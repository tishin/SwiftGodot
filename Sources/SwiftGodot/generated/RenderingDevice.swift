// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
import Foundation
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Abstraction for working with modern low-level graphics APIs.
/// 
/// ``RenderingDevice`` is an abstraction for working with modern low-level graphics APIs such as Vulkan. Compared to ``RenderingServer`` (which works with Godot's own rendering subsystems), ``RenderingDevice`` is much lower-level and allows working more directly with the underlying graphics APIs. ``RenderingDevice`` is used in Godot to provide support for several modern low-level graphics APIs while reducing the amount of code duplication required. ``RenderingDevice`` can also be used in your own projects to perform things that are not exposed by ``RenderingServer`` or high-level nodes, such as using compute shaders.
/// 
/// On startup, Godot creates a global ``RenderingDevice`` which can be retrieved using ``RenderingServer/getRenderingDevice()``. This global ``RenderingDevice`` performs drawing to the screen.
/// 
/// **Local RenderingDevices:** Using ``RenderingServer/createLocalRenderingDevice()``, you can create "secondary" rendering devices to perform drawing and GPU compute operations on separate threads.
/// 
/// > Note: ``RenderingDevice`` assumes intermediate knowledge of modern graphics APIs such as Vulkan, Direct3D 12, Metal or WebGPU. These graphics APIs are lower-level than OpenGL or Direct3D 11, requiring you to perform what was previously done by the graphics driver itself. If you have difficulty understanding the concepts used in this class, follow the <a href="https://vulkan-tutorial.com/">Vulkan Tutorial</a> or <a href="https://vkguide.dev/">Vulkan Guide</a>. It's recommended to have existing modern OpenGL or Direct3D 11 knowledge before attempting to learn a low-level graphics API.
/// 
/// > Note: ``RenderingDevice`` is not available when running in headless mode or when using the Compatibility rendering method.
/// 
open class RenderingDevice: Object {
    override open class var godotClassName: StringName { "RenderingDevice" }
    public enum DeviceType: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Rendering device type does not match any of the other enum values or is unknown.
        case other = 0 // DEVICE_TYPE_OTHER
        /// Rendering device is an integrated GPU, which is typically _(but not always)_ slower than dedicated GPUs (.discreteGpu). On Android and iOS, the rendering device type is always considered to be .integratedGpu.
        case integratedGpu = 1 // DEVICE_TYPE_INTEGRATED_GPU
        /// Rendering device is a dedicated GPU, which is typically _(but not always)_ faster than integrated GPUs (.integratedGpu).
        case discreteGpu = 2 // DEVICE_TYPE_DISCRETE_GPU
        /// Rendering device is an emulated GPU in a virtual environment. This is typically much slower than the host GPU, which means the expected performance level on a dedicated GPU will be roughly equivalent to .integratedGpu. Virtual machine GPU passthrough (such as VFIO) will not report the device type as .virtualGpu. Instead, the host GPU's device type will be reported as if the GPU was not emulated.
        case virtualGpu = 3 // DEVICE_TYPE_VIRTUAL_GPU
        /// Rendering device is provided by software emulation (such as Lavapipe or <a href="https://github.com/google/swiftshader">SwiftShader</a>). This is the slowest kind of rendering device available; it's typically much slower than .integratedGpu.
        case cpu = 4 // DEVICE_TYPE_CPU
        /// Represents the size of the ``RenderingDevice/DeviceType`` enum.
        case max = 5 // DEVICE_TYPE_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .other: return ".other"
                case .integratedGpu: return ".integratedGpu"
                case .discreteGpu: return ".discreteGpu"
                case .virtualGpu: return ".virtualGpu"
                case .cpu: return ".cpu"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum DriverResource: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Specific device object based on a physical device.
        /// 
        /// - Vulkan: Vulkan device driver resource (`VkDevice`). (`rid` argument doesn't apply.)
        /// 
        case logicalDevice = 0 // DRIVER_RESOURCE_LOGICAL_DEVICE
        /// Physical device the specific logical device is based on.
        /// 
        /// - Vulkan: `VkDevice`. (`rid` argument doesn't apply.)
        /// 
        case physicalDevice = 1 // DRIVER_RESOURCE_PHYSICAL_DEVICE
        /// Top-most graphics API entry object.
        /// 
        /// - Vulkan: `VkInstance`. (`rid` argument doesn't apply.)
        /// 
        case topmostObject = 2 // DRIVER_RESOURCE_TOPMOST_OBJECT
        /// The main graphics-compute command queue.
        /// 
        /// - Vulkan: `VkQueue`. (`rid` argument doesn't apply.)
        /// 
        case commandQueue = 3 // DRIVER_RESOURCE_COMMAND_QUEUE
        /// The specific family the main queue belongs to.
        /// 
        /// - Vulkan: the queue family index, an `uint32_t`. (`rid` argument doesn't apply.)
        /// 
        case queueFamily = 4 // DRIVER_RESOURCE_QUEUE_FAMILY
        /// - Vulkan: `VkImage`.
        case texture = 5 // DRIVER_RESOURCE_TEXTURE
        /// The view of an owned or shared texture.
        /// 
        /// - Vulkan: `VkImageView`.
        /// 
        case textureView = 6 // DRIVER_RESOURCE_TEXTURE_VIEW
        /// The native id of the data format of the texture.
        /// 
        /// - Vulkan: `VkFormat`.
        /// 
        case textureDataFormat = 7 // DRIVER_RESOURCE_TEXTURE_DATA_FORMAT
        /// - Vulkan: `VkSampler`.
        case sampler = 8 // DRIVER_RESOURCE_SAMPLER
        /// - Vulkan: `VkDescriptorSet`.
        case uniformSet = 9 // DRIVER_RESOURCE_UNIFORM_SET
        /// Buffer of any kind of (storage, vertex, etc.).
        /// 
        /// - Vulkan: `VkBuffer`.
        /// 
        case buffer = 10 // DRIVER_RESOURCE_BUFFER
        /// - Vulkan: `VkPipeline`.
        case computePipeline = 11 // DRIVER_RESOURCE_COMPUTE_PIPELINE
        /// - Vulkan: `VkPipeline`.
        case renderPipeline = 12 // DRIVER_RESOURCE_RENDER_PIPELINE
        /// 
        // case vulkanDevice = 0 // DRIVER_RESOURCE_VULKAN_DEVICE
        /// 
        // case vulkanPhysicalDevice = 1 // DRIVER_RESOURCE_VULKAN_PHYSICAL_DEVICE
        /// 
        // case vulkanInstance = 2 // DRIVER_RESOURCE_VULKAN_INSTANCE
        /// 
        // case vulkanQueue = 3 // DRIVER_RESOURCE_VULKAN_QUEUE
        /// 
        // case vulkanQueueFamilyIndex = 4 // DRIVER_RESOURCE_VULKAN_QUEUE_FAMILY_INDEX
        /// 
        // case vulkanImage = 5 // DRIVER_RESOURCE_VULKAN_IMAGE
        /// 
        // case vulkanImageView = 6 // DRIVER_RESOURCE_VULKAN_IMAGE_VIEW
        /// 
        // case vulkanImageNativeTextureFormat = 7 // DRIVER_RESOURCE_VULKAN_IMAGE_NATIVE_TEXTURE_FORMAT
        /// 
        // case vulkanSampler = 8 // DRIVER_RESOURCE_VULKAN_SAMPLER
        /// 
        // case vulkanDescriptorSet = 9 // DRIVER_RESOURCE_VULKAN_DESCRIPTOR_SET
        /// 
        // case vulkanBuffer = 10 // DRIVER_RESOURCE_VULKAN_BUFFER
        /// 
        // case vulkanComputePipeline = 11 // DRIVER_RESOURCE_VULKAN_COMPUTE_PIPELINE
        /// 
        // case vulkanRenderPipeline = 12 // DRIVER_RESOURCE_VULKAN_RENDER_PIPELINE
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .logicalDevice: return ".logicalDevice"
                case .physicalDevice: return ".physicalDevice"
                case .topmostObject: return ".topmostObject"
                case .commandQueue: return ".commandQueue"
                case .queueFamily: return ".queueFamily"
                case .texture: return ".texture"
                case .textureView: return ".textureView"
                case .textureDataFormat: return ".textureDataFormat"
                case .sampler: return ".sampler"
                case .uniformSet: return ".uniformSet"
                case .buffer: return ".buffer"
                case .computePipeline: return ".computePipeline"
                case .renderPipeline: return ".renderPipeline"
            }
            
        }
        
    }
    
    public enum DataFormat: Int64, CaseIterable, CustomDebugStringConvertible {
        /// 4-bit-per-channel red/green channel data format, packed into 8 bits. Values are in the `[0.0, 1.0]` range.
        /// 
        /// > Note: More information on all data formats can be found on the <a href="https://registry.khronos.org/vulkan/specs/1.1/html/vkspec.html#_identification_of_formats">Identification of formats</a> section of the Vulkan specification, as well as the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkFormat.html">VkFormat</a> enum.
        /// 
        case r4g4UnormPack8 = 0 // DATA_FORMAT_R4G4_UNORM_PACK8
        /// 4-bit-per-channel red/green/blue/alpha channel data format, packed into 16 bits. Values are in the `[0.0, 1.0]` range.
        case r4g4b4a4UnormPack16 = 1 // DATA_FORMAT_R4G4B4A4_UNORM_PACK16
        /// 4-bit-per-channel blue/green/red/alpha channel data format, packed into 16 bits. Values are in the `[0.0, 1.0]` range.
        case b4g4r4a4UnormPack16 = 2 // DATA_FORMAT_B4G4R4A4_UNORM_PACK16
        /// Red/green/blue channel data format with 5 bits of red, 6 bits of green and 5 bits of blue, packed into 16 bits. Values are in the `[0.0, 1.0]` range.
        case r5g6b5UnormPack16 = 3 // DATA_FORMAT_R5G6B5_UNORM_PACK16
        /// Blue/green/red channel data format with 5 bits of blue, 6 bits of green and 5 bits of red, packed into 16 bits. Values are in the `[0.0, 1.0]` range.
        case b5g6r5UnormPack16 = 4 // DATA_FORMAT_B5G6R5_UNORM_PACK16
        /// Red/green/blue/alpha channel data format with 5 bits of red, 6 bits of green, 5 bits of blue and 1 bit of alpha, packed into 16 bits. Values are in the `[0.0, 1.0]` range.
        case r5g5b5a1UnormPack16 = 5 // DATA_FORMAT_R5G5B5A1_UNORM_PACK16
        /// Blue/green/red/alpha channel data format with 5 bits of blue, 6 bits of green, 5 bits of red and 1 bit of alpha, packed into 16 bits. Values are in the `[0.0, 1.0]` range.
        case b5g5r5a1UnormPack16 = 6 // DATA_FORMAT_B5G5R5A1_UNORM_PACK16
        /// Alpha/red/green/blue channel data format with 1 bit of alpha, 5 bits of red, 6 bits of green and 5 bits of blue, packed into 16 bits. Values are in the `[0.0, 1.0]` range.
        case a1r5g5b5UnormPack16 = 7 // DATA_FORMAT_A1R5G5B5_UNORM_PACK16
        /// 8-bit-per-channel unsigned floating-point red channel data format with normalized value. Values are in the `[0.0, 1.0]` range.
        case r8Unorm = 8 // DATA_FORMAT_R8_UNORM
        /// 8-bit-per-channel signed floating-point red channel data format with normalized value. Values are in the `[-1.0, 1.0]` range.
        case r8Snorm = 9 // DATA_FORMAT_R8_SNORM
        /// 8-bit-per-channel unsigned floating-point red channel data format with scaled value (value is converted from integer to float). Values are in the `[0.0, 255.0]` range.
        case r8Uscaled = 10 // DATA_FORMAT_R8_USCALED
        /// 8-bit-per-channel signed floating-point red channel data format with scaled value (value is converted from integer to float). Values are in the `[-127.0, 127.0]` range.
        case r8Sscaled = 11 // DATA_FORMAT_R8_SSCALED
        /// 8-bit-per-channel unsigned integer red channel data format. Values are in the `[0, 255]` range.
        case r8Uint = 12 // DATA_FORMAT_R8_UINT
        /// 8-bit-per-channel signed integer red channel data format. Values are in the `[-127, 127]` range.
        case r8Sint = 13 // DATA_FORMAT_R8_SINT
        /// 8-bit-per-channel unsigned floating-point red channel data format with normalized value and non-linear sRGB encoding. Values are in the `[0.0, 1.0]` range.
        case r8Srgb = 14 // DATA_FORMAT_R8_SRGB
        /// 8-bit-per-channel unsigned floating-point red/green channel data format with normalized value. Values are in the `[0.0, 1.0]` range.
        case r8g8Unorm = 15 // DATA_FORMAT_R8G8_UNORM
        /// 8-bit-per-channel signed floating-point red/green channel data format with normalized value. Values are in the `[-1.0, 1.0]` range.
        case r8g8Snorm = 16 // DATA_FORMAT_R8G8_SNORM
        /// 8-bit-per-channel unsigned floating-point red/green channel data format with scaled value (value is converted from integer to float). Values are in the `[0.0, 255.0]` range.
        case r8g8Uscaled = 17 // DATA_FORMAT_R8G8_USCALED
        /// 8-bit-per-channel signed floating-point red/green channel data format with scaled value (value is converted from integer to float). Values are in the `[-127.0, 127.0]` range.
        case r8g8Sscaled = 18 // DATA_FORMAT_R8G8_SSCALED
        /// 8-bit-per-channel unsigned integer red/green channel data format. Values are in the `[0, 255]` range.
        case r8g8Uint = 19 // DATA_FORMAT_R8G8_UINT
        /// 8-bit-per-channel signed integer red/green channel data format. Values are in the `[-127, 127]` range.
        case r8g8Sint = 20 // DATA_FORMAT_R8G8_SINT
        /// 8-bit-per-channel unsigned floating-point red/green channel data format with normalized value and non-linear sRGB encoding. Values are in the `[0.0, 1.0]` range.
        case r8g8Srgb = 21 // DATA_FORMAT_R8G8_SRGB
        /// 8-bit-per-channel unsigned floating-point red/green/blue channel data format with normalized value. Values are in the `[0.0, 1.0]` range.
        case r8g8b8Unorm = 22 // DATA_FORMAT_R8G8B8_UNORM
        /// 8-bit-per-channel signed floating-point red/green/blue channel data format with normalized value. Values are in the `[-1.0, 1.0]` range.
        case r8g8b8Snorm = 23 // DATA_FORMAT_R8G8B8_SNORM
        /// 8-bit-per-channel unsigned floating-point red/green/blue channel data format with scaled value (value is converted from integer to float). Values are in the `[0.0, 255.0]` range.
        case r8g8b8Uscaled = 24 // DATA_FORMAT_R8G8B8_USCALED
        /// 8-bit-per-channel signed floating-point red/green/blue channel data format with scaled value (value is converted from integer to float). Values are in the `[-127.0, 127.0]` range.
        case r8g8b8Sscaled = 25 // DATA_FORMAT_R8G8B8_SSCALED
        /// 8-bit-per-channel unsigned integer red/green/blue channel data format. Values are in the `[0, 255]` range.
        case r8g8b8Uint = 26 // DATA_FORMAT_R8G8B8_UINT
        /// 8-bit-per-channel signed integer red/green/blue channel data format. Values are in the `[-127, 127]` range.
        case r8g8b8Sint = 27 // DATA_FORMAT_R8G8B8_SINT
        /// 8-bit-per-channel unsigned floating-point red/green/blue/blue channel data format with normalized value and non-linear sRGB encoding. Values are in the `[0.0, 1.0]` range.
        case r8g8b8Srgb = 28 // DATA_FORMAT_R8G8B8_SRGB
        /// 8-bit-per-channel unsigned floating-point blue/green/red channel data format with normalized value. Values are in the `[0.0, 1.0]` range.
        case b8g8r8Unorm = 29 // DATA_FORMAT_B8G8R8_UNORM
        /// 8-bit-per-channel signed floating-point blue/green/red channel data format with normalized value. Values are in the `[-1.0, 1.0]` range.
        case b8g8r8Snorm = 30 // DATA_FORMAT_B8G8R8_SNORM
        /// 8-bit-per-channel unsigned floating-point blue/green/red channel data format with scaled value (value is converted from integer to float). Values are in the `[0.0, 255.0]` range.
        case b8g8r8Uscaled = 31 // DATA_FORMAT_B8G8R8_USCALED
        /// 8-bit-per-channel signed floating-point blue/green/red channel data format with scaled value (value is converted from integer to float). Values are in the `[-127.0, 127.0]` range.
        case b8g8r8Sscaled = 32 // DATA_FORMAT_B8G8R8_SSCALED
        /// 8-bit-per-channel unsigned integer blue/green/red channel data format. Values are in the `[0, 255]` range.
        case b8g8r8Uint = 33 // DATA_FORMAT_B8G8R8_UINT
        /// 8-bit-per-channel signed integer blue/green/red channel data format. Values are in the `[-127, 127]` range.
        case b8g8r8Sint = 34 // DATA_FORMAT_B8G8R8_SINT
        /// 8-bit-per-channel unsigned floating-point blue/green/red data format with normalized value and non-linear sRGB encoding. Values are in the `[0.0, 1.0]` range.
        case b8g8r8Srgb = 35 // DATA_FORMAT_B8G8R8_SRGB
        /// 8-bit-per-channel unsigned floating-point red/green/blue/alpha channel data format with normalized value. Values are in the `[0.0, 1.0]` range.
        case r8g8b8a8Unorm = 36 // DATA_FORMAT_R8G8B8A8_UNORM
        /// 8-bit-per-channel signed floating-point red/green/blue/alpha channel data format with normalized value. Values are in the `[-1.0, 1.0]` range.
        case r8g8b8a8Snorm = 37 // DATA_FORMAT_R8G8B8A8_SNORM
        /// 8-bit-per-channel unsigned floating-point red/green/blue/alpha channel data format with scaled value (value is converted from integer to float). Values are in the `[0.0, 255.0]` range.
        case r8g8b8a8Uscaled = 38 // DATA_FORMAT_R8G8B8A8_USCALED
        /// 8-bit-per-channel signed floating-point red/green/blue/alpha channel data format with scaled value (value is converted from integer to float). Values are in the `[-127.0, 127.0]` range.
        case r8g8b8a8Sscaled = 39 // DATA_FORMAT_R8G8B8A8_SSCALED
        /// 8-bit-per-channel unsigned integer red/green/blue/alpha channel data format. Values are in the `[0, 255]` range.
        case r8g8b8a8Uint = 40 // DATA_FORMAT_R8G8B8A8_UINT
        /// 8-bit-per-channel signed integer red/green/blue/alpha channel data format. Values are in the `[-127, 127]` range.
        case r8g8b8a8Sint = 41 // DATA_FORMAT_R8G8B8A8_SINT
        /// 8-bit-per-channel unsigned floating-point red/green/blue/alpha channel data format with normalized value and non-linear sRGB encoding. Values are in the `[0.0, 1.0]` range.
        case r8g8b8a8Srgb = 42 // DATA_FORMAT_R8G8B8A8_SRGB
        /// 8-bit-per-channel unsigned floating-point blue/green/red/alpha channel data format with normalized value. Values are in the `[0.0, 1.0]` range.
        case b8g8r8a8Unorm = 43 // DATA_FORMAT_B8G8R8A8_UNORM
        /// 8-bit-per-channel signed floating-point blue/green/red/alpha channel data format with normalized value. Values are in the `[-1.0, 1.0]` range.
        case b8g8r8a8Snorm = 44 // DATA_FORMAT_B8G8R8A8_SNORM
        /// 8-bit-per-channel unsigned floating-point blue/green/red/alpha channel data format with scaled value (value is converted from integer to float). Values are in the `[0.0, 255.0]` range.
        case b8g8r8a8Uscaled = 45 // DATA_FORMAT_B8G8R8A8_USCALED
        /// 8-bit-per-channel signed floating-point blue/green/red/alpha channel data format with scaled value (value is converted from integer to float). Values are in the `[-127.0, 127.0]` range.
        case b8g8r8a8Sscaled = 46 // DATA_FORMAT_B8G8R8A8_SSCALED
        /// 8-bit-per-channel unsigned integer blue/green/red/alpha channel data format. Values are in the `[0, 255]` range.
        case b8g8r8a8Uint = 47 // DATA_FORMAT_B8G8R8A8_UINT
        /// 8-bit-per-channel signed integer blue/green/red/alpha channel data format. Values are in the `[-127, 127]` range.
        case b8g8r8a8Sint = 48 // DATA_FORMAT_B8G8R8A8_SINT
        /// 8-bit-per-channel unsigned floating-point blue/green/red/alpha channel data format with normalized value and non-linear sRGB encoding. Values are in the `[0.0, 1.0]` range.
        case b8g8r8a8Srgb = 49 // DATA_FORMAT_B8G8R8A8_SRGB
        /// 8-bit-per-channel unsigned floating-point alpha/red/green/blue channel data format with normalized value, packed in 32 bits. Values are in the `[0.0, 1.0]` range.
        case a8b8g8r8UnormPack32 = 50 // DATA_FORMAT_A8B8G8R8_UNORM_PACK32
        /// 8-bit-per-channel signed floating-point alpha/red/green/blue channel data format with normalized value, packed in 32 bits. Values are in the `[-1.0, 1.0]` range.
        case a8b8g8r8SnormPack32 = 51 // DATA_FORMAT_A8B8G8R8_SNORM_PACK32
        /// 8-bit-per-channel unsigned floating-point alpha/red/green/blue channel data format with scaled value (value is converted from integer to float), packed in 32 bits. Values are in the `[0.0, 255.0]` range.
        case a8b8g8r8UscaledPack32 = 52 // DATA_FORMAT_A8B8G8R8_USCALED_PACK32
        /// 8-bit-per-channel signed floating-point alpha/red/green/blue channel data format with scaled value (value is converted from integer to float), packed in 32 bits. Values are in the `[-127.0, 127.0]` range.
        case a8b8g8r8SscaledPack32 = 53 // DATA_FORMAT_A8B8G8R8_SSCALED_PACK32
        /// 8-bit-per-channel unsigned integer alpha/red/green/blue channel data format, packed in 32 bits. Values are in the `[0, 255]` range.
        case a8b8g8r8UintPack32 = 54 // DATA_FORMAT_A8B8G8R8_UINT_PACK32
        /// 8-bit-per-channel signed integer alpha/red/green/blue channel data format, packed in 32 bits. Values are in the `[-127, 127]` range.
        case a8b8g8r8SintPack32 = 55 // DATA_FORMAT_A8B8G8R8_SINT_PACK32
        /// 8-bit-per-channel unsigned floating-point alpha/red/green/blue channel data format with normalized value and non-linear sRGB encoding, packed in 32 bits. Values are in the `[0.0, 1.0]` range.
        case a8b8g8r8SrgbPack32 = 56 // DATA_FORMAT_A8B8G8R8_SRGB_PACK32
        /// Unsigned floating-point alpha/red/green/blue channel data format with normalized value, packed in 32 bits. Format contains 2 bits of alpha, 10 bits of red, 10 bits of green and 10 bits of blue. Values are in the `[0.0, 1.0]` range.
        case a2r10g10b10UnormPack32 = 57 // DATA_FORMAT_A2R10G10B10_UNORM_PACK32
        /// Signed floating-point alpha/red/green/blue channel data format with normalized value, packed in 32 bits. Format contains 2 bits of alpha, 10 bits of red, 10 bits of green and 10 bits of blue. Values are in the `[-1.0, 1.0]` range.
        case a2r10g10b10SnormPack32 = 58 // DATA_FORMAT_A2R10G10B10_SNORM_PACK32
        /// Unsigned floating-point alpha/red/green/blue channel data format with normalized value, packed in 32 bits. Format contains 2 bits of alpha, 10 bits of red, 10 bits of green and 10 bits of blue. Values are in the `[0.0, 1023.0]` range for red/green/blue and `[0.0, 3.0]` for alpha.
        case a2r10g10b10UscaledPack32 = 59 // DATA_FORMAT_A2R10G10B10_USCALED_PACK32
        /// Signed floating-point alpha/red/green/blue channel data format with normalized value, packed in 32 bits. Format contains 2 bits of alpha, 10 bits of red, 10 bits of green and 10 bits of blue. Values are in the `[-511.0, 511.0]` range for red/green/blue and `[-1.0, 1.0]` for alpha.
        case a2r10g10b10SscaledPack32 = 60 // DATA_FORMAT_A2R10G10B10_SSCALED_PACK32
        /// Unsigned integer alpha/red/green/blue channel data format with normalized value, packed in 32 bits. Format contains 2 bits of alpha, 10 bits of red, 10 bits of green and 10 bits of blue. Values are in the `[0, 1023]` range for red/green/blue and `[0, 3]` for alpha.
        case a2r10g10b10UintPack32 = 61 // DATA_FORMAT_A2R10G10B10_UINT_PACK32
        /// Signed integer alpha/red/green/blue channel data format with normalized value, packed in 32 bits. Format contains 2 bits of alpha, 10 bits of red, 10 bits of green and 10 bits of blue. Values are in the `[-511, 511]` range for red/green/blue and `[-1, 1]` for alpha.
        case a2r10g10b10SintPack32 = 62 // DATA_FORMAT_A2R10G10B10_SINT_PACK32
        /// Unsigned floating-point alpha/blue/green/red channel data format with normalized value, packed in 32 bits. Format contains 2 bits of alpha, 10 bits of blue, 10 bits of green and 10 bits of red. Values are in the `[0.0, 1.0]` range.
        case a2b10g10r10UnormPack32 = 63 // DATA_FORMAT_A2B10G10R10_UNORM_PACK32
        /// Signed floating-point alpha/blue/green/red channel data format with normalized value, packed in 32 bits. Format contains 2 bits of alpha, 10 bits of blue, 10 bits of green and 10 bits of red. Values are in the `[-1.0, 1.0]` range.
        case a2b10g10r10SnormPack32 = 64 // DATA_FORMAT_A2B10G10R10_SNORM_PACK32
        /// Unsigned floating-point alpha/blue/green/red channel data format with normalized value, packed in 32 bits. Format contains 2 bits of alpha, 10 bits of blue, 10 bits of green and 10 bits of red. Values are in the `[0.0, 1023.0]` range for blue/green/red and `[0.0, 3.0]` for alpha.
        case a2b10g10r10UscaledPack32 = 65 // DATA_FORMAT_A2B10G10R10_USCALED_PACK32
        /// Signed floating-point alpha/blue/green/red channel data format with normalized value, packed in 32 bits. Format contains 2 bits of alpha, 10 bits of blue, 10 bits of green and 10 bits of red. Values are in the `[-511.0, 511.0]` range for blue/green/red and `[-1.0, 1.0]` for alpha.
        case a2b10g10r10SscaledPack32 = 66 // DATA_FORMAT_A2B10G10R10_SSCALED_PACK32
        /// Unsigned integer alpha/blue/green/red channel data format with normalized value, packed in 32 bits. Format contains 2 bits of alpha, 10 bits of blue, 10 bits of green and 10 bits of red. Values are in the `[0, 1023]` range for blue/green/red and `[0, 3]` for alpha.
        case a2b10g10r10UintPack32 = 67 // DATA_FORMAT_A2B10G10R10_UINT_PACK32
        /// Signed integer alpha/blue/green/red channel data format with normalized value, packed in 32 bits. Format contains 2 bits of alpha, 10 bits of blue, 10 bits of green and 10 bits of red. Values are in the `[-511, 511]` range for blue/green/red and `[-1, 1]` for alpha.
        case a2b10g10r10SintPack32 = 68 // DATA_FORMAT_A2B10G10R10_SINT_PACK32
        /// 16-bit-per-channel unsigned floating-point red channel data format with normalized value. Values are in the `[0.0, 1.0]` range.
        case r16Unorm = 69 // DATA_FORMAT_R16_UNORM
        /// 16-bit-per-channel signed floating-point red channel data format with normalized value. Values are in the `[-1.0, 1.0]` range.
        case r16Snorm = 70 // DATA_FORMAT_R16_SNORM
        /// 16-bit-per-channel unsigned floating-point red channel data format with scaled value (value is converted from integer to float). Values are in the `[0.0, 65535.0]` range.
        case r16Uscaled = 71 // DATA_FORMAT_R16_USCALED
        /// 16-bit-per-channel signed floating-point red channel data format with scaled value (value is converted from integer to float). Values are in the `[-32767.0, 32767.0]` range.
        case r16Sscaled = 72 // DATA_FORMAT_R16_SSCALED
        /// 16-bit-per-channel unsigned integer red channel data format. Values are in the `[0.0, 65535]` range.
        case r16Uint = 73 // DATA_FORMAT_R16_UINT
        /// 16-bit-per-channel signed integer red channel data format. Values are in the `[-32767, 32767]` range.
        case r16Sint = 74 // DATA_FORMAT_R16_SINT
        /// 16-bit-per-channel signed floating-point red channel data format with the value stored as-is.
        case r16Sfloat = 75 // DATA_FORMAT_R16_SFLOAT
        /// 16-bit-per-channel unsigned floating-point red/green channel data format with normalized value. Values are in the `[0.0, 1.0]` range.
        case r16g16Unorm = 76 // DATA_FORMAT_R16G16_UNORM
        /// 16-bit-per-channel signed floating-point red/green channel data format with normalized value. Values are in the `[-1.0, 1.0]` range.
        case r16g16Snorm = 77 // DATA_FORMAT_R16G16_SNORM
        /// 16-bit-per-channel unsigned floating-point red/green channel data format with scaled value (value is converted from integer to float). Values are in the `[0.0, 65535.0]` range.
        case r16g16Uscaled = 78 // DATA_FORMAT_R16G16_USCALED
        /// 16-bit-per-channel signed floating-point red/green channel data format with scaled value (value is converted from integer to float). Values are in the `[-32767.0, 32767.0]` range.
        case r16g16Sscaled = 79 // DATA_FORMAT_R16G16_SSCALED
        /// 16-bit-per-channel unsigned integer red/green channel data format. Values are in the `[0.0, 65535]` range.
        case r16g16Uint = 80 // DATA_FORMAT_R16G16_UINT
        /// 16-bit-per-channel signed integer red/green channel data format. Values are in the `[-32767, 32767]` range.
        case r16g16Sint = 81 // DATA_FORMAT_R16G16_SINT
        /// 16-bit-per-channel signed floating-point red/green channel data format with the value stored as-is.
        case r16g16Sfloat = 82 // DATA_FORMAT_R16G16_SFLOAT
        /// 16-bit-per-channel unsigned floating-point red/green/blue channel data format with normalized value. Values are in the `[0.0, 1.0]` range.
        case r16g16b16Unorm = 83 // DATA_FORMAT_R16G16B16_UNORM
        /// 16-bit-per-channel signed floating-point red/green/blue channel data format with normalized value. Values are in the `[-1.0, 1.0]` range.
        case r16g16b16Snorm = 84 // DATA_FORMAT_R16G16B16_SNORM
        /// 16-bit-per-channel unsigned floating-point red/green/blue channel data format with scaled value (value is converted from integer to float). Values are in the `[0.0, 65535.0]` range.
        case r16g16b16Uscaled = 85 // DATA_FORMAT_R16G16B16_USCALED
        /// 16-bit-per-channel signed floating-point red/green/blue channel data format with scaled value (value is converted from integer to float). Values are in the `[-32767.0, 32767.0]` range.
        case r16g16b16Sscaled = 86 // DATA_FORMAT_R16G16B16_SSCALED
        /// 16-bit-per-channel unsigned integer red/green/blue channel data format. Values are in the `[0.0, 65535]` range.
        case r16g16b16Uint = 87 // DATA_FORMAT_R16G16B16_UINT
        /// 16-bit-per-channel signed integer red/green/blue channel data format. Values are in the `[-32767, 32767]` range.
        case r16g16b16Sint = 88 // DATA_FORMAT_R16G16B16_SINT
        /// 16-bit-per-channel signed floating-point red/green/blue channel data format with the value stored as-is.
        case r16g16b16Sfloat = 89 // DATA_FORMAT_R16G16B16_SFLOAT
        /// 16-bit-per-channel unsigned floating-point red/green/blue/alpha channel data format with normalized value. Values are in the `[0.0, 1.0]` range.
        case r16g16b16a16Unorm = 90 // DATA_FORMAT_R16G16B16A16_UNORM
        /// 16-bit-per-channel signed floating-point red/green/blue/alpha channel data format with normalized value. Values are in the `[-1.0, 1.0]` range.
        case r16g16b16a16Snorm = 91 // DATA_FORMAT_R16G16B16A16_SNORM
        /// 16-bit-per-channel unsigned floating-point red/green/blue/alpha channel data format with scaled value (value is converted from integer to float). Values are in the `[0.0, 65535.0]` range.
        case r16g16b16a16Uscaled = 92 // DATA_FORMAT_R16G16B16A16_USCALED
        /// 16-bit-per-channel signed floating-point red/green/blue/alpha channel data format with scaled value (value is converted from integer to float). Values are in the `[-32767.0, 32767.0]` range.
        case r16g16b16a16Sscaled = 93 // DATA_FORMAT_R16G16B16A16_SSCALED
        /// 16-bit-per-channel unsigned integer red/green/blue/alpha channel data format. Values are in the `[0.0, 65535]` range.
        case r16g16b16a16Uint = 94 // DATA_FORMAT_R16G16B16A16_UINT
        /// 16-bit-per-channel signed integer red/green/blue/alpha channel data format. Values are in the `[-32767, 32767]` range.
        case r16g16b16a16Sint = 95 // DATA_FORMAT_R16G16B16A16_SINT
        /// 16-bit-per-channel signed floating-point red/green/blue/alpha channel data format with the value stored as-is.
        case r16g16b16a16Sfloat = 96 // DATA_FORMAT_R16G16B16A16_SFLOAT
        /// 32-bit-per-channel unsigned integer red channel data format. Values are in the `[0, 2^32 - 1]` range.
        case r32Uint = 97 // DATA_FORMAT_R32_UINT
        /// 32-bit-per-channel signed integer red channel data format. Values are in the `[2^31 + 1, 2^31 - 1]` range.
        case r32Sint = 98 // DATA_FORMAT_R32_SINT
        /// 32-bit-per-channel signed floating-point red channel data format with the value stored as-is.
        case r32Sfloat = 99 // DATA_FORMAT_R32_SFLOAT
        /// 32-bit-per-channel unsigned integer red/green channel data format. Values are in the `[0, 2^32 - 1]` range.
        case r32g32Uint = 100 // DATA_FORMAT_R32G32_UINT
        /// 32-bit-per-channel signed integer red/green channel data format. Values are in the `[2^31 + 1, 2^31 - 1]` range.
        case r32g32Sint = 101 // DATA_FORMAT_R32G32_SINT
        /// 32-bit-per-channel signed floating-point red/green channel data format with the value stored as-is.
        case r32g32Sfloat = 102 // DATA_FORMAT_R32G32_SFLOAT
        /// 32-bit-per-channel unsigned integer red/green/blue channel data format. Values are in the `[0, 2^32 - 1]` range.
        case r32g32b32Uint = 103 // DATA_FORMAT_R32G32B32_UINT
        /// 32-bit-per-channel signed integer red/green/blue channel data format. Values are in the `[2^31 + 1, 2^31 - 1]` range.
        case r32g32b32Sint = 104 // DATA_FORMAT_R32G32B32_SINT
        /// 32-bit-per-channel signed floating-point red/green/blue channel data format with the value stored as-is.
        case r32g32b32Sfloat = 105 // DATA_FORMAT_R32G32B32_SFLOAT
        /// 32-bit-per-channel unsigned integer red/green/blue/alpha channel data format. Values are in the `[0, 2^32 - 1]` range.
        case r32g32b32a32Uint = 106 // DATA_FORMAT_R32G32B32A32_UINT
        /// 32-bit-per-channel signed integer red/green/blue/alpha channel data format. Values are in the `[2^31 + 1, 2^31 - 1]` range.
        case r32g32b32a32Sint = 107 // DATA_FORMAT_R32G32B32A32_SINT
        /// 32-bit-per-channel signed floating-point red/green/blue/alpha channel data format with the value stored as-is.
        case r32g32b32a32Sfloat = 108 // DATA_FORMAT_R32G32B32A32_SFLOAT
        /// 64-bit-per-channel unsigned integer red channel data format. Values are in the `[0, 2^64 - 1]` range.
        case r64Uint = 109 // DATA_FORMAT_R64_UINT
        /// 64-bit-per-channel signed integer red channel data format. Values are in the `[2^63 + 1, 2^63 - 1]` range.
        case r64Sint = 110 // DATA_FORMAT_R64_SINT
        /// 64-bit-per-channel signed floating-point red channel data format with the value stored as-is.
        case r64Sfloat = 111 // DATA_FORMAT_R64_SFLOAT
        /// 64-bit-per-channel unsigned integer red/green channel data format. Values are in the `[0, 2^64 - 1]` range.
        case r64g64Uint = 112 // DATA_FORMAT_R64G64_UINT
        /// 64-bit-per-channel signed integer red/green channel data format. Values are in the `[2^63 + 1, 2^63 - 1]` range.
        case r64g64Sint = 113 // DATA_FORMAT_R64G64_SINT
        /// 64-bit-per-channel signed floating-point red/green channel data format with the value stored as-is.
        case r64g64Sfloat = 114 // DATA_FORMAT_R64G64_SFLOAT
        /// 64-bit-per-channel unsigned integer red/green/blue channel data format. Values are in the `[0, 2^64 - 1]` range.
        case r64g64b64Uint = 115 // DATA_FORMAT_R64G64B64_UINT
        /// 64-bit-per-channel signed integer red/green/blue channel data format. Values are in the `[2^63 + 1, 2^63 - 1]` range.
        case r64g64b64Sint = 116 // DATA_FORMAT_R64G64B64_SINT
        /// 64-bit-per-channel signed floating-point red/green/blue channel data format with the value stored as-is.
        case r64g64b64Sfloat = 117 // DATA_FORMAT_R64G64B64_SFLOAT
        /// 64-bit-per-channel unsigned integer red/green/blue/alpha channel data format. Values are in the `[0, 2^64 - 1]` range.
        case r64g64b64a64Uint = 118 // DATA_FORMAT_R64G64B64A64_UINT
        /// 64-bit-per-channel signed integer red/green/blue/alpha channel data format. Values are in the `[2^63 + 1, 2^63 - 1]` range.
        case r64g64b64a64Sint = 119 // DATA_FORMAT_R64G64B64A64_SINT
        /// 64-bit-per-channel signed floating-point red/green/blue/alpha channel data format with the value stored as-is.
        case r64g64b64a64Sfloat = 120 // DATA_FORMAT_R64G64B64A64_SFLOAT
        /// Unsigned floating-point blue/green/red data format with the value stored as-is, packed in 32 bits. The format's precision is 10 bits of blue channel, 11 bits of green channel and 11 bits of red channel.
        case b10g11r11UfloatPack32 = 121 // DATA_FORMAT_B10G11R11_UFLOAT_PACK32
        /// Unsigned floating-point exposure/blue/green/red data format with the value stored as-is, packed in 32 bits. The format's precision is 5 bits of exposure, 9 bits of blue channel, 9 bits of green channel and 9 bits of red channel.
        case e5b9g9r9UfloatPack32 = 122 // DATA_FORMAT_E5B9G9R9_UFLOAT_PACK32
        /// 16-bit unsigned floating-point depth data format with normalized value. Values are in the `[0.0, 1.0]` range.
        case d16Unorm = 123 // DATA_FORMAT_D16_UNORM
        /// 24-bit unsigned floating-point depth data format with normalized value, plus 8 unused bits, packed in 32 bits. Values for depth are in the `[0.0, 1.0]` range.
        case x8D24UnormPack32 = 124 // DATA_FORMAT_X8_D24_UNORM_PACK32
        /// 32-bit signed floating-point depth data format with the value stored as-is.
        case d32Sfloat = 125 // DATA_FORMAT_D32_SFLOAT
        /// 8-bit unsigned integer stencil data format.
        case s8Uint = 126 // DATA_FORMAT_S8_UINT
        /// 16-bit unsigned floating-point depth data format with normalized value, plus 8 bits of stencil in unsigned integer format. Values for depth are in the `[0.0, 1.0]` range. Values for stencil are in the `[0, 255]` range.
        case d16UnormS8Uint = 127 // DATA_FORMAT_D16_UNORM_S8_UINT
        /// 24-bit unsigned floating-point depth data format with normalized value, plus 8 bits of stencil in unsigned integer format. Values for depth are in the `[0.0, 1.0]` range. Values for stencil are in the `[0, 255]` range.
        case d24UnormS8Uint = 128 // DATA_FORMAT_D24_UNORM_S8_UINT
        /// 32-bit signed floating-point depth data format with the value stored as-is, plus 8 bits of stencil in unsigned integer format. Values for stencil are in the `[0, 255]` range.
        case d32SfloatS8Uint = 129 // DATA_FORMAT_D32_SFLOAT_S8_UINT
        /// VRAM-compressed unsigned red/green/blue channel data format with normalized value. Values are in the `[0.0, 1.0]` range. The format's precision is 5 bits of red channel, 6 bits of green channel and 5 bits of blue channel. Using BC1 texture compression (also known as S3TC DXT1).
        case bc1RgbUnormBlock = 130 // DATA_FORMAT_BC1_RGB_UNORM_BLOCK
        /// VRAM-compressed unsigned red/green/blue channel data format with normalized value and non-linear sRGB encoding. Values are in the `[0.0, 1.0]` range. The format's precision is 5 bits of red channel, 6 bits of green channel and 5 bits of blue channel. Using BC1 texture compression (also known as S3TC DXT1).
        case bc1RgbSrgbBlock = 131 // DATA_FORMAT_BC1_RGB_SRGB_BLOCK
        /// VRAM-compressed unsigned red/green/blue/alpha channel data format with normalized value. Values are in the `[0.0, 1.0]` range. The format's precision is 5 bits of red channel, 6 bits of green channel, 5 bits of blue channel and 1 bit of alpha channel. Using BC1 texture compression (also known as S3TC DXT1).
        case bc1RgbaUnormBlock = 132 // DATA_FORMAT_BC1_RGBA_UNORM_BLOCK
        /// VRAM-compressed unsigned red/green/blue/alpha channel data format with normalized value and non-linear sRGB encoding. Values are in the `[0.0, 1.0]` range. The format's precision is 5 bits of red channel, 6 bits of green channel, 5 bits of blue channel and 1 bit of alpha channel. Using BC1 texture compression (also known as S3TC DXT1).
        case bc1RgbaSrgbBlock = 133 // DATA_FORMAT_BC1_RGBA_SRGB_BLOCK
        /// VRAM-compressed unsigned red/green/blue/alpha channel data format with normalized value. Values are in the `[0.0, 1.0]` range. The format's precision is 5 bits of red channel, 6 bits of green channel, 5 bits of blue channel and 4 bits of alpha channel. Using BC2 texture compression (also known as S3TC DXT3).
        case bc2UnormBlock = 134 // DATA_FORMAT_BC2_UNORM_BLOCK
        /// VRAM-compressed unsigned red/green/blue/alpha channel data format with normalized value and non-linear sRGB encoding. Values are in the `[0.0, 1.0]` range. The format's precision is 5 bits of red channel, 6 bits of green channel, 5 bits of blue channel and 4 bits of alpha channel. Using BC2 texture compression (also known as S3TC DXT3).
        case bc2SrgbBlock = 135 // DATA_FORMAT_BC2_SRGB_BLOCK
        /// VRAM-compressed unsigned red/green/blue/alpha channel data format with normalized value. Values are in the `[0.0, 1.0]` range. The format's precision is 5 bits of red channel, 6 bits of green channel, 5 bits of blue channel and 8 bits of alpha channel. Using BC3 texture compression (also known as S3TC DXT5).
        case bc3UnormBlock = 136 // DATA_FORMAT_BC3_UNORM_BLOCK
        /// VRAM-compressed unsigned red/green/blue/alpha channel data format with normalized value and non-linear sRGB encoding. Values are in the `[0.0, 1.0]` range. The format's precision is 5 bits of red channel, 6 bits of green channel, 5 bits of blue channel and 8 bits of alpha channel. Using BC3 texture compression (also known as S3TC DXT5).
        case bc3SrgbBlock = 137 // DATA_FORMAT_BC3_SRGB_BLOCK
        /// VRAM-compressed unsigned red channel data format with normalized value. Values are in the `[0.0, 1.0]` range. The format's precision is 8 bits of red channel. Using BC4 texture compression.
        case bc4UnormBlock = 138 // DATA_FORMAT_BC4_UNORM_BLOCK
        /// VRAM-compressed signed red channel data format with normalized value. Values are in the `[-1.0, 1.0]` range. The format's precision is 8 bits of red channel. Using BC4 texture compression.
        case bc4SnormBlock = 139 // DATA_FORMAT_BC4_SNORM_BLOCK
        /// VRAM-compressed unsigned red/green channel data format with normalized value. Values are in the `[0.0, 1.0]` range. The format's precision is 8 bits of red channel and 8 bits of green channel. Using BC5 texture compression (also known as S3TC RGTC).
        case bc5UnormBlock = 140 // DATA_FORMAT_BC5_UNORM_BLOCK
        /// VRAM-compressed signed red/green channel data format with normalized value. Values are in the `[-1.0, 1.0]` range. The format's precision is 8 bits of red channel and 8 bits of green channel. Using BC5 texture compression (also known as S3TC RGTC).
        case bc5SnormBlock = 141 // DATA_FORMAT_BC5_SNORM_BLOCK
        /// VRAM-compressed unsigned red/green/blue channel data format with the floating-point value stored as-is. The format's precision is 8 bits of red channel and 8 bits of green channel. Using BC6H texture compression (also known as BPTC HDR).
        case bc6hUfloatBlock = 142 // DATA_FORMAT_BC6H_UFLOAT_BLOCK
        /// VRAM-compressed signed red/green/blue channel data format with the floating-point value stored as-is. The format's precision is between 4 and 7 bits for the red/green/blue channels and between 0 and 8 bits for the alpha channel. Using BC7 texture compression (also known as BPTC HDR).
        case bc6hSfloatBlock = 143 // DATA_FORMAT_BC6H_SFLOAT_BLOCK
        /// VRAM-compressed unsigned red/green/blue/alpha channel data format with normalized value. Values are in the `[0.0, 1.0]` range. The format's precision is between 4 and 7 bits for the red/green/blue channels and between 0 and 8 bits for the alpha channel. Also known as BPTC LDR.
        case bc7UnormBlock = 144 // DATA_FORMAT_BC7_UNORM_BLOCK
        /// VRAM-compressed unsigned red/green/blue/alpha channel data format with normalized value and non-linear sRGB encoding. Values are in the `[0.0, 1.0]` range. The format's precision is between 4 and 7 bits for the red/green/blue channels and between 0 and 8 bits for the alpha channel. Also known as BPTC LDR.
        case bc7SrgbBlock = 145 // DATA_FORMAT_BC7_SRGB_BLOCK
        /// VRAM-compressed unsigned red/green/blue channel data format with normalized value. Values are in the `[0.0, 1.0]` range. Using ETC2 texture compression.
        case etc2R8g8b8UnormBlock = 146 // DATA_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
        /// VRAM-compressed unsigned red/green/blue channel data format with normalized value and non-linear sRGB encoding. Values are in the `[0.0, 1.0]` range. Using ETC2 texture compression.
        case etc2R8g8b8SrgbBlock = 147 // DATA_FORMAT_ETC2_R8G8B8_SRGB_BLOCK
        /// VRAM-compressed unsigned red/green/blue/alpha channel data format with normalized value. Values are in the `[0.0, 1.0]` range. Red/green/blue use 8 bit of precision each, with alpha using 1 bit of precision. Using ETC2 texture compression.
        case etc2R8g8b8a1UnormBlock = 148 // DATA_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK
        /// VRAM-compressed unsigned red/green/blue/alpha channel data format with normalized value and non-linear sRGB encoding. Values are in the `[0.0, 1.0]` range. Red/green/blue use 8 bit of precision each, with alpha using 1 bit of precision. Using ETC2 texture compression.
        case etc2R8g8b8a1SrgbBlock = 149 // DATA_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK
        /// VRAM-compressed unsigned red/green/blue/alpha channel data format with normalized value. Values are in the `[0.0, 1.0]` range. Red/green/blue use 8 bits of precision each, with alpha using 8 bits of precision. Using ETC2 texture compression.
        case etc2R8g8b8a8UnormBlock = 150 // DATA_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK
        /// VRAM-compressed unsigned red/green/blue/alpha channel data format with normalized value and non-linear sRGB encoding. Values are in the `[0.0, 1.0]` range. Red/green/blue use 8 bits of precision each, with alpha using 8 bits of precision. Using ETC2 texture compression.
        case etc2R8g8b8a8SrgbBlock = 151 // DATA_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK
        /// 11-bit VRAM-compressed unsigned red channel data format with normalized value. Values are in the `[0.0, 1.0]` range. Using ETC2 texture compression.
        case eacR11UnormBlock = 152 // DATA_FORMAT_EAC_R11_UNORM_BLOCK
        /// 11-bit VRAM-compressed signed red channel data format with normalized value. Values are in the `[0.0, 1.0]` range. Using ETC2 texture compression.
        case eacR11SnormBlock = 153 // DATA_FORMAT_EAC_R11_SNORM_BLOCK
        /// 11-bit VRAM-compressed unsigned red/green channel data format with normalized value. Values are in the `[0.0, 1.0]` range. Using ETC2 texture compression.
        case eacR11g11UnormBlock = 154 // DATA_FORMAT_EAC_R11G11_UNORM_BLOCK
        /// 11-bit VRAM-compressed signed red/green channel data format with normalized value. Values are in the `[0.0, 1.0]` range. Using ETC2 texture compression.
        case eacR11g11SnormBlock = 155 // DATA_FORMAT_EAC_R11G11_SNORM_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value, packed in 4×4 blocks (highest quality). Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc4x4UnormBlock = 156 // DATA_FORMAT_ASTC_4x4_UNORM_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value and non-linear sRGB encoding, packed in 4×4 blocks (highest quality). Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc4x4SrgbBlock = 157 // DATA_FORMAT_ASTC_4x4_SRGB_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value, packed in 5×4 blocks. Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc5x4UnormBlock = 158 // DATA_FORMAT_ASTC_5x4_UNORM_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value and non-linear sRGB encoding, packed in 5×4 blocks. Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc5x4SrgbBlock = 159 // DATA_FORMAT_ASTC_5x4_SRGB_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value, packed in 5×5 blocks. Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc5x5UnormBlock = 160 // DATA_FORMAT_ASTC_5x5_UNORM_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value and non-linear sRGB encoding, packed in 5×5 blocks. Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc5x5SrgbBlock = 161 // DATA_FORMAT_ASTC_5x5_SRGB_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value, packed in 6×5 blocks. Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc6x5UnormBlock = 162 // DATA_FORMAT_ASTC_6x5_UNORM_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value and non-linear sRGB encoding, packed in 6×5 blocks. Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc6x5SrgbBlock = 163 // DATA_FORMAT_ASTC_6x5_SRGB_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value, packed in 6×6 blocks. Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc6x6UnormBlock = 164 // DATA_FORMAT_ASTC_6x6_UNORM_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value and non-linear sRGB encoding, packed in 6×6 blocks. Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc6x6SrgbBlock = 165 // DATA_FORMAT_ASTC_6x6_SRGB_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value, packed in 8×5 blocks. Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc8x5UnormBlock = 166 // DATA_FORMAT_ASTC_8x5_UNORM_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value and non-linear sRGB encoding, packed in 8×5 blocks. Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc8x5SrgbBlock = 167 // DATA_FORMAT_ASTC_8x5_SRGB_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value, packed in 8×6 blocks. Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc8x6UnormBlock = 168 // DATA_FORMAT_ASTC_8x6_UNORM_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value and non-linear sRGB encoding, packed in 8×6 blocks. Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc8x6SrgbBlock = 169 // DATA_FORMAT_ASTC_8x6_SRGB_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value, packed in 8×8 blocks. Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc8x8UnormBlock = 170 // DATA_FORMAT_ASTC_8x8_UNORM_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value and non-linear sRGB encoding, packed in 8×8 blocks. Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc8x8SrgbBlock = 171 // DATA_FORMAT_ASTC_8x8_SRGB_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value, packed in 10×5 blocks. Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc10x5UnormBlock = 172 // DATA_FORMAT_ASTC_10x5_UNORM_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value and non-linear sRGB encoding, packed in 10×5 blocks. Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc10x5SrgbBlock = 173 // DATA_FORMAT_ASTC_10x5_SRGB_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value, packed in 10×6 blocks. Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc10x6UnormBlock = 174 // DATA_FORMAT_ASTC_10x6_UNORM_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value and non-linear sRGB encoding, packed in 10×6 blocks. Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc10x6SrgbBlock = 175 // DATA_FORMAT_ASTC_10x6_SRGB_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value, packed in 10×8 blocks. Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc10x8UnormBlock = 176 // DATA_FORMAT_ASTC_10x8_UNORM_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value and non-linear sRGB encoding, packed in 10×8 blocks. Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc10x8SrgbBlock = 177 // DATA_FORMAT_ASTC_10x8_SRGB_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value, packed in 10×10 blocks. Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc10x10UnormBlock = 178 // DATA_FORMAT_ASTC_10x10_UNORM_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value and non-linear sRGB encoding, packed in 10×10 blocks. Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc10x10SrgbBlock = 179 // DATA_FORMAT_ASTC_10x10_SRGB_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value, packed in 12×10 blocks. Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc12x10UnormBlock = 180 // DATA_FORMAT_ASTC_12x10_UNORM_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value and non-linear sRGB encoding, packed in 12×10 blocks. Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc12x10SrgbBlock = 181 // DATA_FORMAT_ASTC_12x10_SRGB_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value, packed in 12 blocks (lowest quality). Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc12x12UnormBlock = 182 // DATA_FORMAT_ASTC_12x12_UNORM_BLOCK
        /// VRAM-compressed unsigned floating-point data format with normalized value and non-linear sRGB encoding, packed in 12 blocks (lowest quality). Values are in the `[0.0, 1.0]` range. Using ASTC compression.
        case astc12x12SrgbBlock = 183 // DATA_FORMAT_ASTC_12x12_SRGB_BLOCK
        /// 8-bit-per-channel unsigned floating-point green/blue/red channel data format with normalized value. Values are in the `[0.0, 1.0]` range. Blue and red channel data is stored at halved horizontal resolution (i.e. 2 horizontally adjacent pixels will share the same value for the blue/red channel).
        case g8b8g8r8422Unorm = 184 // DATA_FORMAT_G8B8G8R8_422_UNORM
        /// 8-bit-per-channel unsigned floating-point blue/green/red channel data format with normalized value. Values are in the `[0.0, 1.0]` range. Blue and red channel data is stored at halved horizontal resolution (i.e. 2 horizontally adjacent pixels will share the same value for the blue/red channel).
        case b8g8r8g8422Unorm = 185 // DATA_FORMAT_B8G8R8G8_422_UNORM
        /// 8-bit-per-channel unsigned floating-point green/blue/red channel data with normalized value, stored across 3 separate planes (green + blue + red). Values are in the `[0.0, 1.0]` range. Blue and red channel data is stored at halved horizontal and vertical resolution (i.e. 2×2 adjacent pixels will share the same value for the blue/red channel).
        case g8B8R83plane420Unorm = 186 // DATA_FORMAT_G8_B8_R8_3PLANE_420_UNORM
        /// 8-bit-per-channel unsigned floating-point green/blue/red channel data with normalized value, stored across 2 separate planes (green + blue/red). Values are in the `[0.0, 1.0]` range. Blue and red channel data is stored at halved horizontal and vertical resolution (i.e. 2×2 adjacent pixels will share the same value for the blue/red channel).
        case g8B8r82plane420Unorm = 187 // DATA_FORMAT_G8_B8R8_2PLANE_420_UNORM
        /// 8-bit-per-channel unsigned floating-point green/blue/red channel data with normalized value, stored across 2 separate planes (green + blue + red). Values are in the `[0.0, 1.0]` range. Blue and red channel data is stored at halved horizontal resolution (i.e. 2 horizontally adjacent pixels will share the same value for the blue/red channel).
        case g8B8R83plane422Unorm = 188 // DATA_FORMAT_G8_B8_R8_3PLANE_422_UNORM
        /// 8-bit-per-channel unsigned floating-point green/blue/red channel data with normalized value, stored across 2 separate planes (green + blue/red). Values are in the `[0.0, 1.0]` range. Blue and red channel data is stored at halved horizontal resolution (i.e. 2 horizontally adjacent pixels will share the same value for the blue/red channel).
        case g8B8r82plane422Unorm = 189 // DATA_FORMAT_G8_B8R8_2PLANE_422_UNORM
        /// 8-bit-per-channel unsigned floating-point green/blue/red channel data with normalized value, stored across 3 separate planes. Values are in the `[0.0, 1.0]` range.
        case g8B8R83plane444Unorm = 190 // DATA_FORMAT_G8_B8_R8_3PLANE_444_UNORM
        /// 10-bit-per-channel unsigned floating-point red channel data with normalized value, plus 6 unused bits, packed in 16 bits. Values are in the `[0.0, 1.0]` range.
        case r10x6UnormPack16 = 191 // DATA_FORMAT_R10X6_UNORM_PACK16
        /// 10-bit-per-channel unsigned floating-point red/green channel data with normalized value, plus 6 unused bits after each channel, packed in 2×16 bits. Values are in the `[0.0, 1.0]` range.
        case r10x6g10x6Unorm2pack16 = 192 // DATA_FORMAT_R10X6G10X6_UNORM_2PACK16
        /// 10-bit-per-channel unsigned floating-point red/green/blue/alpha channel data with normalized value, plus 6 unused bits after each channel, packed in 4×16 bits. Values are in the `[0.0, 1.0]` range.
        case r10x6g10x6b10x6a10x6Unorm4pack16 = 193 // DATA_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16
        /// 10-bit-per-channel unsigned floating-point green/blue/green/red channel data with normalized value, plus 6 unused bits after each channel, packed in 4×16 bits. Values are in the `[0.0, 1.0]` range. Blue and red channel data is stored at halved horizontal resolution (i.e. 2 horizontally adjacent pixels will share the same value for the blue/red channel). The green channel is listed twice, but contains different values to allow it to be represented at full resolution.
        case g10x6b10x6g10x6r10x6422Unorm4pack16 = 194 // DATA_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16
        /// 10-bit-per-channel unsigned floating-point blue/green/red/green channel data with normalized value, plus 6 unused bits after each channel, packed in 4×16 bits. Values are in the `[0.0, 1.0]` range. Blue and red channel data is stored at halved horizontal resolution (i.e. 2 horizontally adjacent pixels will share the same value for the blue/red channel). The green channel is listed twice, but contains different values to allow it to be represented at full resolution.
        case b10x6g10x6r10x6g10x6422Unorm4pack16 = 195 // DATA_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16
        /// 10-bit-per-channel unsigned floating-point green/blue/red channel data with normalized value, plus 6 unused bits after each channel. Packed in 3×16 bits and stored across 2 separate planes (green + blue + red). Values are in the `[0.0, 1.0]` range. Blue and red channel data is stored at halved horizontal and vertical resolution (i.e. 2×2 adjacent pixels will share the same value for the blue/red channel).
        case g10x6B10x6R10x63plane420Unorm3pack16 = 196 // DATA_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16
        /// 10-bit-per-channel unsigned floating-point green/blue/red channel data with normalized value, plus 6 unused bits after each channel. Packed in 3×16 bits and stored across 2 separate planes (green + blue/red). Values are in the `[0.0, 1.0]` range. Blue and red channel data is stored at halved horizontal and vertical resolution (i.e. 2×2 adjacent pixels will share the same value for the blue/red channel).
        case g10x6B10x6r10x62plane420Unorm3pack16 = 197 // DATA_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16
        /// 10-bit-per-channel unsigned floating-point green/blue/red channel data with normalized value, plus 6 unused bits after each channel. Packed in 3×16 bits and stored across 3 separate planes (green + blue + red). Values are in the `[0.0, 1.0]` range. Blue and red channel data is stored at halved horizontal resolution (i.e. 2 horizontally adjacent pixels will share the same value for the blue/red channel).
        case g10x6B10x6R10x63plane422Unorm3pack16 = 198 // DATA_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16
        /// 10-bit-per-channel unsigned floating-point green/blue/red channel data with normalized value, plus 6 unused bits after each channel. Packed in 3×16 bits and stored across 3 separate planes (green + blue/red). Values are in the `[0.0, 1.0]` range. Blue and red channel data is stored at halved horizontal resolution (i.e. 2 horizontally adjacent pixels will share the same value for the blue/red channel).
        case g10x6B10x6r10x62plane422Unorm3pack16 = 199 // DATA_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16
        /// 10-bit-per-channel unsigned floating-point green/blue/red channel data with normalized value, plus 6 unused bits after each channel. Packed in 3×16 bits and stored across 3 separate planes (green + blue + red). Values are in the `[0.0, 1.0]` range.
        case g10x6B10x6R10x63plane444Unorm3pack16 = 200 // DATA_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16
        /// 12-bit-per-channel unsigned floating-point red channel data with normalized value, plus 6 unused bits, packed in 16 bits. Values are in the `[0.0, 1.0]` range.
        case r12x4UnormPack16 = 201 // DATA_FORMAT_R12X4_UNORM_PACK16
        /// 12-bit-per-channel unsigned floating-point red/green channel data with normalized value, plus 6 unused bits after each channel, packed in 2×16 bits. Values are in the `[0.0, 1.0]` range.
        case r12x4g12x4Unorm2pack16 = 202 // DATA_FORMAT_R12X4G12X4_UNORM_2PACK16
        /// 12-bit-per-channel unsigned floating-point red/green/blue/alpha channel data with normalized value, plus 6 unused bits after each channel, packed in 4×16 bits. Values are in the `[0.0, 1.0]` range.
        case r12x4g12x4b12x4a12x4Unorm4pack16 = 203 // DATA_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16
        /// 12-bit-per-channel unsigned floating-point green/blue/green/red channel data with normalized value, plus 6 unused bits after each channel, packed in 4×16 bits. Values are in the `[0.0, 1.0]` range. Blue and red channel data is stored at halved horizontal resolution (i.e. 2 horizontally adjacent pixels will share the same value for the blue/red channel). The green channel is listed twice, but contains different values to allow it to be represented at full resolution.
        case g12x4b12x4g12x4r12x4422Unorm4pack16 = 204 // DATA_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16
        /// 12-bit-per-channel unsigned floating-point blue/green/red/green channel data with normalized value, plus 6 unused bits after each channel, packed in 4×16 bits. Values are in the `[0.0, 1.0]` range. Blue and red channel data is stored at halved horizontal resolution (i.e. 2 horizontally adjacent pixels will share the same value for the blue/red channel). The green channel is listed twice, but contains different values to allow it to be represented at full resolution.
        case b12x4g12x4r12x4g12x4422Unorm4pack16 = 205 // DATA_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16
        /// 12-bit-per-channel unsigned floating-point green/blue/red channel data with normalized value, plus 6 unused bits after each channel. Packed in 3×16 bits and stored across 2 separate planes (green + blue + red). Values are in the `[0.0, 1.0]` range. Blue and red channel data is stored at halved horizontal and vertical resolution (i.e. 2×2 adjacent pixels will share the same value for the blue/red channel).
        case g12x4B12x4R12x43plane420Unorm3pack16 = 206 // DATA_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16
        /// 12-bit-per-channel unsigned floating-point green/blue/red channel data with normalized value, plus 6 unused bits after each channel. Packed in 3×16 bits and stored across 2 separate planes (green + blue/red). Values are in the `[0.0, 1.0]` range. Blue and red channel data is stored at halved horizontal and vertical resolution (i.e. 2×2 adjacent pixels will share the same value for the blue/red channel).
        case g12x4B12x4r12x42plane420Unorm3pack16 = 207 // DATA_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16
        /// 12-bit-per-channel unsigned floating-point green/blue/red channel data with normalized value, plus 6 unused bits after each channel. Packed in 3×16 bits and stored across 3 separate planes (green + blue + red). Values are in the `[0.0, 1.0]` range. Blue and red channel data is stored at halved horizontal resolution (i.e. 2 horizontally adjacent pixels will share the same value for the blue/red channel).
        case g12x4B12x4R12x43plane422Unorm3pack16 = 208 // DATA_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16
        /// 12-bit-per-channel unsigned floating-point green/blue/red channel data with normalized value, plus 6 unused bits after each channel. Packed in 3×16 bits and stored across 3 separate planes (green + blue/red). Values are in the `[0.0, 1.0]` range. Blue and red channel data is stored at halved horizontal resolution (i.e. 2 horizontally adjacent pixels will share the same value for the blue/red channel).
        case g12x4B12x4r12x42plane422Unorm3pack16 = 209 // DATA_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16
        /// 12-bit-per-channel unsigned floating-point green/blue/red channel data with normalized value, plus 6 unused bits after each channel. Packed in 3×16 bits and stored across 3 separate planes (green + blue + red). Values are in the `[0.0, 1.0]` range.
        case g12x4B12x4R12x43plane444Unorm3pack16 = 210 // DATA_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16
        /// 16-bit-per-channel unsigned floating-point green/blue/red channel data format with normalized value. Values are in the `[0.0, 1.0]` range. Blue and red channel data is stored at halved horizontal resolution (i.e. 2 horizontally adjacent pixels will share the same value for the blue/red channel).
        case g16b16g16r16422Unorm = 211 // DATA_FORMAT_G16B16G16R16_422_UNORM
        /// 16-bit-per-channel unsigned floating-point blue/green/red channel data format with normalized value. Values are in the `[0.0, 1.0]` range. Blue and red channel data is stored at halved horizontal resolution (i.e. 2 horizontally adjacent pixels will share the same value for the blue/red channel).
        case b16g16r16g16422Unorm = 212 // DATA_FORMAT_B16G16R16G16_422_UNORM
        /// 16-bit-per-channel unsigned floating-point green/blue/red channel data with normalized value, plus 6 unused bits after each channel. Stored across 2 separate planes (green + blue + red). Values are in the `[0.0, 1.0]` range. Blue and red channel data is stored at halved horizontal and vertical resolution (i.e. 2×2 adjacent pixels will share the same value for the blue/red channel).
        case g16B16R163plane420Unorm = 213 // DATA_FORMAT_G16_B16_R16_3PLANE_420_UNORM
        /// 16-bit-per-channel unsigned floating-point green/blue/red channel data with normalized value, plus 6 unused bits after each channel. Stored across 2 separate planes (green + blue/red). Values are in the `[0.0, 1.0]` range. Blue and red channel data is stored at halved horizontal and vertical resolution (i.e. 2×2 adjacent pixels will share the same value for the blue/red channel).
        case g16B16r162plane420Unorm = 214 // DATA_FORMAT_G16_B16R16_2PLANE_420_UNORM
        /// 16-bit-per-channel unsigned floating-point green/blue/red channel data with normalized value, plus 6 unused bits after each channel. Stored across 3 separate planes (green + blue + red). Values are in the `[0.0, 1.0]` range. Blue and red channel data is stored at halved horizontal resolution (i.e. 2 horizontally adjacent pixels will share the same value for the blue/red channel).
        case g16B16R163plane422Unorm = 215 // DATA_FORMAT_G16_B16_R16_3PLANE_422_UNORM
        /// 16-bit-per-channel unsigned floating-point green/blue/red channel data with normalized value, plus 6 unused bits after each channel. Stored across 3 separate planes (green + blue/red). Values are in the `[0.0, 1.0]` range. Blue and red channel data is stored at halved horizontal resolution (i.e. 2 horizontally adjacent pixels will share the same value for the blue/red channel).
        case g16B16r162plane422Unorm = 216 // DATA_FORMAT_G16_B16R16_2PLANE_422_UNORM
        /// 16-bit-per-channel unsigned floating-point green/blue/red channel data with normalized value, plus 6 unused bits after each channel. Stored across 3 separate planes (green + blue + red). Values are in the `[0.0, 1.0]` range.
        case g16B16R163plane444Unorm = 217 // DATA_FORMAT_G16_B16_R16_3PLANE_444_UNORM
        /// Represents the size of the ``RenderingDevice/DataFormat`` enum.
        case max = 218 // DATA_FORMAT_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .r4g4UnormPack8: return ".r4g4UnormPack8"
                case .r4g4b4a4UnormPack16: return ".r4g4b4a4UnormPack16"
                case .b4g4r4a4UnormPack16: return ".b4g4r4a4UnormPack16"
                case .r5g6b5UnormPack16: return ".r5g6b5UnormPack16"
                case .b5g6r5UnormPack16: return ".b5g6r5UnormPack16"
                case .r5g5b5a1UnormPack16: return ".r5g5b5a1UnormPack16"
                case .b5g5r5a1UnormPack16: return ".b5g5r5a1UnormPack16"
                case .a1r5g5b5UnormPack16: return ".a1r5g5b5UnormPack16"
                case .r8Unorm: return ".r8Unorm"
                case .r8Snorm: return ".r8Snorm"
                case .r8Uscaled: return ".r8Uscaled"
                case .r8Sscaled: return ".r8Sscaled"
                case .r8Uint: return ".r8Uint"
                case .r8Sint: return ".r8Sint"
                case .r8Srgb: return ".r8Srgb"
                case .r8g8Unorm: return ".r8g8Unorm"
                case .r8g8Snorm: return ".r8g8Snorm"
                case .r8g8Uscaled: return ".r8g8Uscaled"
                case .r8g8Sscaled: return ".r8g8Sscaled"
                case .r8g8Uint: return ".r8g8Uint"
                case .r8g8Sint: return ".r8g8Sint"
                case .r8g8Srgb: return ".r8g8Srgb"
                case .r8g8b8Unorm: return ".r8g8b8Unorm"
                case .r8g8b8Snorm: return ".r8g8b8Snorm"
                case .r8g8b8Uscaled: return ".r8g8b8Uscaled"
                case .r8g8b8Sscaled: return ".r8g8b8Sscaled"
                case .r8g8b8Uint: return ".r8g8b8Uint"
                case .r8g8b8Sint: return ".r8g8b8Sint"
                case .r8g8b8Srgb: return ".r8g8b8Srgb"
                case .b8g8r8Unorm: return ".b8g8r8Unorm"
                case .b8g8r8Snorm: return ".b8g8r8Snorm"
                case .b8g8r8Uscaled: return ".b8g8r8Uscaled"
                case .b8g8r8Sscaled: return ".b8g8r8Sscaled"
                case .b8g8r8Uint: return ".b8g8r8Uint"
                case .b8g8r8Sint: return ".b8g8r8Sint"
                case .b8g8r8Srgb: return ".b8g8r8Srgb"
                case .r8g8b8a8Unorm: return ".r8g8b8a8Unorm"
                case .r8g8b8a8Snorm: return ".r8g8b8a8Snorm"
                case .r8g8b8a8Uscaled: return ".r8g8b8a8Uscaled"
                case .r8g8b8a8Sscaled: return ".r8g8b8a8Sscaled"
                case .r8g8b8a8Uint: return ".r8g8b8a8Uint"
                case .r8g8b8a8Sint: return ".r8g8b8a8Sint"
                case .r8g8b8a8Srgb: return ".r8g8b8a8Srgb"
                case .b8g8r8a8Unorm: return ".b8g8r8a8Unorm"
                case .b8g8r8a8Snorm: return ".b8g8r8a8Snorm"
                case .b8g8r8a8Uscaled: return ".b8g8r8a8Uscaled"
                case .b8g8r8a8Sscaled: return ".b8g8r8a8Sscaled"
                case .b8g8r8a8Uint: return ".b8g8r8a8Uint"
                case .b8g8r8a8Sint: return ".b8g8r8a8Sint"
                case .b8g8r8a8Srgb: return ".b8g8r8a8Srgb"
                case .a8b8g8r8UnormPack32: return ".a8b8g8r8UnormPack32"
                case .a8b8g8r8SnormPack32: return ".a8b8g8r8SnormPack32"
                case .a8b8g8r8UscaledPack32: return ".a8b8g8r8UscaledPack32"
                case .a8b8g8r8SscaledPack32: return ".a8b8g8r8SscaledPack32"
                case .a8b8g8r8UintPack32: return ".a8b8g8r8UintPack32"
                case .a8b8g8r8SintPack32: return ".a8b8g8r8SintPack32"
                case .a8b8g8r8SrgbPack32: return ".a8b8g8r8SrgbPack32"
                case .a2r10g10b10UnormPack32: return ".a2r10g10b10UnormPack32"
                case .a2r10g10b10SnormPack32: return ".a2r10g10b10SnormPack32"
                case .a2r10g10b10UscaledPack32: return ".a2r10g10b10UscaledPack32"
                case .a2r10g10b10SscaledPack32: return ".a2r10g10b10SscaledPack32"
                case .a2r10g10b10UintPack32: return ".a2r10g10b10UintPack32"
                case .a2r10g10b10SintPack32: return ".a2r10g10b10SintPack32"
                case .a2b10g10r10UnormPack32: return ".a2b10g10r10UnormPack32"
                case .a2b10g10r10SnormPack32: return ".a2b10g10r10SnormPack32"
                case .a2b10g10r10UscaledPack32: return ".a2b10g10r10UscaledPack32"
                case .a2b10g10r10SscaledPack32: return ".a2b10g10r10SscaledPack32"
                case .a2b10g10r10UintPack32: return ".a2b10g10r10UintPack32"
                case .a2b10g10r10SintPack32: return ".a2b10g10r10SintPack32"
                case .r16Unorm: return ".r16Unorm"
                case .r16Snorm: return ".r16Snorm"
                case .r16Uscaled: return ".r16Uscaled"
                case .r16Sscaled: return ".r16Sscaled"
                case .r16Uint: return ".r16Uint"
                case .r16Sint: return ".r16Sint"
                case .r16Sfloat: return ".r16Sfloat"
                case .r16g16Unorm: return ".r16g16Unorm"
                case .r16g16Snorm: return ".r16g16Snorm"
                case .r16g16Uscaled: return ".r16g16Uscaled"
                case .r16g16Sscaled: return ".r16g16Sscaled"
                case .r16g16Uint: return ".r16g16Uint"
                case .r16g16Sint: return ".r16g16Sint"
                case .r16g16Sfloat: return ".r16g16Sfloat"
                case .r16g16b16Unorm: return ".r16g16b16Unorm"
                case .r16g16b16Snorm: return ".r16g16b16Snorm"
                case .r16g16b16Uscaled: return ".r16g16b16Uscaled"
                case .r16g16b16Sscaled: return ".r16g16b16Sscaled"
                case .r16g16b16Uint: return ".r16g16b16Uint"
                case .r16g16b16Sint: return ".r16g16b16Sint"
                case .r16g16b16Sfloat: return ".r16g16b16Sfloat"
                case .r16g16b16a16Unorm: return ".r16g16b16a16Unorm"
                case .r16g16b16a16Snorm: return ".r16g16b16a16Snorm"
                case .r16g16b16a16Uscaled: return ".r16g16b16a16Uscaled"
                case .r16g16b16a16Sscaled: return ".r16g16b16a16Sscaled"
                case .r16g16b16a16Uint: return ".r16g16b16a16Uint"
                case .r16g16b16a16Sint: return ".r16g16b16a16Sint"
                case .r16g16b16a16Sfloat: return ".r16g16b16a16Sfloat"
                case .r32Uint: return ".r32Uint"
                case .r32Sint: return ".r32Sint"
                case .r32Sfloat: return ".r32Sfloat"
                case .r32g32Uint: return ".r32g32Uint"
                case .r32g32Sint: return ".r32g32Sint"
                case .r32g32Sfloat: return ".r32g32Sfloat"
                case .r32g32b32Uint: return ".r32g32b32Uint"
                case .r32g32b32Sint: return ".r32g32b32Sint"
                case .r32g32b32Sfloat: return ".r32g32b32Sfloat"
                case .r32g32b32a32Uint: return ".r32g32b32a32Uint"
                case .r32g32b32a32Sint: return ".r32g32b32a32Sint"
                case .r32g32b32a32Sfloat: return ".r32g32b32a32Sfloat"
                case .r64Uint: return ".r64Uint"
                case .r64Sint: return ".r64Sint"
                case .r64Sfloat: return ".r64Sfloat"
                case .r64g64Uint: return ".r64g64Uint"
                case .r64g64Sint: return ".r64g64Sint"
                case .r64g64Sfloat: return ".r64g64Sfloat"
                case .r64g64b64Uint: return ".r64g64b64Uint"
                case .r64g64b64Sint: return ".r64g64b64Sint"
                case .r64g64b64Sfloat: return ".r64g64b64Sfloat"
                case .r64g64b64a64Uint: return ".r64g64b64a64Uint"
                case .r64g64b64a64Sint: return ".r64g64b64a64Sint"
                case .r64g64b64a64Sfloat: return ".r64g64b64a64Sfloat"
                case .b10g11r11UfloatPack32: return ".b10g11r11UfloatPack32"
                case .e5b9g9r9UfloatPack32: return ".e5b9g9r9UfloatPack32"
                case .d16Unorm: return ".d16Unorm"
                case .x8D24UnormPack32: return ".x8D24UnormPack32"
                case .d32Sfloat: return ".d32Sfloat"
                case .s8Uint: return ".s8Uint"
                case .d16UnormS8Uint: return ".d16UnormS8Uint"
                case .d24UnormS8Uint: return ".d24UnormS8Uint"
                case .d32SfloatS8Uint: return ".d32SfloatS8Uint"
                case .bc1RgbUnormBlock: return ".bc1RgbUnormBlock"
                case .bc1RgbSrgbBlock: return ".bc1RgbSrgbBlock"
                case .bc1RgbaUnormBlock: return ".bc1RgbaUnormBlock"
                case .bc1RgbaSrgbBlock: return ".bc1RgbaSrgbBlock"
                case .bc2UnormBlock: return ".bc2UnormBlock"
                case .bc2SrgbBlock: return ".bc2SrgbBlock"
                case .bc3UnormBlock: return ".bc3UnormBlock"
                case .bc3SrgbBlock: return ".bc3SrgbBlock"
                case .bc4UnormBlock: return ".bc4UnormBlock"
                case .bc4SnormBlock: return ".bc4SnormBlock"
                case .bc5UnormBlock: return ".bc5UnormBlock"
                case .bc5SnormBlock: return ".bc5SnormBlock"
                case .bc6hUfloatBlock: return ".bc6hUfloatBlock"
                case .bc6hSfloatBlock: return ".bc6hSfloatBlock"
                case .bc7UnormBlock: return ".bc7UnormBlock"
                case .bc7SrgbBlock: return ".bc7SrgbBlock"
                case .etc2R8g8b8UnormBlock: return ".etc2R8g8b8UnormBlock"
                case .etc2R8g8b8SrgbBlock: return ".etc2R8g8b8SrgbBlock"
                case .etc2R8g8b8a1UnormBlock: return ".etc2R8g8b8a1UnormBlock"
                case .etc2R8g8b8a1SrgbBlock: return ".etc2R8g8b8a1SrgbBlock"
                case .etc2R8g8b8a8UnormBlock: return ".etc2R8g8b8a8UnormBlock"
                case .etc2R8g8b8a8SrgbBlock: return ".etc2R8g8b8a8SrgbBlock"
                case .eacR11UnormBlock: return ".eacR11UnormBlock"
                case .eacR11SnormBlock: return ".eacR11SnormBlock"
                case .eacR11g11UnormBlock: return ".eacR11g11UnormBlock"
                case .eacR11g11SnormBlock: return ".eacR11g11SnormBlock"
                case .astc4x4UnormBlock: return ".astc4x4UnormBlock"
                case .astc4x4SrgbBlock: return ".astc4x4SrgbBlock"
                case .astc5x4UnormBlock: return ".astc5x4UnormBlock"
                case .astc5x4SrgbBlock: return ".astc5x4SrgbBlock"
                case .astc5x5UnormBlock: return ".astc5x5UnormBlock"
                case .astc5x5SrgbBlock: return ".astc5x5SrgbBlock"
                case .astc6x5UnormBlock: return ".astc6x5UnormBlock"
                case .astc6x5SrgbBlock: return ".astc6x5SrgbBlock"
                case .astc6x6UnormBlock: return ".astc6x6UnormBlock"
                case .astc6x6SrgbBlock: return ".astc6x6SrgbBlock"
                case .astc8x5UnormBlock: return ".astc8x5UnormBlock"
                case .astc8x5SrgbBlock: return ".astc8x5SrgbBlock"
                case .astc8x6UnormBlock: return ".astc8x6UnormBlock"
                case .astc8x6SrgbBlock: return ".astc8x6SrgbBlock"
                case .astc8x8UnormBlock: return ".astc8x8UnormBlock"
                case .astc8x8SrgbBlock: return ".astc8x8SrgbBlock"
                case .astc10x5UnormBlock: return ".astc10x5UnormBlock"
                case .astc10x5SrgbBlock: return ".astc10x5SrgbBlock"
                case .astc10x6UnormBlock: return ".astc10x6UnormBlock"
                case .astc10x6SrgbBlock: return ".astc10x6SrgbBlock"
                case .astc10x8UnormBlock: return ".astc10x8UnormBlock"
                case .astc10x8SrgbBlock: return ".astc10x8SrgbBlock"
                case .astc10x10UnormBlock: return ".astc10x10UnormBlock"
                case .astc10x10SrgbBlock: return ".astc10x10SrgbBlock"
                case .astc12x10UnormBlock: return ".astc12x10UnormBlock"
                case .astc12x10SrgbBlock: return ".astc12x10SrgbBlock"
                case .astc12x12UnormBlock: return ".astc12x12UnormBlock"
                case .astc12x12SrgbBlock: return ".astc12x12SrgbBlock"
                case .g8b8g8r8422Unorm: return ".g8b8g8r8422Unorm"
                case .b8g8r8g8422Unorm: return ".b8g8r8g8422Unorm"
                case .g8B8R83plane420Unorm: return ".g8B8R83plane420Unorm"
                case .g8B8r82plane420Unorm: return ".g8B8r82plane420Unorm"
                case .g8B8R83plane422Unorm: return ".g8B8R83plane422Unorm"
                case .g8B8r82plane422Unorm: return ".g8B8r82plane422Unorm"
                case .g8B8R83plane444Unorm: return ".g8B8R83plane444Unorm"
                case .r10x6UnormPack16: return ".r10x6UnormPack16"
                case .r10x6g10x6Unorm2pack16: return ".r10x6g10x6Unorm2pack16"
                case .r10x6g10x6b10x6a10x6Unorm4pack16: return ".r10x6g10x6b10x6a10x6Unorm4pack16"
                case .g10x6b10x6g10x6r10x6422Unorm4pack16: return ".g10x6b10x6g10x6r10x6422Unorm4pack16"
                case .b10x6g10x6r10x6g10x6422Unorm4pack16: return ".b10x6g10x6r10x6g10x6422Unorm4pack16"
                case .g10x6B10x6R10x63plane420Unorm3pack16: return ".g10x6B10x6R10x63plane420Unorm3pack16"
                case .g10x6B10x6r10x62plane420Unorm3pack16: return ".g10x6B10x6r10x62plane420Unorm3pack16"
                case .g10x6B10x6R10x63plane422Unorm3pack16: return ".g10x6B10x6R10x63plane422Unorm3pack16"
                case .g10x6B10x6r10x62plane422Unorm3pack16: return ".g10x6B10x6r10x62plane422Unorm3pack16"
                case .g10x6B10x6R10x63plane444Unorm3pack16: return ".g10x6B10x6R10x63plane444Unorm3pack16"
                case .r12x4UnormPack16: return ".r12x4UnormPack16"
                case .r12x4g12x4Unorm2pack16: return ".r12x4g12x4Unorm2pack16"
                case .r12x4g12x4b12x4a12x4Unorm4pack16: return ".r12x4g12x4b12x4a12x4Unorm4pack16"
                case .g12x4b12x4g12x4r12x4422Unorm4pack16: return ".g12x4b12x4g12x4r12x4422Unorm4pack16"
                case .b12x4g12x4r12x4g12x4422Unorm4pack16: return ".b12x4g12x4r12x4g12x4422Unorm4pack16"
                case .g12x4B12x4R12x43plane420Unorm3pack16: return ".g12x4B12x4R12x43plane420Unorm3pack16"
                case .g12x4B12x4r12x42plane420Unorm3pack16: return ".g12x4B12x4r12x42plane420Unorm3pack16"
                case .g12x4B12x4R12x43plane422Unorm3pack16: return ".g12x4B12x4R12x43plane422Unorm3pack16"
                case .g12x4B12x4r12x42plane422Unorm3pack16: return ".g12x4B12x4r12x42plane422Unorm3pack16"
                case .g12x4B12x4R12x43plane444Unorm3pack16: return ".g12x4B12x4R12x43plane444Unorm3pack16"
                case .g16b16g16r16422Unorm: return ".g16b16g16r16422Unorm"
                case .b16g16r16g16422Unorm: return ".b16g16r16g16422Unorm"
                case .g16B16R163plane420Unorm: return ".g16B16R163plane420Unorm"
                case .g16B16r162plane420Unorm: return ".g16B16r162plane420Unorm"
                case .g16B16R163plane422Unorm: return ".g16B16R163plane422Unorm"
                case .g16B16r162plane422Unorm: return ".g16B16r162plane422Unorm"
                case .g16B16R163plane444Unorm: return ".g16B16R163plane444Unorm"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public struct BarrierMask: OptionSet, CustomDebugStringConvertible {
        public let rawValue: Int
        public init (rawValue: Int) {
            self.rawValue = rawValue
        }
        
        /// Vertex shader barrier mask.
        public static let vertex = BarrierMask (rawValue: 1)
        /// Fragment shader barrier mask.
        public static let fragment = BarrierMask (rawValue: 8)
        /// Compute barrier mask.
        public static let compute = BarrierMask (rawValue: 2)
        /// Transfer barrier mask.
        public static let transfer = BarrierMask (rawValue: 4)
        /// Raster barrier mask (vertex and fragment). Equivalent to `BARRIER_MASK_VERTEX | BARRIER_MASK_FRAGMENT`.
        public static let raster = BarrierMask (rawValue: 9)
        /// Barrier mask for all types (vertex, fragment, compute, transfer).
        public static let allBarriers = BarrierMask (rawValue: 32767)
        /// No barrier for any type.
        public static let noBarrier = BarrierMask (rawValue: 32768)
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            var result = ""
            if self.contains (.vertex) { result += "vertex, " }
            if self.contains (.fragment) { result += "fragment, " }
            if self.contains (.compute) { result += "compute, " }
            if self.contains (.transfer) { result += "transfer, " }
            if self.contains (.raster) { result += "raster, " }
            if self.contains (.allBarriers) { result += "allBarriers, " }
            if self.contains (.noBarrier) { result += "noBarrier, " }
            if result.hasSuffix (", ") { result.removeLast (2) }
            return result
        }
        
    }
    
    public enum TextureType: Int64, CaseIterable, CustomDebugStringConvertible {
        /// 1-dimensional texture.
        case textureType1d = 0 // TEXTURE_TYPE_1D
        /// 2-dimensional texture.
        case textureType2d = 1 // TEXTURE_TYPE_2D
        /// 3-dimensional texture.
        case textureType3d = 2 // TEXTURE_TYPE_3D
        /// ``Cubemap`` texture.
        case cube = 3 // TEXTURE_TYPE_CUBE
        /// Array of 1-dimensional textures.
        case textureType1dArray = 4 // TEXTURE_TYPE_1D_ARRAY
        /// Array of 2-dimensional textures.
        case textureType2dArray = 5 // TEXTURE_TYPE_2D_ARRAY
        /// Array of ``Cubemap`` textures.
        case cubeArray = 6 // TEXTURE_TYPE_CUBE_ARRAY
        /// Represents the size of the ``RenderingDevice/TextureType`` enum.
        case max = 7 // TEXTURE_TYPE_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .textureType1d: return ".textureType1d"
                case .textureType2d: return ".textureType2d"
                case .textureType3d: return ".textureType3d"
                case .cube: return ".cube"
                case .textureType1dArray: return ".textureType1dArray"
                case .textureType2dArray: return ".textureType2dArray"
                case .cubeArray: return ".cubeArray"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum TextureSamples: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Perform 1 texture sample (this is the fastest but lowest-quality for antialiasing).
        case textureSamples1 = 0 // TEXTURE_SAMPLES_1
        /// Perform 2 texture samples.
        case textureSamples2 = 1 // TEXTURE_SAMPLES_2
        /// Perform 4 texture samples.
        case textureSamples4 = 2 // TEXTURE_SAMPLES_4
        /// Perform 8 texture samples. Not supported on mobile GPUs (including Apple Silicon).
        case textureSamples8 = 3 // TEXTURE_SAMPLES_8
        /// Perform 16 texture samples. Not supported on mobile GPUs and many desktop GPUs.
        case textureSamples16 = 4 // TEXTURE_SAMPLES_16
        /// Perform 32 texture samples. Not supported on most GPUs.
        case textureSamples32 = 5 // TEXTURE_SAMPLES_32
        /// Perform 64 texture samples (this is the slowest but highest-quality for antialiasing). Not supported on most GPUs.
        case textureSamples64 = 6 // TEXTURE_SAMPLES_64
        /// Represents the size of the ``RenderingDevice/TextureSamples`` enum.
        case max = 7 // TEXTURE_SAMPLES_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .textureSamples1: return ".textureSamples1"
                case .textureSamples2: return ".textureSamples2"
                case .textureSamples4: return ".textureSamples4"
                case .textureSamples8: return ".textureSamples8"
                case .textureSamples16: return ".textureSamples16"
                case .textureSamples32: return ".textureSamples32"
                case .textureSamples64: return ".textureSamples64"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public struct TextureUsageBits: OptionSet, CustomDebugStringConvertible {
        public let rawValue: Int
        public init (rawValue: Int) {
            self.rawValue = rawValue
        }
        
        /// Texture can be sampled.
        public static let samplingBit = TextureUsageBits (rawValue: 1)
        /// Texture can be used as a color attachment in a framebuffer.
        public static let colorAttachmentBit = TextureUsageBits (rawValue: 2)
        /// Texture can be used as a depth/stencil attachment in a framebuffer.
        public static let depthStencilAttachmentBit = TextureUsageBits (rawValue: 4)
        /// Texture can be used as a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage">storage image</a>.
        public static let storageBit = TextureUsageBits (rawValue: 8)
        /// Texture can be used as a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-storageimage">storage image</a> with support for atomic operations.
        public static let storageAtomicBit = TextureUsageBits (rawValue: 16)
        /// Texture can be read back on the CPU using ``textureGetData(texture:layer:)`` faster than without this bit, since it is always kept in the system memory.
        public static let cpuReadBit = TextureUsageBits (rawValue: 32)
        /// Texture can be updated using ``textureUpdate(texture:layer:data:)``.
        public static let canUpdateBit = TextureUsageBits (rawValue: 64)
        /// Texture can be a source for ``textureCopy(fromTexture:toTexture:fromPos:toPos:size:srcMipmap:dstMipmap:srcLayer:dstLayer:)``.
        public static let canCopyFromBit = TextureUsageBits (rawValue: 128)
        /// Texture can be a destination for ``textureCopy(fromTexture:toTexture:fromPos:toPos:size:srcMipmap:dstMipmap:srcLayer:dstLayer:)``.
        public static let canCopyToBit = TextureUsageBits (rawValue: 256)
        /// Texture can be used as a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#descriptorsets-inputattachment">input attachment</a> in a framebuffer.
        public static let inputAttachmentBit = TextureUsageBits (rawValue: 512)
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            var result = ""
            if self.contains (.samplingBit) { result += "samplingBit, " }
            if self.contains (.colorAttachmentBit) { result += "colorAttachmentBit, " }
            if self.contains (.depthStencilAttachmentBit) { result += "depthStencilAttachmentBit, " }
            if self.contains (.storageBit) { result += "storageBit, " }
            if self.contains (.storageAtomicBit) { result += "storageAtomicBit, " }
            if self.contains (.cpuReadBit) { result += "cpuReadBit, " }
            if self.contains (.canUpdateBit) { result += "canUpdateBit, " }
            if self.contains (.canCopyFromBit) { result += "canCopyFromBit, " }
            if self.contains (.canCopyToBit) { result += "canCopyToBit, " }
            if self.contains (.inputAttachmentBit) { result += "inputAttachmentBit, " }
            if result.hasSuffix (", ") { result.removeLast (2) }
            return result
        }
        
    }
    
    public enum TextureSwizzle: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Return the sampled value as-is.
        case identity = 0 // TEXTURE_SWIZZLE_IDENTITY
        /// Always return `0.0` when sampling.
        case zero = 1 // TEXTURE_SWIZZLE_ZERO
        /// Always return `1.0` when sampling.
        case one = 2 // TEXTURE_SWIZZLE_ONE
        /// Sample the red color channel.
        case r = 3 // TEXTURE_SWIZZLE_R
        /// Sample the green color channel.
        case g = 4 // TEXTURE_SWIZZLE_G
        /// Sample the blue color channel.
        case b = 5 // TEXTURE_SWIZZLE_B
        /// Sample the alpha channel.
        case a = 6 // TEXTURE_SWIZZLE_A
        /// Represents the size of the ``RenderingDevice/TextureSwizzle`` enum.
        case max = 7 // TEXTURE_SWIZZLE_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .identity: return ".identity"
                case .zero: return ".zero"
                case .one: return ".one"
                case .r: return ".r"
                case .g: return ".g"
                case .b: return ".b"
                case .a: return ".a"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum TextureSliceType: Int64, CaseIterable, CustomDebugStringConvertible {
        /// 2-dimensional texture slice.
        case textureSlice2d = 0 // TEXTURE_SLICE_2D
        /// Cubemap texture slice.
        case cubemap = 1 // TEXTURE_SLICE_CUBEMAP
        /// 3-dimensional texture slice.
        case textureSlice3d = 2 // TEXTURE_SLICE_3D
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .textureSlice2d: return ".textureSlice2d"
                case .cubemap: return ".cubemap"
                case .textureSlice3d: return ".textureSlice3d"
            }
            
        }
        
    }
    
    public enum SamplerFilter: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Nearest-neighbor sampler filtering. Sampling at higher resolutions than the source will result in a pixelated look.
        case nearest = 0 // SAMPLER_FILTER_NEAREST
        /// Bilinear sampler filtering. Sampling at higher resolutions than the source will result in a blurry look.
        case linear = 1 // SAMPLER_FILTER_LINEAR
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .nearest: return ".nearest"
                case .linear: return ".linear"
            }
            
        }
        
    }
    
    public enum SamplerRepeatMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Sample with repeating enabled.
        case `repeat` = 0 // SAMPLER_REPEAT_MODE_REPEAT
        /// Sample with mirrored repeating enabled. When sampling outside the `[0.0, 1.0]` range, return a mirrored version of the sampler. This mirrored version is mirrored again if sampling further away, with the pattern repeating indefinitely.
        case mirroredRepeat = 1 // SAMPLER_REPEAT_MODE_MIRRORED_REPEAT
        /// Sample with repeating disabled. When sampling outside the `[0.0, 1.0]` range, return the color of the last pixel on the edge.
        case clampToEdge = 2 // SAMPLER_REPEAT_MODE_CLAMP_TO_EDGE
        /// Sample with repeating disabled. When sampling outside the `[0.0, 1.0]` range, return the specified ``RDSamplerState/borderColor``.
        case clampToBorder = 3 // SAMPLER_REPEAT_MODE_CLAMP_TO_BORDER
        /// Sample with mirrored repeating enabled, but only once. When sampling in the `[-1.0, 0.0]` range, return a mirrored version of the sampler. When sampling outside the `[-1.0, 1.0]` range, return the color of the last pixel on the edge.
        case mirrorClampToEdge = 4 // SAMPLER_REPEAT_MODE_MIRROR_CLAMP_TO_EDGE
        /// Represents the size of the ``RenderingDevice/SamplerRepeatMode`` enum.
        case max = 5 // SAMPLER_REPEAT_MODE_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .`repeat`: return ".`repeat`"
                case .mirroredRepeat: return ".mirroredRepeat"
                case .clampToEdge: return ".clampToEdge"
                case .clampToBorder: return ".clampToBorder"
                case .mirrorClampToEdge: return ".mirrorClampToEdge"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum SamplerBorderColor: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Return a floating-point transparent black color when sampling outside the `[0.0, 1.0]` range. Only effective if the sampler repeat mode is .clampToBorder.
        case floatTransparentBlack = 0 // SAMPLER_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK
        /// Return a integer transparent black color when sampling outside the `[0.0, 1.0]` range. Only effective if the sampler repeat mode is .clampToBorder.
        case intTransparentBlack = 1 // SAMPLER_BORDER_COLOR_INT_TRANSPARENT_BLACK
        /// Return a floating-point opaque black color when sampling outside the `[0.0, 1.0]` range. Only effective if the sampler repeat mode is .clampToBorder.
        case floatOpaqueBlack = 2 // SAMPLER_BORDER_COLOR_FLOAT_OPAQUE_BLACK
        /// Return a integer opaque black color when sampling outside the `[0.0, 1.0]` range. Only effective if the sampler repeat mode is .clampToBorder.
        case intOpaqueBlack = 3 // SAMPLER_BORDER_COLOR_INT_OPAQUE_BLACK
        /// Return a floating-point opaque white color when sampling outside the `[0.0, 1.0]` range. Only effective if the sampler repeat mode is .clampToBorder.
        case floatOpaqueWhite = 4 // SAMPLER_BORDER_COLOR_FLOAT_OPAQUE_WHITE
        /// Return a integer opaque white color when sampling outside the `[0.0, 1.0]` range. Only effective if the sampler repeat mode is .clampToBorder.
        case intOpaqueWhite = 5 // SAMPLER_BORDER_COLOR_INT_OPAQUE_WHITE
        /// Represents the size of the ``RenderingDevice/SamplerBorderColor`` enum.
        case max = 6 // SAMPLER_BORDER_COLOR_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .floatTransparentBlack: return ".floatTransparentBlack"
                case .intTransparentBlack: return ".intTransparentBlack"
                case .floatOpaqueBlack: return ".floatOpaqueBlack"
                case .intOpaqueBlack: return ".intOpaqueBlack"
                case .floatOpaqueWhite: return ".floatOpaqueWhite"
                case .intOpaqueWhite: return ".intOpaqueWhite"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum VertexFrequency: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Vertex attribute addressing is a function of the vertex. This is used to specify the rate at which vertex attributes are pulled from buffers.
        case vertex = 0 // VERTEX_FREQUENCY_VERTEX
        /// Vertex attribute addressing is a function of the instance index. This is used to specify the rate at which vertex attributes are pulled from buffers.
        case instance = 1 // VERTEX_FREQUENCY_INSTANCE
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .vertex: return ".vertex"
                case .instance: return ".instance"
            }
            
        }
        
    }
    
    public enum IndexBufferFormat: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Index buffer in 16-bit unsigned integer format. This limits the maximum index that can be specified to `65535`.
        case uint16 = 0 // INDEX_BUFFER_FORMAT_UINT16
        /// Index buffer in 32-bit unsigned integer format. This limits the maximum index that can be specified to `4294967295`.
        case uint32 = 1 // INDEX_BUFFER_FORMAT_UINT32
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .uint16: return ".uint16"
                case .uint32: return ".uint32"
            }
            
        }
        
    }
    
    public struct StorageBufferUsage: OptionSet, CustomDebugStringConvertible {
        public let rawValue: Int
        public init (rawValue: Int) {
            self.rawValue = rawValue
        }
        
        /// 
        public static let storageBufferUsageDispatchIndirect = StorageBufferUsage (rawValue: 1)
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            var result = ""
            if self.contains (.storageBufferUsageDispatchIndirect) { result += "storageBufferUsageDispatchIndirect, " }
            if result.hasSuffix (", ") { result.removeLast (2) }
            return result
        }
        
    }
    
    public enum UniformType: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Sampler uniform.
        case sampler = 0 // UNIFORM_TYPE_SAMPLER
        /// Sampler uniform with a texture.
        case samplerWithTexture = 1 // UNIFORM_TYPE_SAMPLER_WITH_TEXTURE
        /// Texture uniform.
        case texture = 2 // UNIFORM_TYPE_TEXTURE
        /// Image uniform.
        case image = 3 // UNIFORM_TYPE_IMAGE
        /// Texture buffer uniform.
        case textureBuffer = 4 // UNIFORM_TYPE_TEXTURE_BUFFER
        /// Sampler uniform with a texture buffer.
        case samplerWithTextureBuffer = 5 // UNIFORM_TYPE_SAMPLER_WITH_TEXTURE_BUFFER
        /// Image buffer uniform.
        case imageBuffer = 6 // UNIFORM_TYPE_IMAGE_BUFFER
        /// Uniform buffer uniform.
        case uniformBuffer = 7 // UNIFORM_TYPE_UNIFORM_BUFFER
        /// <a href="https://vkguide.dev/docs/chapter-4/storage_buffers/">Storage buffer</a> uniform.
        case storageBuffer = 8 // UNIFORM_TYPE_STORAGE_BUFFER
        /// Input attachment uniform.
        case inputAttachment = 9 // UNIFORM_TYPE_INPUT_ATTACHMENT
        /// Represents the size of the ``RenderingDevice/UniformType`` enum.
        case max = 10 // UNIFORM_TYPE_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .sampler: return ".sampler"
                case .samplerWithTexture: return ".samplerWithTexture"
                case .texture: return ".texture"
                case .image: return ".image"
                case .textureBuffer: return ".textureBuffer"
                case .samplerWithTextureBuffer: return ".samplerWithTextureBuffer"
                case .imageBuffer: return ".imageBuffer"
                case .uniformBuffer: return ".uniformBuffer"
                case .storageBuffer: return ".storageBuffer"
                case .inputAttachment: return ".inputAttachment"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum RenderPrimitive: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Point rendering primitive (with constant size, regardless of distance from camera).
        case points = 0 // RENDER_PRIMITIVE_POINTS
        /// Line list rendering primitive. Lines are drawn separated from each other.
        case lines = 1 // RENDER_PRIMITIVE_LINES
        /// <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-line-lists-with-adjacency">Line list rendering primitive with adjacency.</a>
        /// 
        /// > Note: Adjacency is only useful with geometry shaders, which Godot does not expose.
        /// 
        case linesWithAdjacency = 2 // RENDER_PRIMITIVE_LINES_WITH_ADJACENCY
        /// Line strip rendering primitive. Lines drawn are connected to the previous vertex.
        case linestrips = 3 // RENDER_PRIMITIVE_LINESTRIPS
        /// <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-line-strips-with-adjacency">Line strip rendering primitive with adjacency.</a>
        /// 
        /// > Note: Adjacency is only useful with geometry shaders, which Godot does not expose.
        /// 
        case linestripsWithAdjacency = 4 // RENDER_PRIMITIVE_LINESTRIPS_WITH_ADJACENCY
        /// Triangle list rendering primitive. Triangles are drawn separated from each other.
        case triangles = 5 // RENDER_PRIMITIVE_TRIANGLES
        /// <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-triangle-lists-with-adjacency">Triangle list rendering primitive with adjacency.</a>
        /// 
        /// > Note: Adjacency is only useful with geometry shaders, which Godot does not expose.
        /// 
        case trianglesWithAdjacency = 6 // RENDER_PRIMITIVE_TRIANGLES_WITH_ADJACENCY
        /// Triangle strip rendering primitive. Triangles drawn are connected to the previous triangle.
        case triangleStrips = 7 // RENDER_PRIMITIVE_TRIANGLE_STRIPS
        /// <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#drawing-triangle-strips-with-adjacency">Triangle strip rendering primitive with adjacency.</a>
        /// 
        /// > Note: Adjacency is only useful with geometry shaders, which Godot does not expose.
        /// 
        case triangleStripsWithAjacency = 8 // RENDER_PRIMITIVE_TRIANGLE_STRIPS_WITH_AJACENCY
        /// Triangle strip rendering primitive with _primitive restart_ enabled. Triangles drawn are connected to the previous triangle, but a primitive restart index can be specified before drawing to create a second triangle strip after the specified index.
        /// 
        /// > Note: Only compatible with indexed draws.
        /// 
        case triangleStripsWithRestartIndex = 9 // RENDER_PRIMITIVE_TRIANGLE_STRIPS_WITH_RESTART_INDEX
        /// Tessellation patch rendering primitive. Only useful with tessellation shaders, which can be used to deform these patches.
        case tesselationPatch = 10 // RENDER_PRIMITIVE_TESSELATION_PATCH
        /// Represents the size of the ``RenderingDevice/RenderPrimitive`` enum.
        case max = 11 // RENDER_PRIMITIVE_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .points: return ".points"
                case .lines: return ".lines"
                case .linesWithAdjacency: return ".linesWithAdjacency"
                case .linestrips: return ".linestrips"
                case .linestripsWithAdjacency: return ".linestripsWithAdjacency"
                case .triangles: return ".triangles"
                case .trianglesWithAdjacency: return ".trianglesWithAdjacency"
                case .triangleStrips: return ".triangleStrips"
                case .triangleStripsWithAjacency: return ".triangleStripsWithAjacency"
                case .triangleStripsWithRestartIndex: return ".triangleStripsWithRestartIndex"
                case .tesselationPatch: return ".tesselationPatch"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum PolygonCullMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Do not use polygon front face or backface culling.
        case disabled = 0 // POLYGON_CULL_DISABLED
        /// Use polygon frontface culling (faces pointing towards the camera are hidden).
        case front = 1 // POLYGON_CULL_FRONT
        /// Use polygon backface culling (faces pointing away from the camera are hidden).
        case back = 2 // POLYGON_CULL_BACK
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .disabled: return ".disabled"
                case .front: return ".front"
                case .back: return ".back"
            }
            
        }
        
    }
    
    public enum PolygonFrontFace: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Clockwise winding order to determine which face of a polygon is its front face.
        case clockwise = 0 // POLYGON_FRONT_FACE_CLOCKWISE
        /// Counter-clockwise winding order to determine which face of a polygon is its front face.
        case counterClockwise = 1 // POLYGON_FRONT_FACE_COUNTER_CLOCKWISE
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .clockwise: return ".clockwise"
                case .counterClockwise: return ".counterClockwise"
            }
            
        }
        
    }
    
    public enum StencilOperation: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Keep the current stencil value.
        case keep = 0 // STENCIL_OP_KEEP
        /// Set the stencil value to `0`.
        case zero = 1 // STENCIL_OP_ZERO
        /// Replace the existing stencil value with the new one.
        case replace = 2 // STENCIL_OP_REPLACE
        /// Increment the existing stencil value and clamp to the maximum representable unsigned value if reached. Stencil bits are considered as an unsigned integer.
        case incrementAndClamp = 3 // STENCIL_OP_INCREMENT_AND_CLAMP
        /// Decrement the existing stencil value and clamp to the minimum value if reached. Stencil bits are considered as an unsigned integer.
        case decrementAndClamp = 4 // STENCIL_OP_DECREMENT_AND_CLAMP
        /// Bitwise-invert the existing stencil value.
        case invert = 5 // STENCIL_OP_INVERT
        /// Increment the stencil value and wrap around to `0` if reaching the maximum representable unsigned. Stencil bits are considered as an unsigned integer.
        case incrementAndWrap = 6 // STENCIL_OP_INCREMENT_AND_WRAP
        /// Decrement the stencil value and wrap around to the maximum representable unsigned if reaching the minimum. Stencil bits are considered as an unsigned integer.
        case decrementAndWrap = 7 // STENCIL_OP_DECREMENT_AND_WRAP
        /// Represents the size of the ``RenderingDevice/StencilOperation`` enum.
        case max = 8 // STENCIL_OP_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .keep: return ".keep"
                case .zero: return ".zero"
                case .replace: return ".replace"
                case .incrementAndClamp: return ".incrementAndClamp"
                case .decrementAndClamp: return ".decrementAndClamp"
                case .invert: return ".invert"
                case .incrementAndWrap: return ".incrementAndWrap"
                case .decrementAndWrap: return ".decrementAndWrap"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum CompareOperator: Int64, CaseIterable, CustomDebugStringConvertible {
        /// "Never" comparison (opposite of .compareOpAlways).
        case never = 0 // COMPARE_OP_NEVER
        /// "Less than" comparison.
        case less = 1 // COMPARE_OP_LESS
        /// "Equal" comparison.
        case equal = 2 // COMPARE_OP_EQUAL
        /// "Less than or equal" comparison.
        case lessOrEqual = 3 // COMPARE_OP_LESS_OR_EQUAL
        /// "Greater than" comparison.
        case greater = 4 // COMPARE_OP_GREATER
        /// "Not equal" comparison.
        case notEqual = 5 // COMPARE_OP_NOT_EQUAL
        /// "Greater than or equal" comparison.
        case greaterOrEqual = 6 // COMPARE_OP_GREATER_OR_EQUAL
        /// "Always" comparison (opposite of .compareOpNever).
        case always = 7 // COMPARE_OP_ALWAYS
        /// Represents the size of the ``RenderingDevice/CompareOperator`` enum.
        case max = 8 // COMPARE_OP_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .never: return ".never"
                case .less: return ".less"
                case .equal: return ".equal"
                case .lessOrEqual: return ".lessOrEqual"
                case .greater: return ".greater"
                case .notEqual: return ".notEqual"
                case .greaterOrEqual: return ".greaterOrEqual"
                case .always: return ".always"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum LogicOperation: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Clear logic operation (result is always `0`). See also .logicOpSet.
        case clear = 0 // LOGIC_OP_CLEAR
        /// AND logic operation.
        case and = 1 // LOGIC_OP_AND
        /// AND logic operation with the _destination_ operand being inverted. See also .logicOpAndInverted.
        case andReverse = 2 // LOGIC_OP_AND_REVERSE
        /// Copy logic operation (keeps the _source_ value as-is). See also .logicOpCopyInverted and .logicOpNoOp.
        case copy = 3 // LOGIC_OP_COPY
        /// AND logic operation with the _source_ operand being inverted. See also .logicOpAndReverse.
        case andInverted = 4 // LOGIC_OP_AND_INVERTED
        /// No-op logic operation (keeps the _destination_ value as-is). See also .logicOpCopy.
        case noOp = 5 // LOGIC_OP_NO_OP
        /// Exclusive or (XOR) logic operation.
        case xor = 6 // LOGIC_OP_XOR
        /// OR logic operation.
        case or = 7 // LOGIC_OP_OR
        /// Not-OR (NOR) logic operation.
        case nor = 8 // LOGIC_OP_NOR
        /// Not-XOR (XNOR) logic operation.
        case equivalent = 9 // LOGIC_OP_EQUIVALENT
        /// Invert logic operation.
        case invert = 10 // LOGIC_OP_INVERT
        /// OR logic operation with the _destination_ operand being inverted. See also .logicOpOrReverse.
        case orReverse = 11 // LOGIC_OP_OR_REVERSE
        /// NOT logic operation (inverts the value). See also .logicOpCopy.
        case copyInverted = 12 // LOGIC_OP_COPY_INVERTED
        /// OR logic operation with the _source_ operand being inverted. See also .logicOpOrReverse.
        case orInverted = 13 // LOGIC_OP_OR_INVERTED
        /// Not-AND (NAND) logic operation.
        case nand = 14 // LOGIC_OP_NAND
        /// SET logic operation (result is always `1`). See also .logicOpClear.
        case set = 15 // LOGIC_OP_SET
        /// Represents the size of the ``RenderingDevice/LogicOperation`` enum.
        case max = 16 // LOGIC_OP_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .clear: return ".clear"
                case .and: return ".and"
                case .andReverse: return ".andReverse"
                case .copy: return ".copy"
                case .andInverted: return ".andInverted"
                case .noOp: return ".noOp"
                case .xor: return ".xor"
                case .or: return ".or"
                case .nor: return ".nor"
                case .equivalent: return ".equivalent"
                case .invert: return ".invert"
                case .orReverse: return ".orReverse"
                case .copyInverted: return ".copyInverted"
                case .orInverted: return ".orInverted"
                case .nand: return ".nand"
                case .set: return ".set"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum BlendFactor: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Constant `0.0` blend factor.
        case zero = 0 // BLEND_FACTOR_ZERO
        /// Constant `1.0` blend factor.
        case one = 1 // BLEND_FACTOR_ONE
        /// Color blend factor is `source color`. Alpha blend factor is `source alpha`.
        case srcColor = 2 // BLEND_FACTOR_SRC_COLOR
        /// Color blend factor is `1.0 - source color`. Alpha blend factor is `1.0 - source alpha`.
        case oneMinusSrcColor = 3 // BLEND_FACTOR_ONE_MINUS_SRC_COLOR
        /// Color blend factor is `destination color`. Alpha blend factor is `destination alpha`.
        case dstColor = 4 // BLEND_FACTOR_DST_COLOR
        /// Color blend factor is `1.0 - destination color`. Alpha blend factor is `1.0 - destination alpha`.
        case oneMinusDstColor = 5 // BLEND_FACTOR_ONE_MINUS_DST_COLOR
        /// Color and alpha blend factor is `source alpha`.
        case srcAlpha = 6 // BLEND_FACTOR_SRC_ALPHA
        /// Color and alpha blend factor is `1.0 - source alpha`.
        case oneMinusSrcAlpha = 7 // BLEND_FACTOR_ONE_MINUS_SRC_ALPHA
        /// Color and alpha blend factor is `destination alpha`.
        case dstAlpha = 8 // BLEND_FACTOR_DST_ALPHA
        /// Color and alpha blend factor is `1.0 - destination alpha`.
        case oneMinusDstAlpha = 9 // BLEND_FACTOR_ONE_MINUS_DST_ALPHA
        /// Color blend factor is `blend constant color`. Alpha blend factor is `blend constant alpha` (see ``drawListSetBlendConstants(drawList:color:)``).
        case constantColor = 10 // BLEND_FACTOR_CONSTANT_COLOR
        /// Color blend factor is `1.0 - blend constant color`. Alpha blend factor is `1.0 - blend constant alpha` (see ``drawListSetBlendConstants(drawList:color:)``).
        case oneMinusConstantColor = 11 // BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR
        /// Color and alpha blend factor is `blend constant alpha` (see ``drawListSetBlendConstants(drawList:color:)``).
        case constantAlpha = 12 // BLEND_FACTOR_CONSTANT_ALPHA
        /// Color and alpha blend factor is `1.0 - blend constant alpha` (see ``drawListSetBlendConstants(drawList:color:)``).
        case oneMinusConstantAlpha = 13 // BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA
        /// Color blend factor is `min(source alpha, 1.0 - destination alpha)`. Alpha blend factor is `1.0`.
        case srcAlphaSaturate = 14 // BLEND_FACTOR_SRC_ALPHA_SATURATE
        /// Color blend factor is `second source color`. Alpha blend factor is `second source alpha`. Only relevant for dual-source blending.
        case src1Color = 15 // BLEND_FACTOR_SRC1_COLOR
        /// Color blend factor is `1.0 - second source color`. Alpha blend factor is `1.0 - second source alpha`. Only relevant for dual-source blending.
        case oneMinusSrc1Color = 16 // BLEND_FACTOR_ONE_MINUS_SRC1_COLOR
        /// Color and alpha blend factor is `second source alpha`. Only relevant for dual-source blending.
        case src1Alpha = 17 // BLEND_FACTOR_SRC1_ALPHA
        /// Color and alpha blend factor is `1.0 - second source alpha`. Only relevant for dual-source blending.
        case oneMinusSrc1Alpha = 18 // BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA
        /// Represents the size of the ``RenderingDevice/BlendFactor`` enum.
        case max = 19 // BLEND_FACTOR_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .zero: return ".zero"
                case .one: return ".one"
                case .srcColor: return ".srcColor"
                case .oneMinusSrcColor: return ".oneMinusSrcColor"
                case .dstColor: return ".dstColor"
                case .oneMinusDstColor: return ".oneMinusDstColor"
                case .srcAlpha: return ".srcAlpha"
                case .oneMinusSrcAlpha: return ".oneMinusSrcAlpha"
                case .dstAlpha: return ".dstAlpha"
                case .oneMinusDstAlpha: return ".oneMinusDstAlpha"
                case .constantColor: return ".constantColor"
                case .oneMinusConstantColor: return ".oneMinusConstantColor"
                case .constantAlpha: return ".constantAlpha"
                case .oneMinusConstantAlpha: return ".oneMinusConstantAlpha"
                case .srcAlphaSaturate: return ".srcAlphaSaturate"
                case .src1Color: return ".src1Color"
                case .oneMinusSrc1Color: return ".oneMinusSrc1Color"
                case .src1Alpha: return ".src1Alpha"
                case .oneMinusSrc1Alpha: return ".oneMinusSrc1Alpha"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum BlendOperation: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Additive blending operation (`source + destination`).
        case add = 0 // BLEND_OP_ADD
        /// Subtractive blending operation (`source - destination`).
        case subtract = 1 // BLEND_OP_SUBTRACT
        /// Reverse subtractive blending operation (`destination - source`).
        case reverseSubtract = 2 // BLEND_OP_REVERSE_SUBTRACT
        /// Minimum blending operation (keep the lowest value of the two).
        case minimum = 3 // BLEND_OP_MINIMUM
        /// Maximum blending operation (keep the highest value of the two).
        case maximum = 4 // BLEND_OP_MAXIMUM
        /// Represents the size of the ``RenderingDevice/BlendOperation`` enum.
        case max = 5 // BLEND_OP_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .add: return ".add"
                case .subtract: return ".subtract"
                case .reverseSubtract: return ".reverseSubtract"
                case .minimum: return ".minimum"
                case .maximum: return ".maximum"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public struct PipelineDynamicStateFlags: OptionSet, CustomDebugStringConvertible {
        public let rawValue: Int
        public init (rawValue: Int) {
            self.rawValue = rawValue
        }
        
        /// Allows dynamically changing the width of rendering lines.
        public static let lineWidth = PipelineDynamicStateFlags (rawValue: 1)
        /// Allows dynamically changing the depth bias.
        public static let depthBias = PipelineDynamicStateFlags (rawValue: 2)
        /// 
        public static let blendConstants = PipelineDynamicStateFlags (rawValue: 4)
        /// 
        public static let depthBounds = PipelineDynamicStateFlags (rawValue: 8)
        /// 
        public static let stencilCompareMask = PipelineDynamicStateFlags (rawValue: 16)
        /// 
        public static let stencilWriteMask = PipelineDynamicStateFlags (rawValue: 32)
        /// 
        public static let stencilReference = PipelineDynamicStateFlags (rawValue: 64)
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            var result = ""
            if self.contains (.lineWidth) { result += "lineWidth, " }
            if self.contains (.depthBias) { result += "depthBias, " }
            if self.contains (.blendConstants) { result += "blendConstants, " }
            if self.contains (.depthBounds) { result += "depthBounds, " }
            if self.contains (.stencilCompareMask) { result += "stencilCompareMask, " }
            if self.contains (.stencilWriteMask) { result += "stencilWriteMask, " }
            if self.contains (.stencilReference) { result += "stencilReference, " }
            if result.hasSuffix (", ") { result.removeLast (2) }
            return result
        }
        
    }
    
    public enum InitialAction: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Load the previous contents of the framebuffer.
        case load = 0 // INITIAL_ACTION_LOAD
        /// Clear the whole framebuffer or its specified region.
        case clear = 1 // INITIAL_ACTION_CLEAR
        /// Ignore the previous contents of the framebuffer. This is the fastest option if you'll overwrite all of the pixels and don't need to read any of them.
        case discard = 2 // INITIAL_ACTION_DISCARD
        /// Represents the size of the ``RenderingDevice/InitialAction`` enum.
        case max = 3 // INITIAL_ACTION_MAX
        /// 
        // case clearRegion = 1 // INITIAL_ACTION_CLEAR_REGION
        /// 
        // case clearRegionContinue = 1 // INITIAL_ACTION_CLEAR_REGION_CONTINUE
        /// 
        // case keep = 0 // INITIAL_ACTION_KEEP
        /// 
        // case drop = 2 // INITIAL_ACTION_DROP
        /// 
        // case `continue` = 0 // INITIAL_ACTION_CONTINUE
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .load: return ".load"
                case .clear: return ".clear"
                case .discard: return ".discard"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum FinalAction: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Store the result of the draw list in the framebuffer. This is generally what you want to do.
        case store = 0 // FINAL_ACTION_STORE
        /// Discard the contents of the framebuffer. This is the fastest option if you don't need to use the results of the draw list.
        case discard = 1 // FINAL_ACTION_DISCARD
        /// Represents the size of the ``RenderingDevice/FinalAction`` enum.
        case max = 2 // FINAL_ACTION_MAX
        /// 
        // case read = 0 // FINAL_ACTION_READ
        /// 
        // case `continue` = 0 // FINAL_ACTION_CONTINUE
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .store: return ".store"
                case .discard: return ".discard"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum ShaderStage: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Vertex shader stage. This can be used to manipulate vertices from a shader (but not create new vertices).
        case vertex = 0 // SHADER_STAGE_VERTEX
        /// Fragment shader stage (called "pixel shader" in Direct3D). This can be used to manipulate pixels from a shader.
        case fragment = 1 // SHADER_STAGE_FRAGMENT
        /// Tessellation control shader stage. This can be used to create additional geometry from a shader.
        case tesselationControl = 2 // SHADER_STAGE_TESSELATION_CONTROL
        /// Tessellation evaluation shader stage. This can be used to create additional geometry from a shader.
        case tesselationEvaluation = 3 // SHADER_STAGE_TESSELATION_EVALUATION
        /// Compute shader stage. This can be used to run arbitrary computing tasks in a shader, performing them on the GPU instead of the CPU.
        case compute = 4 // SHADER_STAGE_COMPUTE
        /// Represents the size of the ``RenderingDevice/ShaderStage`` enum.
        case max = 5 // SHADER_STAGE_MAX
        /// Vertex shader stage bit (see also .vertex).
        // case vertexBit = 1 // SHADER_STAGE_VERTEX_BIT
        /// Fragment shader stage bit (see also .fragment).
        // case fragmentBit = 2 // SHADER_STAGE_FRAGMENT_BIT
        /// Tessellation control shader stage bit (see also .tesselationControl).
        // case tesselationControlBit = 4 // SHADER_STAGE_TESSELATION_CONTROL_BIT
        /// Tessellation evaluation shader stage bit (see also .tesselationEvaluation).
        case tesselationEvaluationBit = 8 // SHADER_STAGE_TESSELATION_EVALUATION_BIT
        /// Compute shader stage bit (see also .compute).
        case computeBit = 16 // SHADER_STAGE_COMPUTE_BIT
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .vertex: return ".vertex"
                case .fragment: return ".fragment"
                case .tesselationControl: return ".tesselationControl"
                case .tesselationEvaluation: return ".tesselationEvaluation"
                case .compute: return ".compute"
                case .max: return ".max"
                case .tesselationEvaluationBit: return ".tesselationEvaluationBit"
                case .computeBit: return ".computeBit"
            }
            
        }
        
    }
    
    public enum ShaderLanguage: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Khronos' GLSL shading language (used natively by OpenGL and Vulkan). This is the language used for core Godot shaders.
        case glsl = 0 // SHADER_LANGUAGE_GLSL
        /// Microsoft's High-Level Shading Language (used natively by Direct3D, but can also be used in Vulkan).
        case hlsl = 1 // SHADER_LANGUAGE_HLSL
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .glsl: return ".glsl"
                case .hlsl: return ".hlsl"
            }
            
        }
        
    }
    
    public enum PipelineSpecializationConstantType: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Boolean specialization constant.
        case bool = 0 // PIPELINE_SPECIALIZATION_CONSTANT_TYPE_BOOL
        /// Integer specialization constant.
        case int = 1 // PIPELINE_SPECIALIZATION_CONSTANT_TYPE_INT
        /// Floating-point specialization constant.
        case float = 2 // PIPELINE_SPECIALIZATION_CONSTANT_TYPE_FLOAT
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .bool: return ".bool"
                case .int: return ".int"
                case .float: return ".float"
            }
            
        }
        
    }
    
    public enum Limit: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Maximum number of uniform sets that can be bound at a given time.
        case maxBoundUniformSets = 0 // LIMIT_MAX_BOUND_UNIFORM_SETS
        /// Maximum number of color framebuffer attachments that can be used at a given time.
        case maxFramebufferColorAttachments = 1 // LIMIT_MAX_FRAMEBUFFER_COLOR_ATTACHMENTS
        /// Maximum number of textures that can be used per uniform set.
        case maxTexturesPerUniformSet = 2 // LIMIT_MAX_TEXTURES_PER_UNIFORM_SET
        /// Maximum number of samplers that can be used per uniform set.
        case maxSamplersPerUniformSet = 3 // LIMIT_MAX_SAMPLERS_PER_UNIFORM_SET
        /// Maximum number of <a href="https://vkguide.dev/docs/chapter-4/storage_buffers/">storage buffers</a> per uniform set.
        case maxStorageBuffersPerUniformSet = 4 // LIMIT_MAX_STORAGE_BUFFERS_PER_UNIFORM_SET
        /// Maximum number of storage images per uniform set.
        case maxStorageImagesPerUniformSet = 5 // LIMIT_MAX_STORAGE_IMAGES_PER_UNIFORM_SET
        /// Maximum number of uniform buffers per uniform set.
        case maxUniformBuffersPerUniformSet = 6 // LIMIT_MAX_UNIFORM_BUFFERS_PER_UNIFORM_SET
        /// Maximum index for an indexed draw command.
        case maxDrawIndexedIndex = 7 // LIMIT_MAX_DRAW_INDEXED_INDEX
        /// Maximum height of a framebuffer (in pixels).
        case maxFramebufferHeight = 8 // LIMIT_MAX_FRAMEBUFFER_HEIGHT
        /// Maximum width of a framebuffer (in pixels).
        case maxFramebufferWidth = 9 // LIMIT_MAX_FRAMEBUFFER_WIDTH
        /// Maximum number of texture array layers.
        case maxTextureArrayLayers = 10 // LIMIT_MAX_TEXTURE_ARRAY_LAYERS
        /// Maximum supported 1-dimensional texture size (in pixels on a single axis).
        case maxTextureSize1d = 11 // LIMIT_MAX_TEXTURE_SIZE_1D
        /// Maximum supported 2-dimensional texture size (in pixels on a single axis).
        case maxTextureSize2d = 12 // LIMIT_MAX_TEXTURE_SIZE_2D
        /// Maximum supported 3-dimensional texture size (in pixels on a single axis).
        case maxTextureSize3d = 13 // LIMIT_MAX_TEXTURE_SIZE_3D
        /// Maximum supported cubemap texture size (in pixels on a single axis of a single face).
        case maxTextureSizeCube = 14 // LIMIT_MAX_TEXTURE_SIZE_CUBE
        /// Maximum number of textures per shader stage.
        case maxTexturesPerShaderStage = 15 // LIMIT_MAX_TEXTURES_PER_SHADER_STAGE
        /// Maximum number of samplers per shader stage.
        case maxSamplersPerShaderStage = 16 // LIMIT_MAX_SAMPLERS_PER_SHADER_STAGE
        /// Maximum number of <a href="https://vkguide.dev/docs/chapter-4/storage_buffers/">storage buffers</a> per shader stage.
        case maxStorageBuffersPerShaderStage = 17 // LIMIT_MAX_STORAGE_BUFFERS_PER_SHADER_STAGE
        /// Maximum number of storage images per shader stage.
        case maxStorageImagesPerShaderStage = 18 // LIMIT_MAX_STORAGE_IMAGES_PER_SHADER_STAGE
        /// Maximum number of uniform buffers per uniform set.
        case maxUniformBuffersPerShaderStage = 19 // LIMIT_MAX_UNIFORM_BUFFERS_PER_SHADER_STAGE
        /// Maximum size of a push constant. A lot of devices are limited to 128 bytes, so try to avoid exceeding 128 bytes in push constants to ensure compatibility even if your GPU is reporting a higher value.
        case maxPushConstantSize = 20 // LIMIT_MAX_PUSH_CONSTANT_SIZE
        /// Maximum size of a uniform buffer.
        case maxUniformBufferSize = 21 // LIMIT_MAX_UNIFORM_BUFFER_SIZE
        /// Maximum vertex input attribute offset.
        case maxVertexInputAttributeOffset = 22 // LIMIT_MAX_VERTEX_INPUT_ATTRIBUTE_OFFSET
        /// Maximum number of vertex input attributes.
        case maxVertexInputAttributes = 23 // LIMIT_MAX_VERTEX_INPUT_ATTRIBUTES
        /// Maximum number of vertex input bindings.
        case maxVertexInputBindings = 24 // LIMIT_MAX_VERTEX_INPUT_BINDINGS
        /// Maximum vertex input binding stride.
        case maxVertexInputBindingStride = 25 // LIMIT_MAX_VERTEX_INPUT_BINDING_STRIDE
        /// Minimum uniform buffer offset alignment.
        case minUniformBufferOffsetAlignment = 26 // LIMIT_MIN_UNIFORM_BUFFER_OFFSET_ALIGNMENT
        /// Maximum shared memory size for compute shaders.
        case maxComputeSharedMemorySize = 27 // LIMIT_MAX_COMPUTE_SHARED_MEMORY_SIZE
        /// Maximum number of workgroups for compute shaders on the X axis.
        case maxComputeWorkgroupCountX = 28 // LIMIT_MAX_COMPUTE_WORKGROUP_COUNT_X
        /// Maximum number of workgroups for compute shaders on the Y axis.
        case maxComputeWorkgroupCountY = 29 // LIMIT_MAX_COMPUTE_WORKGROUP_COUNT_Y
        /// Maximum number of workgroups for compute shaders on the Z axis.
        case maxComputeWorkgroupCountZ = 30 // LIMIT_MAX_COMPUTE_WORKGROUP_COUNT_Z
        /// Maximum number of workgroup invocations for compute shaders.
        case maxComputeWorkgroupInvocations = 31 // LIMIT_MAX_COMPUTE_WORKGROUP_INVOCATIONS
        /// Maximum workgroup size for compute shaders on the X axis.
        case maxComputeWorkgroupSizeX = 32 // LIMIT_MAX_COMPUTE_WORKGROUP_SIZE_X
        /// Maximum workgroup size for compute shaders on the Y axis.
        case maxComputeWorkgroupSizeY = 33 // LIMIT_MAX_COMPUTE_WORKGROUP_SIZE_Y
        /// Maximum workgroup size for compute shaders on the Z axis.
        case maxComputeWorkgroupSizeZ = 34 // LIMIT_MAX_COMPUTE_WORKGROUP_SIZE_Z
        /// Maximum viewport width (in pixels).
        case maxViewportDimensionsX = 35 // LIMIT_MAX_VIEWPORT_DIMENSIONS_X
        /// Maximum viewport height (in pixels).
        case maxViewportDimensionsY = 36 // LIMIT_MAX_VIEWPORT_DIMENSIONS_Y
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .maxBoundUniformSets: return ".maxBoundUniformSets"
                case .maxFramebufferColorAttachments: return ".maxFramebufferColorAttachments"
                case .maxTexturesPerUniformSet: return ".maxTexturesPerUniformSet"
                case .maxSamplersPerUniformSet: return ".maxSamplersPerUniformSet"
                case .maxStorageBuffersPerUniformSet: return ".maxStorageBuffersPerUniformSet"
                case .maxStorageImagesPerUniformSet: return ".maxStorageImagesPerUniformSet"
                case .maxUniformBuffersPerUniformSet: return ".maxUniformBuffersPerUniformSet"
                case .maxDrawIndexedIndex: return ".maxDrawIndexedIndex"
                case .maxFramebufferHeight: return ".maxFramebufferHeight"
                case .maxFramebufferWidth: return ".maxFramebufferWidth"
                case .maxTextureArrayLayers: return ".maxTextureArrayLayers"
                case .maxTextureSize1d: return ".maxTextureSize1d"
                case .maxTextureSize2d: return ".maxTextureSize2d"
                case .maxTextureSize3d: return ".maxTextureSize3d"
                case .maxTextureSizeCube: return ".maxTextureSizeCube"
                case .maxTexturesPerShaderStage: return ".maxTexturesPerShaderStage"
                case .maxSamplersPerShaderStage: return ".maxSamplersPerShaderStage"
                case .maxStorageBuffersPerShaderStage: return ".maxStorageBuffersPerShaderStage"
                case .maxStorageImagesPerShaderStage: return ".maxStorageImagesPerShaderStage"
                case .maxUniformBuffersPerShaderStage: return ".maxUniformBuffersPerShaderStage"
                case .maxPushConstantSize: return ".maxPushConstantSize"
                case .maxUniformBufferSize: return ".maxUniformBufferSize"
                case .maxVertexInputAttributeOffset: return ".maxVertexInputAttributeOffset"
                case .maxVertexInputAttributes: return ".maxVertexInputAttributes"
                case .maxVertexInputBindings: return ".maxVertexInputBindings"
                case .maxVertexInputBindingStride: return ".maxVertexInputBindingStride"
                case .minUniformBufferOffsetAlignment: return ".minUniformBufferOffsetAlignment"
                case .maxComputeSharedMemorySize: return ".maxComputeSharedMemorySize"
                case .maxComputeWorkgroupCountX: return ".maxComputeWorkgroupCountX"
                case .maxComputeWorkgroupCountY: return ".maxComputeWorkgroupCountY"
                case .maxComputeWorkgroupCountZ: return ".maxComputeWorkgroupCountZ"
                case .maxComputeWorkgroupInvocations: return ".maxComputeWorkgroupInvocations"
                case .maxComputeWorkgroupSizeX: return ".maxComputeWorkgroupSizeX"
                case .maxComputeWorkgroupSizeY: return ".maxComputeWorkgroupSizeY"
                case .maxComputeWorkgroupSizeZ: return ".maxComputeWorkgroupSizeZ"
                case .maxViewportDimensionsX: return ".maxViewportDimensionsX"
                case .maxViewportDimensionsY: return ".maxViewportDimensionsY"
            }
            
        }
        
    }
    
    public enum MemoryType: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Memory taken by textures.
        case textures = 0 // MEMORY_TEXTURES
        /// Memory taken by buffers.
        case buffers = 1 // MEMORY_BUFFERS
        /// Total memory taken. This is greater than the sum of .memoryTextures and .memoryBuffers, as it also includes miscellaneous memory usage.
        case total = 2 // MEMORY_TOTAL
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .textures: return ".textures"
                case .buffers: return ".buffers"
                case .total: return ".total"
            }
            
        }
        
    }
    
    /* Constants */
    /// Returned by functions that return an ID if a value is invalid.
    public static let invalidId = -1
    /// Returned by functions that return a format ID if a value is invalid.
    public static let invalidFormatId = -1
    /* Methods */
    fileprivate static var method_texture_create: GDExtensionMethodBindPtr = {
        let methodName = StringName("texture_create")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3709173589)!
            }
            
        }
        
    }()
    
    /// Creates a new texture. It can be accessed with the RID that is returned.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingDevice's ``freeRid(_:)`` method.
    /// 
    /// > Note: Not to be confused with ``RenderingServer/texture2dCreate(image:)``, which creates the Godot-specific ``Texture2D`` resource as opposed to the graphics API's own texture type.
    /// 
    public final func textureCreate(format: RDTextureFormat?, view: RDTextureView?, data: VariantCollection<PackedByteArray> = VariantCollection<PackedByteArray> ()) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: format?.handle) { pArg0 in
            withUnsafePointer(to: view?.handle) { pArg1 in
                withUnsafePointer(to: data.array.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(RenderingDevice.method_texture_create, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_texture_create_shared: GDExtensionMethodBindPtr = {
        let methodName = StringName("texture_create_shared")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3178156134)!
            }
            
        }
        
    }()
    
    /// Creates a shared texture using the specified `view` and the texture information from `withTexture`.
    public final func textureCreateShared(view: RDTextureView?, withTexture: RID) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: view?.handle) { pArg0 in
            withUnsafePointer(to: withTexture.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RenderingDevice.method_texture_create_shared, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_texture_create_shared_from_slice: GDExtensionMethodBindPtr = {
        let methodName = StringName("texture_create_shared_from_slice")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1808971279)!
            }
            
        }
        
    }()
    
    /// Creates a shared texture using the specified `view` and the texture information from `withTexture`'s `layer` and `mipmap`. The number of included mipmaps from the original texture can be controlled using the `mipmaps` parameter. Only relevant for textures with multiple layers, such as 3D textures, texture arrays and cubemaps. For single-layer textures, use ``textureCreateShared(view:withTexture:)``
    /// 
    /// For 2D textures (which only have one layer), `layer` must be `0`.
    /// 
    /// > Note: Layer slicing is only supported for 2D texture arrays, not 3D textures or cubemaps.
    /// 
    public final func textureCreateSharedFromSlice(view: RDTextureView?, withTexture: RID, layer: UInt32, mipmap: UInt32, mipmaps: UInt32 = 1, sliceType: RenderingDevice.TextureSliceType = .textureSlice2d) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: view?.handle) { pArg0 in
            withUnsafePointer(to: withTexture.content) { pArg1 in
                withUnsafePointer(to: layer) { pArg2 in
                    withUnsafePointer(to: mipmap) { pArg3 in
                        withUnsafePointer(to: mipmaps) { pArg4 in
                            withUnsafePointer(to: sliceType.rawValue) { pArg5 in
                                withUnsafePointer(to: UnsafeRawPointersN6(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5)) { pArgs in
                                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 6) { pArgs in
                                        gi.object_method_bind_ptrcall(RenderingDevice.method_texture_create_shared_from_slice, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_texture_create_from_extension: GDExtensionMethodBindPtr = {
        let methodName = StringName("texture_create_from_extension")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1397171480)!
            }
            
        }
        
    }()
    
    /// Returns an RID for an existing `image` (`VkImage`) with the given `type`, `format`, `samples`, `usageFlags`, `width`, `height`, `depth`, and `layers`. This can be used to allow Godot to render onto foreign images.
    public final func textureCreateFromExtension(type: RenderingDevice.TextureType, format: RenderingDevice.DataFormat, samples: RenderingDevice.TextureSamples, usageFlags: RenderingDevice.TextureUsageBits, image: UInt, width: UInt, height: UInt, depth: UInt, layers: UInt) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: type.rawValue) { pArg0 in
            withUnsafePointer(to: format.rawValue) { pArg1 in
                withUnsafePointer(to: samples.rawValue) { pArg2 in
                    withUnsafePointer(to: usageFlags.rawValue) { pArg3 in
                        withUnsafePointer(to: image) { pArg4 in
                            withUnsafePointer(to: width) { pArg5 in
                                withUnsafePointer(to: height) { pArg6 in
                                    withUnsafePointer(to: depth) { pArg7 in
                                        withUnsafePointer(to: layers) { pArg8 in
                                            withUnsafePointer(to: UnsafeRawPointersN9(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6, pArg7, pArg8)) { pArgs in
                                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 9) { pArgs in
                                                    gi.object_method_bind_ptrcall(RenderingDevice.method_texture_create_from_extension, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                                                }
                                                
                                            }
                                            
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_texture_update: GDExtensionMethodBindPtr = {
        let methodName = StringName("texture_update")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1349464008)!
            }
            
        }
        
    }()
    
    /// Updates texture data with new data, replacing the previous data in place. The updated texture data must have the same dimensions and format. For 2D textures (which only have one layer), `layer` must be `0`. Returns ``@GlobalScope.OK`` if the update was successful, ``@GlobalScope.ERR_INVALID_PARAMETER`` otherwise.
    /// 
    /// > Note: Updating textures is forbidden during creation of a draw or compute list.
    /// 
    /// > Note: The existing `texture` can't be updated while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to .`continue`) to update this texture.
    /// 
    /// > Note: The existing `texture` requires the .textureUsageCanUpdateBit to be updatable.
    /// 
    public final func textureUpdate(texture: RID, layer: UInt32, data: PackedByteArray) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: texture.content) { pArg0 in
            withUnsafePointer(to: layer) { pArg1 in
                withUnsafePointer(to: data.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(RenderingDevice.method_texture_update, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_texture_get_data: GDExtensionMethodBindPtr = {
        let methodName = StringName("texture_get_data")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1859412099)!
            }
            
        }
        
    }()
    
    /// Returns the `texture` data for the specified `layer` as raw binary data. For 2D textures (which only have one layer), `layer` must be `0`.
    /// 
    /// > Note: `texture` can't be retrieved while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to .`continue`) to retrieve this texture. Otherwise, an error is printed and a empty ``PackedByteArray`` is returned.
    /// 
    /// > Note: `texture` requires the .textureUsageCanCopyFromBit to be retrieved. Otherwise, an error is printed and a empty ``PackedByteArray`` is returned.
    /// 
    public final func textureGetData(texture: RID, layer: UInt32) -> PackedByteArray {
        let _result: PackedByteArray = PackedByteArray ()
        withUnsafePointer(to: texture.content) { pArg0 in
            withUnsafePointer(to: layer) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RenderingDevice.method_texture_get_data, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_texture_is_format_supported_for_usage: GDExtensionMethodBindPtr = {
        let methodName = StringName("texture_is_format_supported_for_usage")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2592520478)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the specified `format` is supported for the given `usageFlags`, `false` otherwise.
    public final func textureIsFormatSupportedForUsage(format: RenderingDevice.DataFormat, usageFlags: RenderingDevice.TextureUsageBits) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: format.rawValue) { pArg0 in
            withUnsafePointer(to: usageFlags.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RenderingDevice.method_texture_is_format_supported_for_usage, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_texture_is_shared: GDExtensionMethodBindPtr = {
        let methodName = StringName("texture_is_shared")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3521089500)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the `texture` is shared, `false` otherwise. See ``RDTextureView``.
    public final func textureIsShared(texture: RID) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: texture.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_texture_is_shared, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_texture_is_valid: GDExtensionMethodBindPtr = {
        let methodName = StringName("texture_is_valid")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3521089500)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the `texture` is valid, `false` otherwise.
    public final func textureIsValid(texture: RID) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: texture.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_texture_is_valid, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_texture_copy: GDExtensionMethodBindPtr = {
        let methodName = StringName("texture_copy")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2859522160)!
            }
            
        }
        
    }()
    
    /// Copies the `fromTexture` to `toTexture` with the specified `fromPos`, `toPos` and `size` coordinates. The Z axis of the `fromPos`, `toPos` and `size` must be `0` for 2-dimensional textures. Source and destination mipmaps/layers must also be specified, with these parameters being `0` for textures without mipmaps or single-layer textures. Returns ``@GlobalScope.OK`` if the texture copy was successful or ``@GlobalScope.ERR_INVALID_PARAMETER`` otherwise.
    /// 
    /// > Note: `fromTexture` texture can't be copied while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to .`continue`) to copy this texture.
    /// 
    /// > Note: `fromTexture` texture requires the .textureUsageCanCopyFromBit to be retrieved.
    /// 
    /// > Note: `toTexture` can't be copied while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to .`continue`) to copy this texture.
    /// 
    /// > Note: `toTexture` requires the .textureUsageCanCopyToBit to be retrieved.
    /// 
    /// > Note: `fromTexture` and `toTexture` must be of the same type (color or depth).
    /// 
    public final func textureCopy(fromTexture: RID, toTexture: RID, fromPos: Vector3, toPos: Vector3, size: Vector3, srcMipmap: UInt32, dstMipmap: UInt32, srcLayer: UInt32, dstLayer: UInt32) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: fromTexture.content) { pArg0 in
            withUnsafePointer(to: toTexture.content) { pArg1 in
                withUnsafePointer(to: fromPos) { pArg2 in
                    withUnsafePointer(to: toPos) { pArg3 in
                        withUnsafePointer(to: size) { pArg4 in
                            withUnsafePointer(to: srcMipmap) { pArg5 in
                                withUnsafePointer(to: dstMipmap) { pArg6 in
                                    withUnsafePointer(to: srcLayer) { pArg7 in
                                        withUnsafePointer(to: dstLayer) { pArg8 in
                                            withUnsafePointer(to: UnsafeRawPointersN9(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6, pArg7, pArg8)) { pArgs in
                                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 9) { pArgs in
                                                    gi.object_method_bind_ptrcall(RenderingDevice.method_texture_copy, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                                                }
                                                
                                            }
                                            
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_texture_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName("texture_clear")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3477703247)!
            }
            
        }
        
    }()
    
    /// Clears the specified `texture` by replacing all of its pixels with the specified `color`. `baseMipmap` and `mipmapCount` determine which mipmaps of the texture are affected by this clear operation, while `baseLayer` and `layerCount` determine which layers of a 3D texture (or texture array) are affected by this clear operation. For 2D textures (which only have one layer by design), `baseLayer` must be `0` and `layerCount` must be `1`.
    /// 
    /// > Note: `texture` can't be cleared while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to .`continue`) to clear this texture.
    /// 
    public final func textureClear(texture: RID, color: Color, baseMipmap: UInt32, mipmapCount: UInt32, baseLayer: UInt32, layerCount: UInt32) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: texture.content) { pArg0 in
            withUnsafePointer(to: color) { pArg1 in
                withUnsafePointer(to: baseMipmap) { pArg2 in
                    withUnsafePointer(to: mipmapCount) { pArg3 in
                        withUnsafePointer(to: baseLayer) { pArg4 in
                            withUnsafePointer(to: layerCount) { pArg5 in
                                withUnsafePointer(to: UnsafeRawPointersN6(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5)) { pArgs in
                                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 6) { pArgs in
                                        gi.object_method_bind_ptrcall(RenderingDevice.method_texture_clear, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_texture_resolve_multisample: GDExtensionMethodBindPtr = {
        let methodName = StringName("texture_resolve_multisample")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3181288260)!
            }
            
        }
        
    }()
    
    /// Resolves the `fromTexture` texture onto `toTexture` with multisample antialiasing enabled. This must be used when rendering a framebuffer for MSAA to work. Returns ``@GlobalScope.OK`` if successful, ``@GlobalScope.ERR_INVALID_PARAMETER`` otherwise.
    /// 
    /// > Note: `fromTexture` and `toTexture` textures must have the same dimension, format and type (color or depth).
    /// 
    /// > Note: `fromTexture` can't be copied while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to .`continue`) to resolve this texture.
    /// 
    /// > Note: `fromTexture` requires the .textureUsageCanCopyFromBit to be retrieved.
    /// 
    /// > Note: `fromTexture` must be multisampled and must also be 2D (or a slice of a 3D/cubemap texture).
    /// 
    /// > Note: `toTexture` can't be copied while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to .`continue`) to resolve this texture.
    /// 
    /// > Note: `toTexture` texture requires the .textureUsageCanCopyToBit to be retrieved.
    /// 
    /// > Note: `toTexture` texture must **not** be multisampled and must also be 2D (or a slice of a 3D/cubemap texture).
    /// 
    public final func textureResolveMultisample(fromTexture: RID, toTexture: RID) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: fromTexture.content) { pArg0 in
            withUnsafePointer(to: toTexture.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RenderingDevice.method_texture_resolve_multisample, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_texture_get_format: GDExtensionMethodBindPtr = {
        let methodName = StringName("texture_get_format")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1374471690)!
            }
            
        }
        
    }()
    
    /// Returns the data format used to create this texture.
    public final func textureGetFormat(texture: RID) -> RDTextureFormat? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: texture.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_texture_get_format, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_texture_get_native_handle: GDExtensionMethodBindPtr = {
        let methodName = StringName("texture_get_native_handle")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3917799429)!
            }
            
        }
        
    }()
    
    /// Returns the internal graphics handle for this texture object. For use when communicating with third-party APIs mostly with GDExtension.
    /// 
    /// > Note: This function returns a `uint64_t` which internally maps to a `GLuint` (OpenGL) or `VkImage` (Vulkan).
    /// 
    public final func textureGetNativeHandle(texture: RID) -> UInt {
        var _result: UInt = 0
        withUnsafePointer(to: texture.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_texture_get_native_handle, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_framebuffer_format_create: GDExtensionMethodBindPtr = {
        let methodName = StringName("framebuffer_format_create")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 697032759)!
            }
            
        }
        
    }()
    
    /// Creates a new framebuffer format with the specified `attachments` and `viewCount`. Returns the new framebuffer's unique framebuffer format ID.
    /// 
    /// If `viewCount` is greater than or equal to `2`, enables multiview which is used for VR rendering. This requires support for the Vulkan multiview extension.
    /// 
    public final func framebufferFormatCreate(attachments: ObjectCollection<RDAttachmentFormat>, viewCount: UInt32 = 1) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: attachments.array.content) { pArg0 in
            withUnsafePointer(to: viewCount) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RenderingDevice.method_framebuffer_format_create, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_framebuffer_format_create_multipass: GDExtensionMethodBindPtr = {
        let methodName = StringName("framebuffer_format_create_multipass")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2647479094)!
            }
            
        }
        
    }()
    
    /// Creates a multipass framebuffer format with the specified `attachments`, `passes` and `viewCount` and returns its ID. If `viewCount` is greater than or equal to `2`, enables multiview which is used for VR rendering. This requires support for the Vulkan multiview extension.
    public final func framebufferFormatCreateMultipass(attachments: ObjectCollection<RDAttachmentFormat>, passes: ObjectCollection<RDFramebufferPass>, viewCount: UInt32 = 1) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: attachments.array.content) { pArg0 in
            withUnsafePointer(to: passes.array.content) { pArg1 in
                withUnsafePointer(to: viewCount) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(RenderingDevice.method_framebuffer_format_create_multipass, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_framebuffer_format_create_empty: GDExtensionMethodBindPtr = {
        let methodName = StringName("framebuffer_format_create_empty")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 555930169)!
            }
            
        }
        
    }()
    
    /// Creates a new empty framebuffer format with the specified number of `samples` and returns its ID.
    public final func framebufferFormatCreateEmpty(samples: RenderingDevice.TextureSamples = .textureSamples1) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: samples.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_framebuffer_format_create_empty, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_framebuffer_format_get_texture_samples: GDExtensionMethodBindPtr = {
        let methodName = StringName("framebuffer_format_get_texture_samples")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4223391010)!
            }
            
        }
        
    }()
    
    /// Returns the number of texture samples used for the given framebuffer `format` ID (returned by ``framebufferGetFormat(framebuffer:)``).
    public final func framebufferFormatGetTextureSamples(format: Int, renderPass: UInt32 = 0) -> RenderingDevice.TextureSamples {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: format) { pArg0 in
            withUnsafePointer(to: renderPass) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RenderingDevice.method_framebuffer_format_get_texture_samples, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return RenderingDevice.TextureSamples (rawValue: _result)!
    }
    
    fileprivate static var method_framebuffer_create: GDExtensionMethodBindPtr = {
        let methodName = StringName("framebuffer_create")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3284231055)!
            }
            
        }
        
    }()
    
    /// Creates a new framebuffer. It can be accessed with the RID that is returned.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingDevice's ``freeRid(_:)`` method.
    /// 
    public final func framebufferCreate(textures: VariantCollection<RID>, validateWithFormat: Int = -1, viewCount: UInt32 = 1) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: textures.array.content) { pArg0 in
            withUnsafePointer(to: validateWithFormat) { pArg1 in
                withUnsafePointer(to: viewCount) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(RenderingDevice.method_framebuffer_create, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_framebuffer_create_multipass: GDExtensionMethodBindPtr = {
        let methodName = StringName("framebuffer_create_multipass")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1750306695)!
            }
            
        }
        
    }()
    
    /// Creates a new multipass framebuffer. It can be accessed with the RID that is returned.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingDevice's ``freeRid(_:)`` method.
    /// 
    public final func framebufferCreateMultipass(textures: VariantCollection<RID>, passes: ObjectCollection<RDFramebufferPass>, validateWithFormat: Int = -1, viewCount: UInt32 = 1) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: textures.array.content) { pArg0 in
            withUnsafePointer(to: passes.array.content) { pArg1 in
                withUnsafePointer(to: validateWithFormat) { pArg2 in
                    withUnsafePointer(to: viewCount) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(RenderingDevice.method_framebuffer_create_multipass, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_framebuffer_create_empty: GDExtensionMethodBindPtr = {
        let methodName = StringName("framebuffer_create_empty")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3058360618)!
            }
            
        }
        
    }()
    
    /// Creates a new empty framebuffer. It can be accessed with the RID that is returned.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingDevice's ``freeRid(_:)`` method.
    /// 
    public final func framebufferCreateEmpty(size: Vector2i, samples: RenderingDevice.TextureSamples = .textureSamples1, validateWithFormat: Int = -1) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: size) { pArg0 in
            withUnsafePointer(to: samples.rawValue) { pArg1 in
                withUnsafePointer(to: validateWithFormat) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(RenderingDevice.method_framebuffer_create_empty, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_framebuffer_get_format: GDExtensionMethodBindPtr = {
        let methodName = StringName("framebuffer_get_format")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3917799429)!
            }
            
        }
        
    }()
    
    /// Returns the format ID of the framebuffer specified by the `framebuffer` RID. This ID is guaranteed to be unique for the same formats and does not need to be freed.
    public final func framebufferGetFormat(framebuffer: RID) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: framebuffer.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_framebuffer_get_format, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_framebuffer_is_valid: GDExtensionMethodBindPtr = {
        let methodName = StringName("framebuffer_is_valid")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4155700596)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the framebuffer specified by the `framebuffer` RID is valid, `false` otherwise.
    public final func framebufferIsValid(framebuffer: RID) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: framebuffer.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_framebuffer_is_valid, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_sampler_create: GDExtensionMethodBindPtr = {
        let methodName = StringName("sampler_create")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2327892535)!
            }
            
        }
        
    }()
    
    /// Creates a new sampler. It can be accessed with the RID that is returned.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingDevice's ``freeRid(_:)`` method.
    /// 
    public final func samplerCreate(state: RDSamplerState?) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: state?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_sampler_create, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_sampler_is_format_supported_for_filter: GDExtensionMethodBindPtr = {
        let methodName = StringName("sampler_is_format_supported_for_filter")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2247922238)!
            }
            
        }
        
    }()
    
    /// Returns `true` if implementation supports using a texture of `format` with the given `samplerFilter`.
    public final func samplerIsFormatSupportedForFilter(format: RenderingDevice.DataFormat, samplerFilter: RenderingDevice.SamplerFilter) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: format.rawValue) { pArg0 in
            withUnsafePointer(to: samplerFilter.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RenderingDevice.method_sampler_is_format_supported_for_filter, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_vertex_buffer_create: GDExtensionMethodBindPtr = {
        let methodName = StringName("vertex_buffer_create")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3410049843)!
            }
            
        }
        
    }()
    
    /// It can be accessed with the RID that is returned.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingDevice's ``freeRid(_:)`` method.
    /// 
    public final func vertexBufferCreate(sizeBytes: UInt32, data: PackedByteArray = PackedByteArray(), useAsStorage: Bool = false) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: sizeBytes) { pArg0 in
            withUnsafePointer(to: data.content) { pArg1 in
                withUnsafePointer(to: useAsStorage) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(RenderingDevice.method_vertex_buffer_create, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_vertex_format_create: GDExtensionMethodBindPtr = {
        let methodName = StringName("vertex_format_create")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1242678479)!
            }
            
        }
        
    }()
    
    /// Creates a new vertex format with the specified `vertexDescriptions`. Returns a unique vertex format ID corresponding to the newly created vertex format.
    public final func vertexFormatCreate(vertexDescriptions: ObjectCollection<RDVertexAttribute>) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: vertexDescriptions.array.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_vertex_format_create, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_vertex_array_create: GDExtensionMethodBindPtr = {
        let methodName = StringName("vertex_array_create")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3799816279)!
            }
            
        }
        
    }()
    
    /// Creates a vertex array based on the specified buffers. Optionally, `offsets` (in bytes) may be defined for each buffer.
    public final func vertexArrayCreate(vertexCount: UInt32, vertexFormat: Int, srcBuffers: VariantCollection<RID>, offsets: PackedInt64Array = PackedInt64Array()) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: vertexCount) { pArg0 in
            withUnsafePointer(to: vertexFormat) { pArg1 in
                withUnsafePointer(to: srcBuffers.array.content) { pArg2 in
                    withUnsafePointer(to: offsets.content) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(RenderingDevice.method_vertex_array_create, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_index_buffer_create: GDExtensionMethodBindPtr = {
        let methodName = StringName("index_buffer_create")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3935920523)!
            }
            
        }
        
    }()
    
    /// Creates a new index buffer. It can be accessed with the RID that is returned.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingDevice's ``freeRid(_:)`` method.
    /// 
    public final func indexBufferCreate(sizeIndices: UInt32, format: RenderingDevice.IndexBufferFormat, data: PackedByteArray = PackedByteArray(), useRestartIndices: Bool = false) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: sizeIndices) { pArg0 in
            withUnsafePointer(to: format.rawValue) { pArg1 in
                withUnsafePointer(to: data.content) { pArg2 in
                    withUnsafePointer(to: useRestartIndices) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(RenderingDevice.method_index_buffer_create, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_index_array_create: GDExtensionMethodBindPtr = {
        let methodName = StringName("index_array_create")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2256026069)!
            }
            
        }
        
    }()
    
    /// Creates a new index array. It can be accessed with the RID that is returned.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingDevice's ``freeRid(_:)`` method.
    /// 
    public final func indexArrayCreate(indexBuffer: RID, indexOffset: UInt32, indexCount: UInt32) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: indexBuffer.content) { pArg0 in
            withUnsafePointer(to: indexOffset) { pArg1 in
                withUnsafePointer(to: indexCount) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(RenderingDevice.method_index_array_create, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shader_compile_spirv_from_source: GDExtensionMethodBindPtr = {
        let methodName = StringName("shader_compile_spirv_from_source")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1178973306)!
            }
            
        }
        
    }()
    
    /// Compiles a SPIR-V from the shader source code in `shaderSource` and returns the SPIR-V as a ``RDShaderSPIRV``. This intermediate language shader is portable across different GPU models and driver versions, but cannot be run directly by GPUs until compiled into a binary shader using ``shaderCompileBinaryFromSpirv(spirvData:name:)``.
    /// 
    /// If `allowCache` is `true`, make use of the shader cache generated by Godot. This avoids a potentially lengthy shader compilation step if the shader is already in cache. If `allowCache` is `false`, Godot's shader cache is ignored and the shader will always be recompiled.
    /// 
    public final func shaderCompileSpirvFromSource(shaderSource: RDShaderSource?, allowCache: Bool = true) -> RDShaderSPIRV? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: shaderSource?.handle) { pArg0 in
            withUnsafePointer(to: allowCache) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RenderingDevice.method_shader_compile_spirv_from_source, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_shader_compile_binary_from_spirv: GDExtensionMethodBindPtr = {
        let methodName = StringName("shader_compile_binary_from_spirv")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 134910450)!
            }
            
        }
        
    }()
    
    /// Compiles a binary shader from `spirvData` and returns the compiled binary data as a ``PackedByteArray``. This compiled shader is specific to the GPU model and driver version used; it will not work on different GPU models or even different driver versions. See also ``shaderCompileSpirvFromSource(shaderSource:allowCache:)``.
    /// 
    /// `name` is an optional human-readable name that can be given to the compiled shader for organizational purposes.
    /// 
    public final func shaderCompileBinaryFromSpirv(spirvData: RDShaderSPIRV?, name: String = "") -> PackedByteArray {
        let _result: PackedByteArray = PackedByteArray ()
        withUnsafePointer(to: spirvData?.handle) { pArg0 in
            let name = GString(name)
            withUnsafePointer(to: name.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RenderingDevice.method_shader_compile_binary_from_spirv, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shader_create_from_spirv: GDExtensionMethodBindPtr = {
        let methodName = StringName("shader_create_from_spirv")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 342949005)!
            }
            
        }
        
    }()
    
    /// Creates a new shader instance from SPIR-V intermediate code. It can be accessed with the RID that is returned.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingDevice's ``freeRid(_:)`` method. See also ``shaderCompileSpirvFromSource(shaderSource:allowCache:)`` and ``shaderCreateFromBytecode(binaryData:placeholderRid:)``.
    /// 
    public final func shaderCreateFromSpirv(spirvData: RDShaderSPIRV?, name: String = "") -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: spirvData?.handle) { pArg0 in
            let name = GString(name)
            withUnsafePointer(to: name.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RenderingDevice.method_shader_create_from_spirv, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shader_create_from_bytecode: GDExtensionMethodBindPtr = {
        let methodName = StringName("shader_create_from_bytecode")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1687031350)!
            }
            
        }
        
    }()
    
    /// Creates a new shader instance from a binary compiled shader. It can be accessed with the RID that is returned.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingDevice's ``freeRid(_:)`` method. See also ``shaderCompileBinaryFromSpirv(spirvData:name:)`` and ``shaderCreateFromSpirv(spirvData:name:)``.
    /// 
    public final func shaderCreateFromBytecode(binaryData: PackedByteArray, placeholderRid: RID = RID()) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: binaryData.content) { pArg0 in
            withUnsafePointer(to: placeholderRid.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RenderingDevice.method_shader_create_from_bytecode, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_shader_create_placeholder: GDExtensionMethodBindPtr = {
        let methodName = StringName("shader_create_placeholder")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Create a placeholder RID by allocating an RID without initializing it for use in ``shaderCreateFromBytecode(binaryData:placeholderRid:)``. This allows you to create an RID for a shader and pass it around, but defer compiling the shader to a later time.
    public final func shaderCreatePlaceholder() -> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall(RenderingDevice.method_shader_create_placeholder, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_shader_get_vertex_input_attribute_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName("shader_get_vertex_input_attribute_mask")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3917799429)!
            }
            
        }
        
    }()
    
    /// Returns the internal vertex input mask. Internally, the vertex input mask is an unsigned integer consisting of the locations (specified in GLSL via. `layout(location = ...)`) of the input variables (specified in GLSL by the `in` keyword).
    public final func shaderGetVertexInputAttributeMask(shader: RID) -> UInt {
        var _result: UInt = 0
        withUnsafePointer(to: shader.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_shader_get_vertex_input_attribute_mask, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_uniform_buffer_create: GDExtensionMethodBindPtr = {
        let methodName = StringName("uniform_buffer_create")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 34556762)!
            }
            
        }
        
    }()
    
    /// Creates a new uniform buffer. It can be accessed with the RID that is returned.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingDevice's ``freeRid(_:)`` method.
    /// 
    public final func uniformBufferCreate(sizeBytes: UInt32, data: PackedByteArray = PackedByteArray()) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: sizeBytes) { pArg0 in
            withUnsafePointer(to: data.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RenderingDevice.method_uniform_buffer_create, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_storage_buffer_create: GDExtensionMethodBindPtr = {
        let methodName = StringName("storage_buffer_create")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2316365934)!
            }
            
        }
        
    }()
    
    /// Creates a <a href="https://vkguide.dev/docs/chapter-4/storage_buffers/">storage buffer</a> with the specified `data` and `usage`. It can be accessed with the RID that is returned.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingDevice's ``freeRid(_:)`` method.
    /// 
    public final func storageBufferCreate(sizeBytes: UInt32, data: PackedByteArray = PackedByteArray(), usage: RenderingDevice.StorageBufferUsage = []) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: sizeBytes) { pArg0 in
            withUnsafePointer(to: data.content) { pArg1 in
                withUnsafePointer(to: usage.rawValue) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(RenderingDevice.method_storage_buffer_create, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_texture_buffer_create: GDExtensionMethodBindPtr = {
        let methodName = StringName("texture_buffer_create")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1470338698)!
            }
            
        }
        
    }()
    
    /// Creates a new texture buffer. It can be accessed with the RID that is returned.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingDevice's ``freeRid(_:)`` method.
    /// 
    public final func textureBufferCreate(sizeBytes: UInt32, format: RenderingDevice.DataFormat, data: PackedByteArray = PackedByteArray()) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: sizeBytes) { pArg0 in
            withUnsafePointer(to: format.rawValue) { pArg1 in
                withUnsafePointer(to: data.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(RenderingDevice.method_texture_buffer_create, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_uniform_set_create: GDExtensionMethodBindPtr = {
        let methodName = StringName("uniform_set_create")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2280795797)!
            }
            
        }
        
    }()
    
    /// Creates a new uniform set. It can be accessed with the RID that is returned.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingDevice's ``freeRid(_:)`` method.
    /// 
    public final func uniformSetCreate(uniforms: ObjectCollection<RDUniform>, shader: RID, shaderSet: UInt32) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: uniforms.array.content) { pArg0 in
            withUnsafePointer(to: shader.content) { pArg1 in
                withUnsafePointer(to: shaderSet) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(RenderingDevice.method_uniform_set_create, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_uniform_set_is_valid: GDExtensionMethodBindPtr = {
        let methodName = StringName("uniform_set_is_valid")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3521089500)!
            }
            
        }
        
    }()
    
    /// Checks if the `uniformSet` is valid, i.e. is owned.
    public final func uniformSetIsValid(uniformSet: RID) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: uniformSet.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_uniform_set_is_valid, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_buffer_copy: GDExtensionMethodBindPtr = {
        let methodName = StringName("buffer_copy")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 864257779)!
            }
            
        }
        
    }()
    
    /// Copies `size` bytes from the `srcBuffer` at `srcOffset` into `dstBuffer` at `dstOffset`.
    /// 
    /// Prints an error if:
    /// 
    /// - `size` exceeds the size of either `srcBuffer` or `dstBuffer` at their corresponding offsets
    /// 
    /// - a draw list is currently active (created by ``drawListBegin(framebuffer:initialColorAction:finalColorAction:initialDepthAction:finalDepthAction:clearColorValues:clearDepth:clearStencil:region:)``)
    /// 
    /// - a compute list is currently active (created by ``computeListBegin()``)
    /// 
    public final func bufferCopy(srcBuffer: RID, dstBuffer: RID, srcOffset: UInt32, dstOffset: UInt32, size: UInt32) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: srcBuffer.content) { pArg0 in
            withUnsafePointer(to: dstBuffer.content) { pArg1 in
                withUnsafePointer(to: srcOffset) { pArg2 in
                    withUnsafePointer(to: dstOffset) { pArg3 in
                        withUnsafePointer(to: size) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    gi.object_method_bind_ptrcall(RenderingDevice.method_buffer_copy, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_buffer_update: GDExtensionMethodBindPtr = {
        let methodName = StringName("buffer_update")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3454956949)!
            }
            
        }
        
    }()
    
    /// Updates a region of `sizeBytes` bytes, starting at `offset`, in the buffer, with the specified `data`.
    /// 
    /// Prints an error if:
    /// 
    /// - the region specified by `offset` + `sizeBytes` exceeds the buffer
    /// 
    /// - a draw list is currently active (created by ``drawListBegin(framebuffer:initialColorAction:finalColorAction:initialDepthAction:finalDepthAction:clearColorValues:clearDepth:clearStencil:region:)``)
    /// 
    /// - a compute list is currently active (created by ``computeListBegin()``)
    /// 
    public final func bufferUpdate(buffer: RID, offset: UInt32, sizeBytes: UInt32, data: PackedByteArray) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: buffer.content) { pArg0 in
            withUnsafePointer(to: offset) { pArg1 in
                withUnsafePointer(to: sizeBytes) { pArg2 in
                    withUnsafePointer(to: data.content) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(RenderingDevice.method_buffer_update, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_buffer_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName("buffer_clear")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2452320800)!
            }
            
        }
        
    }()
    
    /// Clears the contents of the `buffer`, clearing `sizeBytes` bytes, starting at `offset`.
    /// 
    /// Prints an error if:
    /// 
    /// - the size isn't a multiple of four
    /// 
    /// - the region specified by `offset` + `sizeBytes` exceeds the buffer
    /// 
    /// - a draw list is currently active (created by ``drawListBegin(framebuffer:initialColorAction:finalColorAction:initialDepthAction:finalDepthAction:clearColorValues:clearDepth:clearStencil:region:)``)
    /// 
    /// - a compute list is currently active (created by ``computeListBegin()``)
    /// 
    public final func bufferClear(buffer: RID, offset: UInt32, sizeBytes: UInt32) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: buffer.content) { pArg0 in
            withUnsafePointer(to: offset) { pArg1 in
                withUnsafePointer(to: sizeBytes) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(RenderingDevice.method_buffer_clear, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_buffer_get_data: GDExtensionMethodBindPtr = {
        let methodName = StringName("buffer_get_data")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3101830688)!
            }
            
        }
        
    }()
    
    /// Returns a copy of the data of the specified `buffer`, optionally `offsetBytes` and `sizeBytes` can be set to copy only a portion of the buffer.
    public final func bufferGetData(buffer: RID, offsetBytes: UInt32 = 0, sizeBytes: UInt32 = 0) -> PackedByteArray {
        let _result: PackedByteArray = PackedByteArray ()
        withUnsafePointer(to: buffer.content) { pArg0 in
            withUnsafePointer(to: offsetBytes) { pArg1 in
                withUnsafePointer(to: sizeBytes) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(RenderingDevice.method_buffer_get_data, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_render_pipeline_create: GDExtensionMethodBindPtr = {
        let methodName = StringName("render_pipeline_create")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2385451958)!
            }
            
        }
        
    }()
    
    /// Creates a new render pipeline. It can be accessed with the RID that is returned.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingDevice's ``freeRid(_:)`` method.
    /// 
    public final func renderPipelineCreate(shader: RID, framebufferFormat: Int, vertexFormat: Int, primitive: RenderingDevice.RenderPrimitive, rasterizationState: RDPipelineRasterizationState?, multisampleState: RDPipelineMultisampleState?, stencilState: RDPipelineDepthStencilState?, colorBlendState: RDPipelineColorBlendState?, dynamicStateFlags: RenderingDevice.PipelineDynamicStateFlags = [], forRenderPass: UInt32 = 0, specializationConstants: ObjectCollection<RDPipelineSpecializationConstant>) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: shader.content) { pArg0 in
            withUnsafePointer(to: framebufferFormat) { pArg1 in
                withUnsafePointer(to: vertexFormat) { pArg2 in
                    withUnsafePointer(to: primitive.rawValue) { pArg3 in
                        withUnsafePointer(to: rasterizationState?.handle) { pArg4 in
                            withUnsafePointer(to: multisampleState?.handle) { pArg5 in
                                withUnsafePointer(to: stencilState?.handle) { pArg6 in
                                    withUnsafePointer(to: colorBlendState?.handle) { pArg7 in
                                        withUnsafePointer(to: dynamicStateFlags.rawValue) { pArg8 in
                                            withUnsafePointer(to: forRenderPass) { pArg9 in
                                                withUnsafePointer(to: specializationConstants.array.content) { pArg10 in
                                                    withUnsafePointer(to: UnsafeRawPointersN11(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6, pArg7, pArg8, pArg9, pArg10)) { pArgs in
                                                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 11) { pArgs in
                                                            gi.object_method_bind_ptrcall(RenderingDevice.method_render_pipeline_create, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                                                        }
                                                        
                                                    }
                                                    
                                                }
                                                
                                            }
                                            
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_render_pipeline_is_valid: GDExtensionMethodBindPtr = {
        let methodName = StringName("render_pipeline_is_valid")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3521089500)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the render pipeline specified by the `renderPipeline` RID is valid, `false` otherwise.
    public final func renderPipelineIsValid(renderPipeline: RID) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: renderPipeline.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_render_pipeline_is_valid, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_compute_pipeline_create: GDExtensionMethodBindPtr = {
        let methodName = StringName("compute_pipeline_create")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1448838280)!
            }
            
        }
        
    }()
    
    /// Creates a new compute pipeline. It can be accessed with the RID that is returned.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingDevice's ``freeRid(_:)`` method.
    /// 
    public final func computePipelineCreate(shader: RID, specializationConstants: ObjectCollection<RDPipelineSpecializationConstant>) -> RID {
        let _result: RID = RID ()
        withUnsafePointer(to: shader.content) { pArg0 in
            withUnsafePointer(to: specializationConstants.array.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RenderingDevice.method_compute_pipeline_create, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_compute_pipeline_is_valid: GDExtensionMethodBindPtr = {
        let methodName = StringName("compute_pipeline_is_valid")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3521089500)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the compute pipeline specified by the `computePipeline` RID is valid, `false` otherwise.
    public final func computePipelineIsValid(computePipeline: RID) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: computePipeline.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_compute_pipeline_is_valid, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_screen_get_width: GDExtensionMethodBindPtr = {
        let methodName = StringName("screen_get_width")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1591665591)!
            }
            
        }
        
    }()
    
    /// Returns the window width matching the graphics API context for the given window ID (in pixels). Despite the parameter being named `screen`, this returns the _window_ size. See also ``screenGetHeight(screen:)``.
    /// 
    /// > Note: Only the main ``RenderingDevice`` returned by ``RenderingServer/getRenderingDevice()`` has a width. If called on a local ``RenderingDevice``, this method prints an error and returns ``invalidId``.
    /// 
    public final func screenGetWidth(screen: Int32 = 0) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: screen) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_screen_get_width, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_screen_get_height: GDExtensionMethodBindPtr = {
        let methodName = StringName("screen_get_height")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1591665591)!
            }
            
        }
        
    }()
    
    /// Returns the window height matching the graphics API context for the given window ID (in pixels). Despite the parameter being named `screen`, this returns the _window_ size. See also ``screenGetWidth(screen:)``.
    /// 
    /// > Note: Only the main ``RenderingDevice`` returned by ``RenderingServer/getRenderingDevice()`` has a height. If called on a local ``RenderingDevice``, this method prints an error and returns ``invalidId``.
    /// 
    public final func screenGetHeight(screen: Int32 = 0) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: screen) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_screen_get_height, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_screen_get_framebuffer_format: GDExtensionMethodBindPtr = {
        let methodName = StringName("screen_get_framebuffer_format")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1591665591)!
            }
            
        }
        
    }()
    
    /// Returns the framebuffer format of the given screen.
    /// 
    /// > Note: Only the main ``RenderingDevice`` returned by ``RenderingServer/getRenderingDevice()`` has a format. If called on a local ``RenderingDevice``, this method prints an error and returns ``invalidId``.
    /// 
    public final func screenGetFramebufferFormat(screen: Int32 = 0) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: screen) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_screen_get_framebuffer_format, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_draw_list_begin_for_screen: GDExtensionMethodBindPtr = {
        let methodName = StringName("draw_list_begin_for_screen")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3988079995)!
            }
            
        }
        
    }()
    
    /// High-level variant of ``drawListBegin(framebuffer:initialColorAction:finalColorAction:initialDepthAction:finalDepthAction:clearColorValues:clearDepth:clearStencil:region:)``, with the parameters automatically being adjusted for drawing onto the window specified by the `screen` ID.
    /// 
    /// > Note: Cannot be used with local RenderingDevices, as these don't have a screen. If called on a local RenderingDevice, ``drawListBeginForScreen(_:clearColor:)`` returns ``invalidId``.
    /// 
    public final func drawListBeginForScreen(_ screen: Int32 = 0, clearColor: Color = Color (r: 0, g: 0, b: 0, a: 1)) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: screen) { pArg0 in
            withUnsafePointer(to: clearColor) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RenderingDevice.method_draw_list_begin_for_screen, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_draw_list_begin: GDExtensionMethodBindPtr = {
        let methodName = StringName("draw_list_begin")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2686605154)!
            }
            
        }
        
    }()
    
    /// Starts a list of raster drawing commands created with the `draw_*` methods. The returned value should be passed to other `draw_list_*` functions.
    /// 
    /// Multiple draw lists cannot be created at the same time; you must finish the previous draw list first using ``drawListEnd()``.
    /// 
    /// A simple drawing operation might look like this (code is not a complete example):
    /// 
    public final func drawListBegin(framebuffer: RID, initialColorAction: RenderingDevice.InitialAction, finalColorAction: RenderingDevice.FinalAction, initialDepthAction: RenderingDevice.InitialAction, finalDepthAction: RenderingDevice.FinalAction, clearColorValues: PackedColorArray = PackedColorArray(), clearDepth: Double = 1.0, clearStencil: UInt32 = 0, region: Rect2 = Rect2 (x: 0, y: 0, width: 0, height: 0)) -> Int {
        var _result: Int = 0
        withUnsafePointer(to: framebuffer.content) { pArg0 in
            withUnsafePointer(to: initialColorAction.rawValue) { pArg1 in
                withUnsafePointer(to: finalColorAction.rawValue) { pArg2 in
                    withUnsafePointer(to: initialDepthAction.rawValue) { pArg3 in
                        withUnsafePointer(to: finalDepthAction.rawValue) { pArg4 in
                            withUnsafePointer(to: clearColorValues.content) { pArg5 in
                                withUnsafePointer(to: clearDepth) { pArg6 in
                                    withUnsafePointer(to: clearStencil) { pArg7 in
                                        withUnsafePointer(to: region) { pArg8 in
                                            withUnsafePointer(to: UnsafeRawPointersN9(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6, pArg7, pArg8)) { pArgs in
                                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 9) { pArgs in
                                                    gi.object_method_bind_ptrcall(RenderingDevice.method_draw_list_begin, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                                                }
                                                
                                            }
                                            
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_draw_list_begin_split: GDExtensionMethodBindPtr = {
        let methodName = StringName("draw_list_begin_split")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2406300660)!
            }
            
        }
        
    }()
    
    /// This method does nothing and always returns an empty ``PackedInt64Array``.
    public final func drawListBeginSplit(framebuffer: RID, splits: UInt32, initialColorAction: RenderingDevice.InitialAction, finalColorAction: RenderingDevice.FinalAction, initialDepthAction: RenderingDevice.InitialAction, finalDepthAction: RenderingDevice.FinalAction, clearColorValues: PackedColorArray = PackedColorArray(), clearDepth: Double = 1.0, clearStencil: UInt32 = 0, region: Rect2 = Rect2 (x: 0, y: 0, width: 0, height: 0), storageTextures: VariantCollection<RID> = VariantCollection<RID> ()) -> PackedInt64Array {
        let _result: PackedInt64Array = PackedInt64Array ()
        withUnsafePointer(to: framebuffer.content) { pArg0 in
            withUnsafePointer(to: splits) { pArg1 in
                withUnsafePointer(to: initialColorAction.rawValue) { pArg2 in
                    withUnsafePointer(to: finalColorAction.rawValue) { pArg3 in
                        withUnsafePointer(to: initialDepthAction.rawValue) { pArg4 in
                            withUnsafePointer(to: finalDepthAction.rawValue) { pArg5 in
                                withUnsafePointer(to: clearColorValues.content) { pArg6 in
                                    withUnsafePointer(to: clearDepth) { pArg7 in
                                        withUnsafePointer(to: clearStencil) { pArg8 in
                                            withUnsafePointer(to: region) { pArg9 in
                                                withUnsafePointer(to: storageTextures.array.content) { pArg10 in
                                                    withUnsafePointer(to: UnsafeRawPointersN11(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6, pArg7, pArg8, pArg9, pArg10)) { pArgs in
                                                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 11) { pArgs in
                                                            gi.object_method_bind_ptrcall(RenderingDevice.method_draw_list_begin_split, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                                                        }
                                                        
                                                    }
                                                    
                                                }
                                                
                                            }
                                            
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_draw_list_set_blend_constants: GDExtensionMethodBindPtr = {
        let methodName = StringName("draw_list_set_blend_constants")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2878471219)!
            }
            
        }
        
    }()
    
    /// Sets blend constants for the specified `drawList` to `color`. Blend constants are used only if the graphics pipeline is created with .dynamicStateBlendConstants flag set.
    public final func drawListSetBlendConstants(drawList: Int, color: Color) {
        withUnsafePointer(to: drawList) { pArg0 in
            withUnsafePointer(to: color) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RenderingDevice.method_draw_list_set_blend_constants, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_draw_list_bind_render_pipeline: GDExtensionMethodBindPtr = {
        let methodName = StringName("draw_list_bind_render_pipeline")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4040184819)!
            }
            
        }
        
    }()
    
    /// Binds `renderPipeline` to the specified `drawList`.
    public final func drawListBindRenderPipeline(drawList: Int, renderPipeline: RID) {
        withUnsafePointer(to: drawList) { pArg0 in
            withUnsafePointer(to: renderPipeline.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RenderingDevice.method_draw_list_bind_render_pipeline, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_draw_list_bind_uniform_set: GDExtensionMethodBindPtr = {
        let methodName = StringName("draw_list_bind_uniform_set")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 749655778)!
            }
            
        }
        
    }()
    
    /// Binds `uniformSet` to the specified `drawList`. A `setIndex` must also be specified, which is an identifier starting from `0` that must match the one expected by the draw list.
    public final func drawListBindUniformSet(drawList: Int, uniformSet: RID, setIndex: UInt32) {
        withUnsafePointer(to: drawList) { pArg0 in
            withUnsafePointer(to: uniformSet.content) { pArg1 in
                withUnsafePointer(to: setIndex) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(RenderingDevice.method_draw_list_bind_uniform_set, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_draw_list_bind_vertex_array: GDExtensionMethodBindPtr = {
        let methodName = StringName("draw_list_bind_vertex_array")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4040184819)!
            }
            
        }
        
    }()
    
    /// Binds `vertexArray` to the specified `drawList`.
    public final func drawListBindVertexArray(drawList: Int, vertexArray: RID) {
        withUnsafePointer(to: drawList) { pArg0 in
            withUnsafePointer(to: vertexArray.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RenderingDevice.method_draw_list_bind_vertex_array, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_draw_list_bind_index_array: GDExtensionMethodBindPtr = {
        let methodName = StringName("draw_list_bind_index_array")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4040184819)!
            }
            
        }
        
    }()
    
    /// Binds `indexArray` to the specified `drawList`.
    public final func drawListBindIndexArray(drawList: Int, indexArray: RID) {
        withUnsafePointer(to: drawList) { pArg0 in
            withUnsafePointer(to: indexArray.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RenderingDevice.method_draw_list_bind_index_array, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_draw_list_set_push_constant: GDExtensionMethodBindPtr = {
        let methodName = StringName("draw_list_set_push_constant")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2772371345)!
            }
            
        }
        
    }()
    
    /// Sets the push constant data to `buffer` for the specified `drawList`. The shader determines how this binary data is used. The buffer's size in bytes must also be specified in `sizeBytes` (this can be obtained by calling the ``PackedByteArray/size()`` method on the passed `buffer`).
    public final func drawListSetPushConstant(drawList: Int, buffer: PackedByteArray, sizeBytes: UInt32) {
        withUnsafePointer(to: drawList) { pArg0 in
            withUnsafePointer(to: buffer.content) { pArg1 in
                withUnsafePointer(to: sizeBytes) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(RenderingDevice.method_draw_list_set_push_constant, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_draw_list_draw: GDExtensionMethodBindPtr = {
        let methodName = StringName("draw_list_draw")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4230067973)!
            }
            
        }
        
    }()
    
    /// Submits `drawList` for rendering on the GPU. This is the raster equivalent to ``computeListDispatch(computeList:xGroups:yGroups:zGroups:)``.
    public final func drawListDraw(drawList: Int, useIndices: Bool, instances: UInt32, proceduralVertexCount: UInt32 = 0) {
        withUnsafePointer(to: drawList) { pArg0 in
            withUnsafePointer(to: useIndices) { pArg1 in
                withUnsafePointer(to: instances) { pArg2 in
                    withUnsafePointer(to: proceduralVertexCount) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(RenderingDevice.method_draw_list_draw, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_draw_list_enable_scissor: GDExtensionMethodBindPtr = {
        let methodName = StringName("draw_list_enable_scissor")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 244650101)!
            }
            
        }
        
    }()
    
    /// Creates a scissor rectangle and enables it for the specified `drawList`. Scissor rectangles are used for clipping by discarding fragments that fall outside a specified rectangular portion of the screen. See also ``drawListDisableScissor(drawList:)``.
    /// 
    /// > Note: The specified `rect` is automatically intersected with the screen's dimensions, which means it cannot exceed the screen's dimensions.
    /// 
    public final func drawListEnableScissor(drawList: Int, rect: Rect2 = Rect2 (x: 0, y: 0, width: 0, height: 0)) {
        withUnsafePointer(to: drawList) { pArg0 in
            withUnsafePointer(to: rect) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RenderingDevice.method_draw_list_enable_scissor, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_draw_list_disable_scissor: GDExtensionMethodBindPtr = {
        let methodName = StringName("draw_list_disable_scissor")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Removes and disables the scissor rectangle for the specified `drawList`. See also ``drawListEnableScissor(drawList:rect:)``.
    public final func drawListDisableScissor(drawList: Int) {
        withUnsafePointer(to: drawList) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_draw_list_disable_scissor, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_draw_list_switch_to_next_pass: GDExtensionMethodBindPtr = {
        let methodName = StringName("draw_list_switch_to_next_pass")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2455072627)!
            }
            
        }
        
    }()
    
    /// Switches to the next draw pass.
    public final func drawListSwitchToNextPass() -> Int {
        var _result: Int = 0
        gi.object_method_bind_ptrcall(RenderingDevice.method_draw_list_switch_to_next_pass, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_draw_list_switch_to_next_pass_split: GDExtensionMethodBindPtr = {
        let methodName = StringName("draw_list_switch_to_next_pass_split")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2865087369)!
            }
            
        }
        
    }()
    
    /// This method does nothing and always returns an empty ``PackedInt64Array``.
    public final func drawListSwitchToNextPassSplit(splits: UInt32) -> PackedInt64Array {
        let _result: PackedInt64Array = PackedInt64Array ()
        withUnsafePointer(to: splits) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_draw_list_switch_to_next_pass_split, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_draw_list_end: GDExtensionMethodBindPtr = {
        let methodName = StringName("draw_list_end")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Finishes a list of raster drawing commands created with the `draw_*` methods.
    public final func drawListEnd() {
        gi.object_method_bind_ptrcall(RenderingDevice.method_draw_list_end, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_compute_list_begin: GDExtensionMethodBindPtr = {
        let methodName = StringName("compute_list_begin")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2455072627)!
            }
            
        }
        
    }()
    
    /// Starts a list of compute commands created with the `compute_*` methods. The returned value should be passed to other `compute_list_*` functions.
    /// 
    /// Multiple compute lists cannot be created at the same time; you must finish the previous compute list first using ``computeListEnd()``.
    /// 
    /// A simple compute operation might look like this (code is not a complete example):
    /// 
    public final func computeListBegin() -> Int {
        var _result: Int = 0
        gi.object_method_bind_ptrcall(RenderingDevice.method_compute_list_begin, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_compute_list_bind_compute_pipeline: GDExtensionMethodBindPtr = {
        let methodName = StringName("compute_list_bind_compute_pipeline")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4040184819)!
            }
            
        }
        
    }()
    
    /// Tells the GPU what compute pipeline to use when processing the compute list. If the shader has changed since the last time this function was called, Godot will unbind all descriptor sets and will re-bind them inside ``computeListDispatch(computeList:xGroups:yGroups:zGroups:)``.
    public final func computeListBindComputePipeline(computeList: Int, computePipeline: RID) {
        withUnsafePointer(to: computeList) { pArg0 in
            withUnsafePointer(to: computePipeline.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RenderingDevice.method_compute_list_bind_compute_pipeline, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_compute_list_set_push_constant: GDExtensionMethodBindPtr = {
        let methodName = StringName("compute_list_set_push_constant")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2772371345)!
            }
            
        }
        
    }()
    
    /// Sets the push constant data to `buffer` for the specified `computeList`. The shader determines how this binary data is used. The buffer's size in bytes must also be specified in `sizeBytes` (this can be obtained by calling the ``PackedByteArray/size()`` method on the passed `buffer`).
    public final func computeListSetPushConstant(computeList: Int, buffer: PackedByteArray, sizeBytes: UInt32) {
        withUnsafePointer(to: computeList) { pArg0 in
            withUnsafePointer(to: buffer.content) { pArg1 in
                withUnsafePointer(to: sizeBytes) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(RenderingDevice.method_compute_list_set_push_constant, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_compute_list_bind_uniform_set: GDExtensionMethodBindPtr = {
        let methodName = StringName("compute_list_bind_uniform_set")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 749655778)!
            }
            
        }
        
    }()
    
    /// Binds the `uniformSet` to this `computeList`. Godot ensures that all textures in the uniform set have the correct Vulkan access masks. If Godot had to change access masks of textures, it will raise a Vulkan image memory barrier.
    public final func computeListBindUniformSet(computeList: Int, uniformSet: RID, setIndex: UInt32) {
        withUnsafePointer(to: computeList) { pArg0 in
            withUnsafePointer(to: uniformSet.content) { pArg1 in
                withUnsafePointer(to: setIndex) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(RenderingDevice.method_compute_list_bind_uniform_set, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_compute_list_dispatch: GDExtensionMethodBindPtr = {
        let methodName = StringName("compute_list_dispatch")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4275841770)!
            }
            
        }
        
    }()
    
    /// Submits the compute list for processing on the GPU. This is the compute equivalent to ``drawListDraw(drawList:useIndices:instances:proceduralVertexCount:)``.
    public final func computeListDispatch(computeList: Int, xGroups: UInt32, yGroups: UInt32, zGroups: UInt32) {
        withUnsafePointer(to: computeList) { pArg0 in
            withUnsafePointer(to: xGroups) { pArg1 in
                withUnsafePointer(to: yGroups) { pArg2 in
                    withUnsafePointer(to: zGroups) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(RenderingDevice.method_compute_list_dispatch, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_compute_list_dispatch_indirect: GDExtensionMethodBindPtr = {
        let methodName = StringName("compute_list_dispatch_indirect")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 749655778)!
            }
            
        }
        
    }()
    
    /// Submits the compute list for processing on the GPU with the given group counts stored in the `buffer` at `offset`. Buffer must have been created with .dispatchIndirect flag.
    public final func computeListDispatchIndirect(computeList: Int, buffer: RID, offset: UInt32) {
        withUnsafePointer(to: computeList) { pArg0 in
            withUnsafePointer(to: buffer.content) { pArg1 in
                withUnsafePointer(to: offset) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(RenderingDevice.method_compute_list_dispatch_indirect, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_compute_list_add_barrier: GDExtensionMethodBindPtr = {
        let methodName = StringName("compute_list_add_barrier")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Raises a Vulkan compute barrier in the specified `computeList`.
    public final func computeListAddBarrier(computeList: Int) {
        withUnsafePointer(to: computeList) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_compute_list_add_barrier, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_compute_list_end: GDExtensionMethodBindPtr = {
        let methodName = StringName("compute_list_end")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Finishes a list of compute commands created with the `compute_*` methods.
    public final func computeListEnd() {
        gi.object_method_bind_ptrcall(RenderingDevice.method_compute_list_end, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_free_rid: GDExtensionMethodBindPtr = {
        let methodName = StringName("free_rid")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2722037293)!
            }
            
        }
        
    }()
    
    /// Tries to free an object in the RenderingDevice. To avoid memory leaks, this should be called after using an object as memory management does not occur automatically when using RenderingDevice directly.
    public final func freeRid(_ rid: RID) {
        withUnsafePointer(to: rid.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_free_rid, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_capture_timestamp: GDExtensionMethodBindPtr = {
        let methodName = StringName("capture_timestamp")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Creates a timestamp marker with the specified `name`. This is used for performance reporting with the ``getCapturedTimestampCpuTime(index:)``, ``getCapturedTimestampGpuTime(index:)`` and ``getCapturedTimestampName(index:)`` methods.
    public final func captureTimestamp(name: String) {
        let name = GString(name)
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_capture_timestamp, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_captured_timestamps_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_captured_timestamps_count")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the total number of timestamps (rendering steps) available for profiling.
    public final func getCapturedTimestampsCount() -> UInt32 {
        var _result: UInt32 = 0
        gi.object_method_bind_ptrcall(RenderingDevice.method_get_captured_timestamps_count, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_captured_timestamps_frame: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_captured_timestamps_frame")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the index of the last frame rendered that has rendering timestamps available for querying.
    public final func getCapturedTimestampsFrame() -> UInt {
        var _result: UInt = 0
        gi.object_method_bind_ptrcall(RenderingDevice.method_get_captured_timestamps_frame, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_captured_timestamp_gpu_time: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_captured_timestamp_gpu_time")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the timestamp in GPU time for the rendering step specified by `index` (in microseconds since the engine started). See also ``getCapturedTimestampCpuTime(index:)`` and ``captureTimestamp(name:)``.
    public final func getCapturedTimestampGpuTime(index: UInt32) -> UInt {
        var _result: UInt = 0
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_get_captured_timestamp_gpu_time, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_captured_timestamp_cpu_time: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_captured_timestamp_cpu_time")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the timestamp in CPU time for the rendering step specified by `index` (in microseconds since the engine started). See also ``getCapturedTimestampGpuTime(index:)`` and ``captureTimestamp(name:)``.
    public final func getCapturedTimestampCpuTime(index: UInt32) -> UInt {
        var _result: UInt = 0
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_get_captured_timestamp_cpu_time, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_captured_timestamp_name: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_captured_timestamp_name")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns the timestamp's name for the rendering step specified by `index`. See also ``captureTimestamp(name:)``.
    public final func getCapturedTimestampName(index: UInt32) -> String {
        let _result = GString ()
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_get_captured_timestamp_name, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_limit_get: GDExtensionMethodBindPtr = {
        let methodName = StringName("limit_get")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1559202131)!
            }
            
        }
        
    }()
    
    /// Returns the value of the specified `limit`. This limit varies depending on the current graphics hardware (and sometimes the driver version). If the given limit is exceeded, rendering errors will occur.
    /// 
    /// Limits for various graphics hardware can be found in the <a href="https://vulkan.gpuinfo.org/">Vulkan Hardware Database</a>.
    /// 
    public final func limitGet(limit: RenderingDevice.Limit) -> UInt {
        var _result: UInt = 0
        withUnsafePointer(to: limit.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_limit_get, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_frame_delay: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_frame_delay")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the frame count kept by the graphics API. Higher values result in higher input lag, but with more consistent throughput. For the main ``RenderingDevice``, frames are cycled (usually 3 with triple-buffered V-Sync enabled). However, local ``RenderingDevice``s only have 1 frame.
    public final func getFrameDelay() -> UInt32 {
        var _result: UInt32 = 0
        gi.object_method_bind_ptrcall(RenderingDevice.method_get_frame_delay, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_submit: GDExtensionMethodBindPtr = {
        let methodName = StringName("submit")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Pushes the frame setup and draw command buffers then marks the local device as currently processing (which allows calling ``sync()``).
    /// 
    /// > Note: Only available in local RenderingDevices.
    /// 
    public final func submit() {
        gi.object_method_bind_ptrcall(RenderingDevice.method_submit, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_sync: GDExtensionMethodBindPtr = {
        let methodName = StringName("sync")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Forces a synchronization between the CPU and GPU, which may be required in certain cases. Only call this when needed, as CPU-GPU synchronization has a performance cost.
    /// 
    /// > Note: Only available in local RenderingDevices.
    /// 
    /// > Note: ``sync()`` can only be called after a ``submit()``.
    /// 
    public final func sync() {
        gi.object_method_bind_ptrcall(RenderingDevice.method_sync, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_barrier: GDExtensionMethodBindPtr = {
        let methodName = StringName("barrier")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3718155691)!
            }
            
        }
        
    }()
    
    /// This method does nothing.
    public final func barrier(from: RenderingDevice.BarrierMask = [.vertex, .fragment, .compute, .transfer, .raster, .allBarriers], to: RenderingDevice.BarrierMask = [.vertex, .fragment, .compute, .transfer, .raster, .allBarriers]) {
        withUnsafePointer(to: from.rawValue) { pArg0 in
            withUnsafePointer(to: to.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RenderingDevice.method_barrier, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_full_barrier: GDExtensionMethodBindPtr = {
        let methodName = StringName("full_barrier")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// This method does nothing.
    public final func fullBarrier() {
        gi.object_method_bind_ptrcall(RenderingDevice.method_full_barrier, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_create_local_device: GDExtensionMethodBindPtr = {
        let methodName = StringName("create_local_device")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2846302423)!
            }
            
        }
        
    }()
    
    /// Create a new local ``RenderingDevice``. This is most useful for performing compute operations on the GPU independently from the rest of the engine.
    public final func createLocalDevice() -> RenderingDevice? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(RenderingDevice.method_create_local_device, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_resource_name: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_resource_name")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2726140452)!
            }
            
        }
        
    }()
    
    /// Sets the resource name for `id` to `name`. This is used for debugging with third-party tools such as <a href="https://renderdoc.org/">RenderDoc</a>.
    /// 
    /// The following types of resources can be named: texture, sampler, vertex buffer, index buffer, uniform buffer, texture buffer, storage buffer, uniform set buffer, shader, render pipeline and compute pipeline. Framebuffers cannot be named. Attempting to name an incompatible resource type will print an error.
    /// 
    /// > Note: Resource names are only set when the engine runs in verbose mode (``OS/isStdoutVerbose()`` = `true`), or when using an engine build compiled with the `dev_mode=yes` SCons option. The graphics driver must also support the `VK_EXT_DEBUG_UTILS_EXTENSION_NAME` Vulkan extension for named resources to work.
    /// 
    public final func setResourceName(id: RID, name: String) {
        withUnsafePointer(to: id.content) { pArg0 in
            let name = GString(name)
            withUnsafePointer(to: name.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RenderingDevice.method_set_resource_name, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_draw_command_begin_label: GDExtensionMethodBindPtr = {
        let methodName = StringName("draw_command_begin_label")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1636512886)!
            }
            
        }
        
    }()
    
    /// Create a command buffer debug label region that can be displayed in third-party tools such as <a href="https://renderdoc.org/">RenderDoc</a>. All regions must be ended with a ``drawCommandEndLabel()`` call. When viewed from the linear series of submissions to a single queue, calls to ``drawCommandBeginLabel(name:color:)`` and ``drawCommandEndLabel()`` must be matched and balanced.
    /// 
    /// The `VK_EXT_DEBUG_UTILS_EXTENSION_NAME` Vulkan extension must be available and enabled for command buffer debug label region to work. See also ``drawCommandEndLabel()``.
    /// 
    public final func drawCommandBeginLabel(name: String, color: Color) {
        let name = GString(name)
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: color) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RenderingDevice.method_draw_command_begin_label, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_draw_command_insert_label: GDExtensionMethodBindPtr = {
        let methodName = StringName("draw_command_insert_label")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1636512886)!
            }
            
        }
        
    }()
    
    /// This method does nothing.
    public final func drawCommandInsertLabel(name: String, color: Color) {
        let name = GString(name)
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: color) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(RenderingDevice.method_draw_command_insert_label, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_draw_command_end_label: GDExtensionMethodBindPtr = {
        let methodName = StringName("draw_command_end_label")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Ends the command buffer debug label region started by a ``drawCommandBeginLabel(name:color:)`` call.
    public final func drawCommandEndLabel() {
        gi.object_method_bind_ptrcall(RenderingDevice.method_draw_command_end_label, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_get_device_vendor_name: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_device_vendor_name")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the vendor of the video adapter (e.g. "NVIDIA Corporation"). Equivalent to ``RenderingServer/getVideoAdapterVendor()``. See also ``getDeviceName()``.
    public final func getDeviceVendorName() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(RenderingDevice.method_get_device_vendor_name, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_device_name: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_device_name")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the name of the video adapter (e.g. "GeForce GTX 1080/PCIe/SSE2"). Equivalent to ``RenderingServer/getVideoAdapterName()``. See also ``getDeviceVendorName()``.
    public final func getDeviceName() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(RenderingDevice.method_get_device_name, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_device_pipeline_cache_uuid: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_device_pipeline_cache_uuid")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the universally unique identifier for the pipeline cache. This is used to cache shader files on disk, which avoids shader recompilations on subsequent engine runs. This UUID varies depending on the graphics card model, but also the driver version. Therefore, updating graphics drivers will invalidate the shader cache.
    public final func getDevicePipelineCacheUuid() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(RenderingDevice.method_get_device_pipeline_cache_uuid, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_memory_usage: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_memory_usage")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 251690689)!
            }
            
        }
        
    }()
    
    /// Returns the memory usage in bytes corresponding to the given `type`. When using Vulkan, these statistics are calculated by <a href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator">Vulkan Memory Allocator</a>.
    public final func getMemoryUsage(type: RenderingDevice.MemoryType) -> UInt {
        var _result: UInt = 0
        withUnsafePointer(to: type.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(RenderingDevice.method_get_memory_usage, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_driver_resource: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_driver_resource")
        return withUnsafePointer(to: &RenderingDevice.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 501815484)!
            }
            
        }
        
    }()
    
    /// Returns the unique identifier of the driver `resource` for the specified `rid`. Some driver resource types ignore the specified `rid` (see ``RenderingDevice/DriverResource`` descriptions). `index` is always ignored but must be specified anyway.
    public final func getDriverResource(_ resource: RenderingDevice.DriverResource, rid: RID, index: UInt) -> UInt {
        var _result: UInt = 0
        withUnsafePointer(to: resource.rawValue) { pArg0 in
            withUnsafePointer(to: rid.content) { pArg1 in
                withUnsafePointer(to: index) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(RenderingDevice.method_get_driver_resource, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
}

