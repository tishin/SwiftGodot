// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
import Foundation
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A singleton that allocates some ``Thread``s on startup, used to offload tasks to these threads.
/// 
/// The ``WorkerThreadPool`` singleton allocates a set of ``Thread``s (called worker threads) on project startup and provides methods for offloading tasks to them. This can be used for simple multithreading without having to create ``Thread``s.
/// 
/// Tasks hold the ``Callable`` to be run by the threads. ``WorkerThreadPool`` can be used to create regular tasks, which will be taken by one worker thread, or group tasks, which can be distributed between multiple worker threads. Group tasks execute the ``Callable`` multiple times, which makes them useful for iterating over a lot of elements, such as the enemies in an arena.
/// 
/// Here's a sample on how to offload an expensive function to worker threads:
/// 
/// The above code relies on the number of elements in the `enemies` array remaining constant during the multithreaded part.
/// 
/// > Note: Using this singleton could affect performance negatively if the task being distributed between threads is not computationally expensive.
/// 
open class WorkerThreadPool: Object {
    /// The shared instance of this class
    public static var shared: WorkerThreadPool = {
        return withUnsafePointer (to: &WorkerThreadPool.godotClassName.content) { ptr in
            WorkerThreadPool (nativeHandle: gi.global_get_singleton (ptr)!)
        }
        
    }()
    
    override open class var godotClassName: StringName { "WorkerThreadPool" }
    /* Methods */
    fileprivate static var method_add_task: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_task")
        return withUnsafePointer(to: &WorkerThreadPool.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3745067146)!
            }
            
        }
        
    }()
    
    /// Adds `action` as a task to be executed by a worker thread. `highPriority` determines if the task has a high priority or a low priority (default). You can optionally provide a `description` to help with debugging.
    /// 
    /// Returns a task ID that can be used by other methods.
    /// 
    /// > Warning: Every task must be waited for completion using ``waitForTaskCompletion(taskId:)`` or ``waitForGroupTaskCompletion(groupId:)`` at some point so that any allocated resources inside the task can be cleaned up.
    /// 
    public static func addTask(action: Callable, highPriority: Bool = false, description: String = "") -> Int {
        var _result: Int = 0
        withUnsafePointer(to: action.content) { pArg0 in
            withUnsafePointer(to: highPriority) { pArg1 in
                let description = GString(description)
                withUnsafePointer(to: description.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(method_add_task, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_task_completed: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_task_completed")
        return withUnsafePointer(to: &WorkerThreadPool.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the task with the given ID is completed.
    /// 
    /// > Note: You should only call this method between adding the task and awaiting its completion.
    /// 
    public static func isTaskCompleted(taskId: Int) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: taskId) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_is_task_completed, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_wait_for_task_completion: GDExtensionMethodBindPtr = {
        let methodName = StringName("wait_for_task_completion")
        return withUnsafePointer(to: &WorkerThreadPool.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 844576869)!
            }
            
        }
        
    }()
    
    /// Pauses the thread that calls this method until the task with the given ID is completed.
    /// 
    /// Returns ``@GlobalScope.OK`` if the task could be successfully awaited.
    /// 
    /// Returns ``@GlobalScope.ERR_INVALID_PARAMETER`` if a task with the passed ID does not exist (maybe because it was already awaited and disposed of).
    /// 
    /// Returns ``@GlobalScope.ERR_BUSY`` if the call is made from another running task and, due to task scheduling, there's potential for deadlocking (e.g., the task to await may be at a lower level in the call stack and therefore can't progress). This is an advanced situation that should only matter when some tasks depend on others (in the current implementation, the tricky case is a task trying to wait on an older one).
    /// 
    public static func waitForTaskCompletion(taskId: Int) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: taskId) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_wait_for_task_completion, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_add_group_task: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_group_task")
        return withUnsafePointer(to: &WorkerThreadPool.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1801953219)!
            }
            
        }
        
    }()
    
    /// Adds `action` as a group task to be executed by the worker threads. The ``Callable`` will be called a number of times based on `elements`, with the first thread calling it with the value `0` as a parameter, and each consecutive execution incrementing this value by 1 until it reaches `element - 1`.
    /// 
    /// The number of threads the task is distributed to is defined by `tasksNeeded`, where the default value `-1` means it is distributed to all worker threads. `highPriority` determines if the task has a high priority or a low priority (default). You can optionally provide a `description` to help with debugging.
    /// 
    /// Returns a group task ID that can be used by other methods.
    /// 
    /// > Warning: Every task must be waited for completion using ``waitForTaskCompletion(taskId:)`` or ``waitForGroupTaskCompletion(groupId:)`` at some point so that any allocated resources inside the task can be cleaned up.
    /// 
    public static func addGroupTask(action: Callable, elements: Int32, tasksNeeded: Int32 = -1, highPriority: Bool = false, description: String = "") -> Int {
        var _result: Int = 0
        withUnsafePointer(to: action.content) { pArg0 in
            withUnsafePointer(to: elements) { pArg1 in
                withUnsafePointer(to: tasksNeeded) { pArg2 in
                    withUnsafePointer(to: highPriority) { pArg3 in
                        let description = GString(description)
                        withUnsafePointer(to: description.content) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    gi.object_method_bind_ptrcall(method_add_group_task, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_group_task_completed: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_group_task_completed")
        return withUnsafePointer(to: &WorkerThreadPool.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the group task with the given ID is completed.
    /// 
    /// > Note: You should only call this method between adding the group task and awaiting its completion.
    /// 
    public static func isGroupTaskCompleted(groupId: Int) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: groupId) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_is_group_task_completed, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_group_processed_element_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_group_processed_element_count")
        return withUnsafePointer(to: &WorkerThreadPool.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns how many times the ``Callable`` of the group task with the given ID has already been executed by the worker threads.
    /// 
    /// > Note: If a thread has started executing the ``Callable`` but is yet to finish, it won't be counted.
    /// 
    public static func getGroupProcessedElementCount(groupId: Int) -> UInt32 {
        var _result: UInt32 = 0
        withUnsafePointer(to: groupId) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_get_group_processed_element_count, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_wait_for_group_task_completion: GDExtensionMethodBindPtr = {
        let methodName = StringName("wait_for_group_task_completion")
        return withUnsafePointer(to: &WorkerThreadPool.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Pauses the thread that calls this method until the group task with the given ID is completed.
    public static func waitForGroupTaskCompletion(groupId: Int) {
        withUnsafePointer(to: groupId) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(method_wait_for_group_task_completion, UnsafeMutableRawPointer(mutating: shared.handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
}

