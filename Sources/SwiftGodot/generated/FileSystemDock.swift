// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif


/// Godot editor's dock for managing files in the project.
/// 
/// This class is available only in ``EditorPlugin``s and can't be instantiated. You can access it using ``EditorInterface/getFileSystemDock()``.
/// 
/// While ``FileSystemDock`` doesn't expose any methods for file manipulation, it can listen for various file-related signals.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``inherit``
/// - ``instantiate``
/// - ``resourceRemoved``
/// - ``fileRemoved``
/// - ``folderRemoved``
/// - ``filesMoved``
/// - ``folderMoved``
/// - ``folderColorChanged``
/// - ``displayModeChanged``
open class FileSystemDock: VBoxContainer {
    override open class var godotClassName: StringName { "FileSystemDock" }
    /* Methods */
    fileprivate static var method_navigate_to_path: GDExtensionMethodBindPtr = {
        let methodName = StringName("navigate_to_path")
        return withUnsafePointer(to: &FileSystemDock.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Sets the given `path` as currently selected, ensuring that the selected file/directory is visible.
    public final func navigateToPath(_ path: String) {
        let path = GString(path)
        withUnsafePointer(to: path.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(FileSystemDock.method_navigate_to_path, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_resource_tooltip_plugin: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_resource_tooltip_plugin")
        return withUnsafePointer(to: &FileSystemDock.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2258356838)!
            }
            
        }
        
    }()
    
    /// Registers a new ``EditorResourceTooltipPlugin``.
    public final func addResourceTooltipPlugin(_ plugin: EditorResourceTooltipPlugin?) {
        withUnsafePointer(to: plugin?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(FileSystemDock.method_add_resource_tooltip_plugin, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_remove_resource_tooltip_plugin: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_resource_tooltip_plugin")
        return withUnsafePointer(to: &FileSystemDock.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2258356838)!
            }
            
        }
        
    }()
    
    /// Removes an ``EditorResourceTooltipPlugin``. Fails if the plugin wasn't previously added.
    public final func removeResourceTooltipPlugin(_ plugin: EditorResourceTooltipPlugin?) {
        withUnsafePointer(to: plugin?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(FileSystemDock.method_remove_resource_tooltip_plugin, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    // Signals 
    /// Emitted when a new scene is created that inherits the scene at `file` path.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.inherit.connect { file in
    ///    print ("caught signal")
    /// }
    /// ```
    public var inherit: SignalWithArguments<String> { SignalWithArguments<String> (target: self, signalName: "inherit") }
    
    /// Emitted when the given scenes are being instantiated in the editor.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.instantiate.connect { files in
    ///    print ("caught signal")
    /// }
    /// ```
    public var instantiate: SignalWithArguments<PackedStringArray> { SignalWithArguments<PackedStringArray> (target: self, signalName: "instantiate") }
    
    /// Emitted when an external `resource` had its file removed.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.resourceRemoved.connect { resource in
    ///    print ("caught signal")
    /// }
    /// ```
    public var resourceRemoved: SignalWithArguments<Resource?> { SignalWithArguments<Resource?> (target: self, signalName: "resource_removed") }
    
    /// Emitted when the given `file` was removed.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.fileRemoved.connect { file in
    ///    print ("caught signal")
    /// }
    /// ```
    public var fileRemoved: SignalWithArguments<String> { SignalWithArguments<String> (target: self, signalName: "file_removed") }
    
    /// Emitted when the given `folder` was removed.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.folderRemoved.connect { folder in
    ///    print ("caught signal")
    /// }
    /// ```
    public var folderRemoved: SignalWithArguments<String> { SignalWithArguments<String> (target: self, signalName: "folder_removed") }
    
    /// Emitted when a file is moved from `oldFile` path to `newFile` path.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.filesMoved.connect { oldFile, newFile in
    ///    print ("caught signal")
    /// }
    /// ```
    public var filesMoved: SignalWithArguments<String, String> { SignalWithArguments<String, String> (target: self, signalName: "files_moved") }
    
    /// Emitted when a folder is moved from `oldFolder` path to `newFolder` path.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.folderMoved.connect { oldFolder, newFolder in
    ///    print ("caught signal")
    /// }
    /// ```
    public var folderMoved: SignalWithArguments<String, String> { SignalWithArguments<String, String> (target: self, signalName: "folder_moved") }
    
    /// Emitted when folders change color.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.folderColorChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var folderColorChanged: SimpleSignal { SimpleSignal (target: self, signalName: "folder_color_changed") }
    
    /// Emitted when the user switches file display mode or split mode.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.displayModeChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var displayModeChanged: SimpleSignal { SimpleSignal (target: self, signalName: "display_mode_changed") }
    
}

