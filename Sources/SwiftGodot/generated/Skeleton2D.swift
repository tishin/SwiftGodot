// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
import Foundation
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// The parent of a hierarchy of ``Bone2D``s, used to create a 2D skeletal animation.
/// 
/// ``Skeleton2D`` parents a hierarchy of ``Bone2D`` nodes. It holds a reference to each ``Bone2D``'s rest pose and acts as a single point of access to its bones.
/// 
/// To set up different types of inverse kinematics for the given Skeleton2D, a ``SkeletonModificationStack2D`` should be created. The inverse kinematics be applied by increasing ``SkeletonModificationStack2D/modificationCount`` and creating the desired number of modifications.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``boneSetupChanged``
open class Skeleton2D: Node2D {
    override open class var godotClassName: StringName { "Skeleton2D" }
    /* Methods */
    fileprivate static var method_get_bone_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_bone_count")
        return withUnsafePointer(to: &Skeleton2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of ``Bone2D`` nodes in the node hierarchy parented by Skeleton2D.
    public final func getBoneCount() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(Skeleton2D.method_get_bone_count, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_bone: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_bone")
        return withUnsafePointer(to: &Skeleton2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2556267111)!
            }
            
        }
        
    }()
    
    /// Returns a ``Bone2D`` from the node hierarchy parented by Skeleton2D. The object to return is identified by the parameter `idx`. Bones are indexed by descending the node hierarchy from top to bottom, adding the children of each branch before moving to the next sibling.
    public final func getBone(idx: Int32) -> Bone2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: idx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton2D.method_get_bone, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_skeleton: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_skeleton")
        return withUnsafePointer(to: &Skeleton2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2944877500)!
            }
            
        }
        
    }()
    
    /// Returns the ``RID`` of a Skeleton2D instance.
    public final func getSkeleton() -> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall(Skeleton2D.method_get_skeleton, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_modification_stack: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_modification_stack")
        return withUnsafePointer(to: &Skeleton2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3907307132)!
            }
            
        }
        
    }()
    
    /// Sets the ``SkeletonModificationStack2D`` attached to this skeleton.
    public final func setModificationStack(_ modificationStack: SkeletonModificationStack2D?) {
        withUnsafePointer(to: modificationStack?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton2D.method_set_modification_stack, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_modification_stack: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_modification_stack")
        return withUnsafePointer(to: &Skeleton2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2107508396)!
            }
            
        }
        
    }()
    
    /// Returns the ``SkeletonModificationStack2D`` attached to this skeleton, if one exists.
    public final func getModificationStack() -> SkeletonModificationStack2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Skeleton2D.method_get_modification_stack, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_execute_modifications: GDExtensionMethodBindPtr = {
        let methodName = StringName("execute_modifications")
        return withUnsafePointer(to: &Skeleton2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1005356550)!
            }
            
        }
        
    }()
    
    /// Executes all the modifications on the ``SkeletonModificationStack2D``, if the Skeleton2D has one assigned.
    public final func executeModifications(delta: Double, executionMode: Int32) {
        withUnsafePointer(to: delta) { pArg0 in
            withUnsafePointer(to: executionMode) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Skeleton2D.method_execute_modifications, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_bone_local_pose_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_bone_local_pose_override")
        return withUnsafePointer(to: &Skeleton2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 555457532)!
            }
            
        }
        
    }()
    
    /// Sets the local pose transform, `overridePose`, for the bone at `boneIdx`.
    /// 
    /// `strength` is the interpolation strength that will be used when applying the pose, and `persistent` determines if the applied pose will remain.
    /// 
    /// > Note: The pose transform needs to be a local transform relative to the ``Bone2D`` node at `boneIdx`!
    /// 
    public final func setBoneLocalPoseOverride(boneIdx: Int32, overridePose: Transform2D, strength: Double, persistent: Bool) {
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: overridePose) { pArg1 in
                withUnsafePointer(to: strength) { pArg2 in
                    withUnsafePointer(to: persistent) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(Skeleton2D.method_set_bone_local_pose_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_bone_local_pose_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_bone_local_pose_override")
        return withUnsafePointer(to: &Skeleton2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2995540667)!
            }
            
        }
        
    }()
    
    /// Returns the local pose override transform for `boneIdx`.
    public final func getBoneLocalPoseOverride(boneIdx: Int32) -> Transform2D {
        var _result: Transform2D = Transform2D ()
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton2D.method_get_bone_local_pose_override, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    // Signals 
    /// Emitted when the ``Bone2D`` setup attached to this skeletons changes. This is primarily used internally within the skeleton.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.boneSetupChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var boneSetupChanged: SimpleSignal { SimpleSignal (target: self, signalName: "bone_setup_changed") }
    
}

