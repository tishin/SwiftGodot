// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
import Foundation
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A node containing a bone hierarchy, used to create a 3D skeletal animation.
/// 
/// ``Skeleton3D`` provides an interface for managing a hierarchy of bones, including pose, rest and animation (see ``Animation``). It can also use ragdoll physics.
/// 
/// The overall transform of a bone with respect to the skeleton is determined by bone pose. Bone rest defines the initial transform of the bone pose.
/// 
/// Note that "global pose" below refers to the overall transform of the bone with respect to skeleton, so it is not the actual global/world transform of the bone.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``poseUpdated``
/// - ``skeletonUpdated``
/// - ``boneEnabledChanged``
/// - ``boneListChanged``
/// - ``showRestOnlyChanged``
open class Skeleton3D: Node3D {
    override open class var godotClassName: StringName { "Skeleton3D" }
    public enum ModifierCallbackModeProcess: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Set a flag to process modification during physics frames (see ``Node/``notificationInternalPhysicsProcess````).
        case physics = 0 // MODIFIER_CALLBACK_MODE_PROCESS_PHYSICS
        /// Set a flag to process modification during process frames (see ``Node/``notificationInternalProcess````).
        case idle = 1 // MODIFIER_CALLBACK_MODE_PROCESS_IDLE
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .physics: return ".physics"
                case .idle: return ".idle"
            }
            
        }
        
    }
    
    /* Constants */
    /// Notification received when this skeleton's pose needs to be updated. In that case, this is called only once per frame in a deferred process.
    public static let notificationUpdateSkeleton = 50
    
    /* Properties */
    
    /// Multiplies the 3D position track animation.
    /// 
    /// > Note: Unless this value is `1.0`, the key value in animation will not match the actual position value.
    /// 
    final public var motionScale: Double {
        get {
            return get_motion_scale ()
        }
        
        set {
            set_motion_scale (newValue)
        }
        
    }
    
    /// If `true`, forces the bones in their default rest pose, regardless of their values. In the editor, this also prevents the bones from being edited.
    final public var showRestOnly: Bool {
        get {
            return is_show_rest_only ()
        }
        
        set {
            set_show_rest_only (newValue)
        }
        
    }
    
    /// Sets the processing timing for the Modifier.
    final public var modifierCallbackModeProcess: Skeleton3D.ModifierCallbackModeProcess {
        get {
            return get_modifier_callback_mode_process ()
        }
        
        set {
            set_modifier_callback_mode_process (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_add_bone: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_bone")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1597066294)!
            }
            
        }
        
    }()
    
    /// Adds a new bone with the given name. Returns the new bone's index, or `-1` if this method fails.
    /// 
    /// > Note: Bone names should be unique, non empty, and cannot include the `:` and `/` characters.
    /// 
    public final func addBone(name: String) -> Int32 {
        var _result: Int32 = 0
        let name = GString(name)
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_add_bone, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_find_bone: GDExtensionMethodBindPtr = {
        let methodName = StringName("find_bone")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1321353865)!
            }
            
        }
        
    }()
    
    /// Returns the bone index that matches `name` as its name. Returns `-1` if no bone with this name exists.
    public final func findBone(name: String) -> Int32 {
        var _result: Int32 = 0
        let name = GString(name)
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_find_bone, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_bone_name: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_bone_name")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns the name of the bone at index `boneIdx`.
    public final func getBoneName(boneIdx: Int32) -> String {
        let _result = GString ()
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_get_bone_name, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_set_bone_name: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_bone_name")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 501894301)!
            }
            
        }
        
    }()
    
    /// Sets the bone name, `name`, for the bone at `boneIdx`.
    public final func setBoneName(boneIdx: Int32, name: String) {
        withUnsafePointer(to: boneIdx) { pArg0 in
            let name = GString(name)
            withUnsafePointer(to: name.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Skeleton3D.method_set_bone_name, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_concatenated_bone_names: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_concatenated_bone_names")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2002593661)!
            }
            
        }
        
    }()
    
    /// Returns all bone names concatenated with commas (`,`) as a single ``StringName``.
    /// 
    /// It is useful to set it as a hint for the enum property.
    /// 
    public final func getConcatenatedBoneNames() -> StringName {
        let _result: StringName = StringName ()
        gi.object_method_bind_ptrcall(Skeleton3D.method_get_concatenated_bone_names, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_get_bone_parent: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_bone_parent")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the bone index which is the parent of the bone at `boneIdx`. If -1, then bone has no parent.
    /// 
    /// > Note: The parent bone returned will always be less than `boneIdx`.
    /// 
    public final func getBoneParent(boneIdx: Int32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_get_bone_parent, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_bone_parent: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_bone_parent")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Sets the bone index `parentIdx` as the parent of the bone at `boneIdx`. If -1, then bone has no parent.
    /// 
    /// > Note: `parentIdx` must be less than `boneIdx`.
    /// 
    public final func setBoneParent(boneIdx: Int32, parentIdx: Int32) {
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: parentIdx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Skeleton3D.method_set_bone_parent, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_bone_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_bone_count")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of bones in the skeleton.
    public final func getBoneCount() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(Skeleton3D.method_get_bone_count, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_version: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_version")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of times the bone hierarchy has changed within this skeleton, including renames.
    /// 
    /// The Skeleton version is not serialized: only use within a single instance of Skeleton3D.
    /// 
    /// Use for invalidating caches in IK solvers and other nodes which process bones.
    /// 
    public final func getVersion() -> UInt {
        var _result: UInt = 0
        gi.object_method_bind_ptrcall(Skeleton3D.method_get_version, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_unparent_bone_and_rest: GDExtensionMethodBindPtr = {
        let methodName = StringName("unparent_bone_and_rest")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Unparents the bone at `boneIdx` and sets its rest position to that of its parent prior to being reset.
    public final func unparentBoneAndRest(boneIdx: Int32) {
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_unparent_bone_and_rest, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_bone_children: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_bone_children")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1706082319)!
            }
            
        }
        
    }()
    
    /// Returns an array containing the bone indexes of all the child node of the passed in bone, `boneIdx`.
    public final func getBoneChildren(boneIdx: Int32) -> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_get_bone_children, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_parentless_bones: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_parentless_bones")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1930428628)!
            }
            
        }
        
    }()
    
    /// Returns an array with all of the bones that are parentless. Another way to look at this is that it returns the indexes of all the bones that are not dependent or modified by other bones in the Skeleton.
    public final func getParentlessBones() -> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        gi.object_method_bind_ptrcall(Skeleton3D.method_get_parentless_bones, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_get_bone_rest: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_bone_rest")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1965739696)!
            }
            
        }
        
    }()
    
    /// Returns the rest transform for a bone `boneIdx`.
    public final func getBoneRest(boneIdx: Int32) -> Transform3D {
        var _result: Transform3D = Transform3D ()
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_get_bone_rest, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_bone_rest: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_bone_rest")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3616898986)!
            }
            
        }
        
    }()
    
    /// Sets the rest transform for bone `boneIdx`.
    public final func setBoneRest(boneIdx: Int32, rest: Transform3D) {
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: rest) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Skeleton3D.method_set_bone_rest, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_bone_global_rest: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_bone_global_rest")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1965739696)!
            }
            
        }
        
    }()
    
    /// Returns the global rest transform for `boneIdx`.
    public final func getBoneGlobalRest(boneIdx: Int32) -> Transform3D {
        var _result: Transform3D = Transform3D ()
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_get_bone_global_rest, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_create_skin_from_rest_transforms: GDExtensionMethodBindPtr = {
        let methodName = StringName("create_skin_from_rest_transforms")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1032037385)!
            }
            
        }
        
    }()
    
    /// 
    public final func createSkinFromRestTransforms() -> Skin? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Skeleton3D.method_create_skin_from_rest_transforms, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_register_skin: GDExtensionMethodBindPtr = {
        let methodName = StringName("register_skin")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3405789568)!
            }
            
        }
        
    }()
    
    /// Binds the given Skin to the Skeleton.
    public final func registerSkin(_ skin: Skin?) -> SkinReference? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: skin?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_register_skin, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_localize_rests: GDExtensionMethodBindPtr = {
        let methodName = StringName("localize_rests")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Returns all bones in the skeleton to their rest poses.
    public final func localizeRests() {
        gi.object_method_bind_ptrcall(Skeleton3D.method_localize_rests, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_clear_bones: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear_bones")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clear all the bones in this skeleton.
    public final func clearBones() {
        gi.object_method_bind_ptrcall(Skeleton3D.method_clear_bones, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_get_bone_pose: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_bone_pose")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1965739696)!
            }
            
        }
        
    }()
    
    /// Returns the pose transform of the specified bone.
    /// 
    /// > Note: This is the pose you set to the skeleton in the process, the final pose can get overridden by modifiers in the deferred process, if you want to access the final pose, use [signal SkeletonModifier3D.modification_processed].
    /// 
    public final func getBonePose(boneIdx: Int32) -> Transform3D {
        var _result: Transform3D = Transform3D ()
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_get_bone_pose, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_bone_pose: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_bone_pose")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3616898986)!
            }
            
        }
        
    }()
    
    /// Sets the pose transform, `pose`, for the bone at `boneIdx`.
    public final func setBonePose(boneIdx: Int32, pose: Transform3D) {
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: pose) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Skeleton3D.method_set_bone_pose, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_bone_pose_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_bone_pose_position")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1530502735)!
            }
            
        }
        
    }()
    
    /// Sets the pose position of the bone at `boneIdx` to `position`. `position` is a ``Vector3`` describing a position local to the ``Skeleton3D`` node.
    public final func setBonePosePosition(boneIdx: Int32, position: Vector3) {
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: position) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Skeleton3D.method_set_bone_pose_position, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_bone_pose_rotation: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_bone_pose_rotation")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2823819782)!
            }
            
        }
        
    }()
    
    /// Sets the pose rotation of the bone at `boneIdx` to `rotation`. `rotation` is a ``Quaternion`` describing a rotation in the bone's local coordinate space with respect to the rotation of any parent bones.
    public final func setBonePoseRotation(boneIdx: Int32, rotation: Quaternion) {
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: rotation) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Skeleton3D.method_set_bone_pose_rotation, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_bone_pose_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_bone_pose_scale")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1530502735)!
            }
            
        }
        
    }()
    
    /// Sets the pose scale of the bone at `boneIdx` to `scale`.
    public final func setBonePoseScale(boneIdx: Int32, scale: Vector3) {
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: scale) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Skeleton3D.method_set_bone_pose_scale, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_bone_pose_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_bone_pose_position")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 711720468)!
            }
            
        }
        
    }()
    
    /// Returns the pose position of the bone at `boneIdx`. The returned ``Vector3`` is in the local coordinate space of the ``Skeleton3D`` node.
    public final func getBonePosePosition(boneIdx: Int32) -> Vector3 {
        var _result: Vector3 = Vector3 ()
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_get_bone_pose_position, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_bone_pose_rotation: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_bone_pose_rotation")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 476865136)!
            }
            
        }
        
    }()
    
    /// Returns the pose rotation of the bone at `boneIdx`. The returned ``Quaternion`` is local to the bone with respect to the rotation of any parent bones.
    public final func getBonePoseRotation(boneIdx: Int32) -> Quaternion {
        var _result: Quaternion = Quaternion ()
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_get_bone_pose_rotation, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_bone_pose_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_bone_pose_scale")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 711720468)!
            }
            
        }
        
    }()
    
    /// Returns the pose scale of the bone at `boneIdx`.
    public final func getBonePoseScale(boneIdx: Int32) -> Vector3 {
        var _result: Vector3 = Vector3 ()
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_get_bone_pose_scale, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_reset_bone_pose: GDExtensionMethodBindPtr = {
        let methodName = StringName("reset_bone_pose")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Sets the bone pose to rest for `boneIdx`.
    public final func resetBonePose(boneIdx: Int32) {
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_reset_bone_pose, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_reset_bone_poses: GDExtensionMethodBindPtr = {
        let methodName = StringName("reset_bone_poses")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Sets all bone poses to rests.
    public final func resetBonePoses() {
        gi.object_method_bind_ptrcall(Skeleton3D.method_reset_bone_poses, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_is_bone_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_bone_enabled")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns whether the bone pose for the bone at `boneIdx` is enabled.
    public final func isBoneEnabled(boneIdx: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_is_bone_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_bone_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_bone_enabled")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 972357352)!
            }
            
        }
        
    }()
    
    /// Disables the pose for the bone at `boneIdx` if `false`, enables the bone pose if `true`.
    public final func setBoneEnabled(boneIdx: Int32, enabled: Bool = true) {
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: enabled) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Skeleton3D.method_set_bone_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_bone_global_pose: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_bone_global_pose")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1965739696)!
            }
            
        }
        
    }()
    
    /// Returns the overall transform of the specified bone, with respect to the skeleton. Being relative to the skeleton frame, this is not the actual "global" transform of the bone.
    /// 
    /// > Note: This is the global pose you set to the skeleton in the process, the final global pose can get overridden by modifiers in the deferred process, if you want to access the final global pose, use [signal SkeletonModifier3D.modification_processed].
    /// 
    public final func getBoneGlobalPose(boneIdx: Int32) -> Transform3D {
        var _result: Transform3D = Transform3D ()
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_get_bone_global_pose, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_bone_global_pose: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_bone_global_pose")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3616898986)!
            }
            
        }
        
    }()
    
    /// Sets the global pose transform, `pose`, for the bone at `boneIdx`.
    /// 
    /// > Note: If other bone poses have been changed, this method executes a dirty poses recalculation and will cause performance to deteriorate. If you know that multiple global poses will be applied, consider using ``setBonePose(boneIdx:pose:)`` with precalculation.
    /// 
    public final func setBoneGlobalPose(boneIdx: Int32, pose: Transform3D) {
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: pose) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Skeleton3D.method_set_bone_global_pose, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_force_update_all_bone_transforms: GDExtensionMethodBindPtr = {
        let methodName = StringName("force_update_all_bone_transforms")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Force updates the bone transforms/poses for all bones in the skeleton.
    public final func forceUpdateAllBoneTransforms() {
        gi.object_method_bind_ptrcall(Skeleton3D.method_force_update_all_bone_transforms, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_force_update_bone_child_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName("force_update_bone_child_transform")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Force updates the bone transform for the bone at `boneIdx` and all of its children.
    public final func forceUpdateBoneChildTransform(boneIdx: Int32) {
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_force_update_bone_child_transform, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_motion_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_motion_scale")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_motion_scale(_ motionScale: Double) {
        withUnsafePointer(to: motionScale) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_set_motion_scale, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_motion_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_motion_scale")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_motion_scale() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(Skeleton3D.method_get_motion_scale, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_show_rest_only: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_show_rest_only")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_show_rest_only(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_set_show_rest_only, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_show_rest_only: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_show_rest_only")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_show_rest_only() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Skeleton3D.method_is_show_rest_only, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_modifier_callback_mode_process: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_modifier_callback_mode_process")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3916362634)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_modifier_callback_mode_process(_ mode: Skeleton3D.ModifierCallbackModeProcess) {
        withUnsafePointer(to: mode.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_set_modifier_callback_mode_process, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_modifier_callback_mode_process: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_modifier_callback_mode_process")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 997182536)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_modifier_callback_mode_process() -> Skeleton3D.ModifierCallbackModeProcess {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Skeleton3D.method_get_modifier_callback_mode_process, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Skeleton3D.ModifierCallbackModeProcess (rawValue: _result)!
    }
    
    fileprivate static var method_clear_bones_global_pose_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear_bones_global_pose_override")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Removes the global pose override on all bones in the skeleton.
    public final func clearBonesGlobalPoseOverride() {
        gi.object_method_bind_ptrcall(Skeleton3D.method_clear_bones_global_pose_override, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_set_bone_global_pose_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_bone_global_pose_override")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3483398371)!
            }
            
        }
        
    }()
    
    /// Sets the global pose transform, `pose`, for the bone at `boneIdx`.
    /// 
    /// `amount` is the interpolation strength that will be used when applying the pose, and `persistent` determines if the applied pose will remain.
    /// 
    /// > Note: The pose transform needs to be a global pose! To convert a world transform from a ``Node3D`` to a global bone pose, multiply the ``Transform3D/affineInverse()`` of the node's ``Node3D/globalTransform`` by the desired world transform.
    /// 
    public final func setBoneGlobalPoseOverride(boneIdx: Int32, pose: Transform3D, amount: Double, persistent: Bool = false) {
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: pose) { pArg1 in
                withUnsafePointer(to: amount) { pArg2 in
                    withUnsafePointer(to: persistent) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(Skeleton3D.method_set_bone_global_pose_override, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_bone_global_pose_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_bone_global_pose_override")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1965739696)!
            }
            
        }
        
    }()
    
    /// Returns the global pose override transform for `boneIdx`.
    public final func getBoneGlobalPoseOverride(boneIdx: Int32) -> Transform3D {
        var _result: Transform3D = Transform3D ()
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_get_bone_global_pose_override, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_bone_global_pose_no_override: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_bone_global_pose_no_override")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1965739696)!
            }
            
        }
        
    }()
    
    /// Returns the overall transform of the specified bone, with respect to the skeleton, but without any global pose overrides. Being relative to the skeleton frame, this is not the actual "global" transform of the bone.
    public final func getBoneGlobalPoseNoOverride(boneIdx: Int32) -> Transform3D {
        var _result: Transform3D = Transform3D ()
        withUnsafePointer(to: boneIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_get_bone_global_pose_no_override, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_animate_physical_bones: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_animate_physical_bones")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// This method exists for compatibility with old structures in which the ``Skeleton3D`` does not have a ``PhysicalBoneSimulator3D`` as a child, but directly has ``PhysicalBone3D``s as children.
    /// 
    /// In case you need to raycast to it without running ``physicalBonesStartSimulation(bones:)``, call this method with `enabled == true`.
    /// 
    public final func setAnimatePhysicalBones(enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_set_animate_physical_bones, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_animate_physical_bones: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_animate_physical_bones")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// 
    public final func getAnimatePhysicalBones() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Skeleton3D.method_get_animate_physical_bones, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_physical_bones_stop_simulation: GDExtensionMethodBindPtr = {
        let methodName = StringName("physical_bones_stop_simulation")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Tells the ``PhysicalBone3D`` nodes in the Skeleton to stop simulating.
    public final func physicalBonesStopSimulation() {
        gi.object_method_bind_ptrcall(Skeleton3D.method_physical_bones_stop_simulation, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_physical_bones_start_simulation: GDExtensionMethodBindPtr = {
        let methodName = StringName("physical_bones_start_simulation")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2787316981)!
            }
            
        }
        
    }()
    
    /// Tells the ``PhysicalBone3D`` nodes in the Skeleton to start simulating and reacting to the physics world.
    /// 
    /// Optionally, a list of bone names can be passed-in, allowing only the passed-in bones to be simulated.
    /// 
    public final func physicalBonesStartSimulation(bones: VariantCollection<StringName> = VariantCollection<StringName> ()) {
        withUnsafePointer(to: bones.array.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_physical_bones_start_simulation, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_physical_bones_add_collision_exception: GDExtensionMethodBindPtr = {
        let methodName = StringName("physical_bones_add_collision_exception")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2722037293)!
            }
            
        }
        
    }()
    
    /// Adds a collision exception to the physical bone.
    /// 
    /// Works just like the ``RigidBody3D`` node.
    /// 
    public final func physicalBonesAddCollisionException(_ exception: RID) {
        withUnsafePointer(to: exception.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_physical_bones_add_collision_exception, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_physical_bones_remove_collision_exception: GDExtensionMethodBindPtr = {
        let methodName = StringName("physical_bones_remove_collision_exception")
        return withUnsafePointer(to: &Skeleton3D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2722037293)!
            }
            
        }
        
    }()
    
    /// Removes a collision exception to the physical bone.
    /// 
    /// Works just like the ``RigidBody3D`` node.
    /// 
    public final func physicalBonesRemoveCollisionException(_ exception: RID) {
        withUnsafePointer(to: exception.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Skeleton3D.method_physical_bones_remove_collision_exception, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    // Signals 
    /// Emitted when the pose is updated.
    /// 
    /// > Note: During the update process, this signal is not fired, so modification by ``SkeletonModifier3D`` is not detected.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.poseUpdated.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var poseUpdated: SimpleSignal { SimpleSignal (target: self, signalName: "pose_updated") }
    
    /// Emitted when the final pose has been calculated will be applied to the skin in the update process.
    /// 
    /// This means that all ``SkeletonModifier3D`` processing is complete. In order to detect the completion of the processing of each ``SkeletonModifier3D``, use [signal SkeletonModifier3D.modification_processed].
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.skeletonUpdated.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var skeletonUpdated: SimpleSignal { SimpleSignal (target: self, signalName: "skeleton_updated") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ boneIdx: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the bone at `boneIdx` is toggled with ``setBoneEnabled(boneIdx:enabled:)``. Use ``isBoneEnabled(boneIdx:)`` to check the new value.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.boneEnabledChanged.connect { boneIdx in
    ///    print ("caught signal")
    /// }
    /// ```
    public var boneEnabledChanged: Signal1 { Signal1 (target: self, signalName: "bone_enabled_changed") }
    
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.boneListChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var boneListChanged: SimpleSignal { SimpleSignal (target: self, signalName: "bone_list_changed") }
    
    /// Emitted when the value of ``showRestOnly`` changes.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.showRestOnlyChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var showRestOnlyChanged: SimpleSignal { SimpleSignal (target: self, signalName: "show_rest_only_changed") }
    
}

