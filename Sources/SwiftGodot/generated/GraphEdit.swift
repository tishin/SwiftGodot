// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
import Foundation
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// An editor for graph-like structures, using ``GraphNode``s.
/// 
/// ``GraphEdit`` provides tools for creation, manipulation, and display of various graphs. Its main purpose in the engine is to power the visual programming systems, such as visual shaders, but it is also available for use in user projects.
/// 
/// ``GraphEdit`` by itself is only an empty container, representing an infinite grid where ``GraphNode``s can be placed. Each ``GraphNode`` represents a node in the graph, a single unit of data in the connected scheme. ``GraphEdit``, in turn, helps to control various interactions with nodes and between nodes. When the user attempts to connect, disconnect, or delete a ``GraphNode``, a signal is emitted in the ``GraphEdit``, but no action is taken by default. It is the responsibility of the programmer utilizing this control to implement the necessary logic to determine how each request should be handled.
/// 
/// **Performance:** It is greatly advised to enable low-processor usage mode (see ``OS/lowProcessorUsageMode``) when using GraphEdits.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``connectionRequest``
/// - ``disconnectionRequest``
/// - ``connectionToEmpty``
/// - ``connectionFromEmpty``
/// - ``connectionDragStarted``
/// - ``connectionDragEnded``
/// - ``copyNodesRequest``
/// - ``pasteNodesRequest``
/// - ``duplicateNodesRequest``
/// - ``deleteNodesRequest``
/// - ``nodeSelected``
/// - ``nodeDeselected``
/// - ``frameRectChanged``
/// - ``popupRequest``
/// - ``beginNodeMove``
/// - ``endNodeMove``
/// - ``graphElementsLinkedToFrameRequest``
/// - ``scrollOffsetChanged``
open class GraphEdit: Control {
    override open class var godotClassName: StringName { "GraphEdit" }
    public enum PanningScheme: Int64, CaseIterable, CustomDebugStringConvertible {
        /// [kbd]Mouse Wheel[/kbd] will zoom, [kbd]Ctrl + Mouse Wheel[/kbd] will move the view.
        case zooms = 0 // SCROLL_ZOOMS
        /// [kbd]Mouse Wheel[/kbd] will move the view, [kbd]Ctrl + Mouse Wheel[/kbd] will zoom.
        case pans = 1 // SCROLL_PANS
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .zooms: return ".zooms"
                case .pans: return ".pans"
            }
            
        }
        
    }
    
    public enum GridPattern: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Draw the grid using solid lines.
        case lines = 0 // GRID_PATTERN_LINES
        /// Draw the grid using dots.
        case dots = 1 // GRID_PATTERN_DOTS
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .lines: return ".lines"
                case .dots: return ".dots"
            }
            
        }
        
    }
    
    
    /* Properties */
    
    /// The scroll offset.
    final public var scrollOffset: Vector2 {
        get {
            return get_scroll_offset ()
        }
        
        set {
            set_scroll_offset (newValue)
        }
        
    }
    
    /// If `true`, the grid is visible.
    final public var showGrid: Bool {
        get {
            return is_showing_grid ()
        }
        
        set {
            set_show_grid (newValue)
        }
        
    }
    
    /// The pattern used for drawing the grid.
    final public var gridPattern: GraphEdit.GridPattern {
        get {
            return get_grid_pattern ()
        }
        
        set {
            set_grid_pattern (newValue)
        }
        
    }
    
    /// If `true`, enables snapping.
    final public var snappingEnabled: Bool {
        get {
            return is_snapping_enabled ()
        }
        
        set {
            set_snapping_enabled (newValue)
        }
        
    }
    
    /// The snapping distance in pixels, also determines the grid line distance.
    final public var snappingDistance: Int32 {
        get {
            return get_snapping_distance ()
        }
        
        set {
            set_snapping_distance (newValue)
        }
        
    }
    
    /// Defines the control scheme for panning with mouse wheel.
    final public var panningScheme: GraphEdit.PanningScheme {
        get {
            return get_panning_scheme ()
        }
        
        set {
            set_panning_scheme (newValue)
        }
        
    }
    
    /// If `true`, enables disconnection of existing connections in the GraphEdit by dragging the right end.
    final public var rightDisconnects: Bool {
        get {
            return is_right_disconnects_enabled ()
        }
        
        set {
            set_right_disconnects (newValue)
        }
        
    }
    
    /// The curvature of the lines between the nodes. 0 results in straight lines.
    final public var connectionLinesCurvature: Double {
        get {
            return get_connection_lines_curvature ()
        }
        
        set {
            set_connection_lines_curvature (newValue)
        }
        
    }
    
    /// The thickness of the lines between the nodes.
    final public var connectionLinesThickness: Double {
        get {
            return get_connection_lines_thickness ()
        }
        
        set {
            set_connection_lines_thickness (newValue)
        }
        
    }
    
    /// If `true`, the lines between nodes will use antialiasing.
    final public var connectionLinesAntialiased: Bool {
        get {
            return is_connection_lines_antialiased ()
        }
        
        set {
            set_connection_lines_antialiased (newValue)
        }
        
    }
    
    /// The current zoom value.
    final public var zoom: Double {
        get {
            return get_zoom ()
        }
        
        set {
            set_zoom (newValue)
        }
        
    }
    
    /// The lower zoom limit.
    final public var zoomMin: Double {
        get {
            return get_zoom_min ()
        }
        
        set {
            set_zoom_min (newValue)
        }
        
    }
    
    /// The upper zoom limit.
    final public var zoomMax: Double {
        get {
            return get_zoom_max ()
        }
        
        set {
            set_zoom_max (newValue)
        }
        
    }
    
    /// The step of each zoom level.
    final public var zoomStep: Double {
        get {
            return get_zoom_step ()
        }
        
        set {
            set_zoom_step (newValue)
        }
        
    }
    
    /// If `true`, the minimap is visible.
    final public var minimapEnabled: Bool {
        get {
            return is_minimap_enabled ()
        }
        
        set {
            set_minimap_enabled (newValue)
        }
        
    }
    
    /// The size of the minimap rectangle. The map itself is based on the size of the grid area and is scaled to fit this rectangle.
    final public var minimapSize: Vector2 {
        get {
            return get_minimap_size ()
        }
        
        set {
            set_minimap_size (newValue)
        }
        
    }
    
    /// The opacity of the minimap rectangle.
    final public var minimapOpacity: Double {
        get {
            return get_minimap_opacity ()
        }
        
        set {
            set_minimap_opacity (newValue)
        }
        
    }
    
    /// If `true`, the menu toolbar is visible.
    final public var showMenu: Bool {
        get {
            return is_showing_menu ()
        }
        
        set {
            set_show_menu (newValue)
        }
        
    }
    
    /// If `true`, the label with the current zoom level is visible. The zoom level is displayed in percents.
    final public var showZoomLabel: Bool {
        get {
            return is_showing_zoom_label ()
        }
        
        set {
            set_show_zoom_label (newValue)
        }
        
    }
    
    /// If `true`, buttons that allow to change and reset the zoom level are visible.
    final public var showZoomButtons: Bool {
        get {
            return is_showing_zoom_buttons ()
        }
        
        set {
            set_show_zoom_buttons (newValue)
        }
        
    }
    
    /// If `true`, buttons that allow to configure grid and snapping options are visible.
    final public var showGridButtons: Bool {
        get {
            return is_showing_grid_buttons ()
        }
        
        set {
            set_show_grid_buttons (newValue)
        }
        
    }
    
    /// If `true`, the button to toggle the minimap is visible.
    final public var showMinimapButton: Bool {
        get {
            return is_showing_minimap_button ()
        }
        
        set {
            set_show_minimap_button (newValue)
        }
        
    }
    
    /// If `true`, the button to automatically arrange graph nodes is visible.
    final public var showArrangeButton: Bool {
        get {
            return is_showing_arrange_button ()
        }
        
        set {
            set_show_arrange_button (newValue)
        }
        
    }
    
    /* Methods */
    /// Returns whether the `mousePosition` is in the input hot zone.
    /// 
    /// By default, a hot zone is a ``Rect2`` positioned such that its center is at `inNode`.``GraphNode/getInputPortPosition(portIdx:)``(`inPort`) (For output's case, call ``GraphNode/getOutputPortPosition(portIdx:)`` instead). The hot zone's width is twice the Theme Property `port_grab_distance_horizontal`, and its height is twice the `port_grab_distance_vertical`.
    /// 
    /// Below is a sample code to help get started:
    /// 
    @_documentation(visibility: public)
    open func _isInInputHotzone(inNode: Object?, inPort: Int32, mousePosition: Vector2) -> Bool {
        return false
    }
    
    /// Returns whether the `mousePosition` is in the output hot zone. For more information on hot zones, see ``_isInInputHotzone(inNode:inPort:mousePosition:)``.
    /// 
    /// Below is a sample code to help get started:
    /// 
    @_documentation(visibility: public)
    open func _isInOutputHotzone(inNode: Object?, inPort: Int32, mousePosition: Vector2) -> Bool {
        return false
    }
    
    /// Virtual method which can be overridden to customize how connections are drawn.
    @_documentation(visibility: public)
    open func _getConnectionLine(fromPosition: Vector2, toPosition: Vector2) -> PackedVector2Array {
        return PackedVector2Array ()
    }
    
    /// This virtual method can be used to insert additional error detection while the user is dragging a connection over a valid port.
    /// 
    /// Return `true` if the connection is indeed valid or return `false` if the connection is impossible. If the connection is impossible, no snapping to the port and thus no connection request to that port will happen.
    /// 
    /// In this example a connection to same node is suppressed:
    /// 
    @_documentation(visibility: public)
    open func _isNodeHoverValid(fromNode: StringName, fromPort: Int32, toNode: StringName, toPort: Int32) -> Bool {
        return false
    }
    
    fileprivate static var method_connect_node: GDExtensionMethodBindPtr = {
        let methodName = StringName("connect_node")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 195065850)!
            }
            
        }
        
    }()
    
    /// Create a connection between the `fromPort` of the `fromNode` ``GraphNode`` and the `toPort` of the `toNode` ``GraphNode``. If the connection already exists, no connection is created.
    public final func connectNode(fromNode: StringName, fromPort: Int32, toNode: StringName, toPort: Int32) -> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: fromNode.content) { pArg0 in
            withUnsafePointer(to: fromPort) { pArg1 in
                withUnsafePointer(to: toNode.content) { pArg2 in
                    withUnsafePointer(to: toPort) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(GraphEdit.method_connect_node, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_is_node_connected: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_node_connected")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4216241294)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the `fromPort` of the `fromNode` ``GraphNode`` is connected to the `toPort` of the `toNode` ``GraphNode``.
    public final func isNodeConnected(fromNode: StringName, fromPort: Int32, toNode: StringName, toPort: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: fromNode.content) { pArg0 in
            withUnsafePointer(to: fromPort) { pArg1 in
                withUnsafePointer(to: toNode.content) { pArg2 in
                    withUnsafePointer(to: toPort) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(GraphEdit.method_is_node_connected, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_disconnect_node: GDExtensionMethodBindPtr = {
        let methodName = StringName("disconnect_node")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1933654315)!
            }
            
        }
        
    }()
    
    /// Removes the connection between the `fromPort` of the `fromNode` ``GraphNode`` and the `toPort` of the `toNode` ``GraphNode``. If the connection does not exist, no connection is removed.
    public final func disconnectNode(fromNode: StringName, fromPort: Int32, toNode: StringName, toPort: Int32) {
        withUnsafePointer(to: fromNode.content) { pArg0 in
            withUnsafePointer(to: fromPort) { pArg1 in
                withUnsafePointer(to: toNode.content) { pArg2 in
                    withUnsafePointer(to: toPort) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(GraphEdit.method_disconnect_node, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_connection_activity: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_connection_activity")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1141899943)!
            }
            
        }
        
    }()
    
    /// Sets the coloration of the connection between `fromNode`'s `fromPort` and `toNode`'s `toPort` with the color provided in the [theme_item activity] theme property. The color is linearly interpolated between the connection color and the activity color using `amount` as weight.
    public final func setConnectionActivity(fromNode: StringName, fromPort: Int32, toNode: StringName, toPort: Int32, amount: Double) {
        withUnsafePointer(to: fromNode.content) { pArg0 in
            withUnsafePointer(to: fromPort) { pArg1 in
                withUnsafePointer(to: toNode.content) { pArg2 in
                    withUnsafePointer(to: toPort) { pArg3 in
                        withUnsafePointer(to: amount) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    gi.object_method_bind_ptrcall(GraphEdit.method_set_connection_activity, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_connection_list: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_connection_list")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    /// Returns an ``GArray`` containing the list of connections. A connection consists in a structure of the form `{ from_port: 0, from_node: "GraphNode name 0", to_port: 1, to_node: "GraphNode name 1" }`.
    public final func getConnectionList() -> VariantCollection<GDictionary> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall(GraphEdit.method_get_connection_list, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return VariantCollection<GDictionary>(content: _result)
    }
    
    fileprivate static var method_get_closest_connection_at_point: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_closest_connection_at_point")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 453879819)!
            }
            
        }
        
    }()
    
    /// Returns the closest connection to the given point in screen space. If no connection is found within `maxDistance` pixels, an empty ``GDictionary`` is returned.
    /// 
    /// A connection consists in a structure of the form `{ from_port: 0, from_node: "GraphNode name 0", to_port: 1, to_node: "GraphNode name 1" }`.
    /// 
    /// For example, getting a connection at a given mouse position can be achieved like this:
    /// 
    public final func getClosestConnectionAtPoint(_ point: Vector2, maxDistance: Double = 4.0) -> GDictionary {
        let _result: GDictionary = GDictionary ()
        withUnsafePointer(to: point) { pArg0 in
            withUnsafePointer(to: maxDistance) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(GraphEdit.method_get_closest_connection_at_point, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_connections_intersecting_with_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_connections_intersecting_with_rect")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2709748719)!
            }
            
        }
        
    }()
    
    /// Returns an ``GArray`` containing the list of connections that intersect with the given ``Rect2``. A connection consists in a structure of the form `{ from_port: 0, from_node: "GraphNode name 0", to_port: 1, to_node: "GraphNode name 1" }`.
    public final func getConnectionsIntersectingWithRect(_ rect: Rect2) -> VariantCollection<GDictionary> {
        var _result: Int64 = 0
        withUnsafePointer(to: rect) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_get_connections_intersecting_with_rect, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return VariantCollection<GDictionary>(content: _result)
    }
    
    fileprivate static var method_clear_connections: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear_connections")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Removes all connections between nodes.
    public final func clearConnections() {
        gi.object_method_bind_ptrcall(GraphEdit.method_clear_connections, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_force_connection_drag_end: GDExtensionMethodBindPtr = {
        let methodName = StringName("force_connection_drag_end")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Ends the creation of the current connection. In other words, if you are dragging a connection you can use this method to abort the process and remove the line that followed your cursor.
    /// 
    /// This is best used together with [signal connection_drag_started] and [signal connection_drag_ended] to add custom behavior like node addition through shortcuts.
    /// 
    /// > Note: This method suppresses any other connection request signals apart from [signal connection_drag_ended].
    /// 
    public final func forceConnectionDragEnd() {
        gi.object_method_bind_ptrcall(GraphEdit.method_force_connection_drag_end, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_get_scroll_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_scroll_offset")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_scroll_offset() -> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall(GraphEdit.method_get_scroll_offset, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_scroll_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_scroll_offset")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 743155724)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_scroll_offset(_ offset: Vector2) {
        withUnsafePointer(to: offset) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_set_scroll_offset, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_valid_right_disconnect_type: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_valid_right_disconnect_type")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Allows to disconnect nodes when dragging from the right port of the ``GraphNode``'s slot if it has the specified type. See also ``removeValidRightDisconnectType(_:)``.
    public final func addValidRightDisconnectType(_ type: Int32) {
        withUnsafePointer(to: type) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_add_valid_right_disconnect_type, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_remove_valid_right_disconnect_type: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_valid_right_disconnect_type")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Disallows to disconnect nodes when dragging from the right port of the ``GraphNode``'s slot if it has the specified type. Use this to disable disconnection previously allowed with ``addValidRightDisconnectType(_:)``.
    public final func removeValidRightDisconnectType(_ type: Int32) {
        withUnsafePointer(to: type) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_remove_valid_right_disconnect_type, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_valid_left_disconnect_type: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_valid_left_disconnect_type")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Allows to disconnect nodes when dragging from the left port of the ``GraphNode``'s slot if it has the specified type. See also ``removeValidLeftDisconnectType(_:)``.
    public final func addValidLeftDisconnectType(_ type: Int32) {
        withUnsafePointer(to: type) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_add_valid_left_disconnect_type, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_remove_valid_left_disconnect_type: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_valid_left_disconnect_type")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Disallows to disconnect nodes when dragging from the left port of the ``GraphNode``'s slot if it has the specified type. Use this to disable disconnection previously allowed with ``addValidLeftDisconnectType(_:)``.
    public final func removeValidLeftDisconnectType(_ type: Int32) {
        withUnsafePointer(to: type) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_remove_valid_left_disconnect_type, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_valid_connection_type: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_valid_connection_type")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Allows the connection between two different port types. The port type is defined individually for the left and the right port of each slot with the ``GraphNode/setSlot(slotIndex:enableLeftPort:typeLeft:colorLeft:enableRightPort:typeRight:colorRight:customIconLeft:customIconRight:drawStylebox:)`` method.
    /// 
    /// See also ``isValidConnectionType(fromType:toType:)`` and ``removeValidConnectionType(fromType:toType:)``.
    /// 
    public final func addValidConnectionType(fromType: Int32, toType: Int32) {
        withUnsafePointer(to: fromType) { pArg0 in
            withUnsafePointer(to: toType) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(GraphEdit.method_add_valid_connection_type, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_remove_valid_connection_type: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_valid_connection_type")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Disallows the connection between two different port types previously allowed by ``addValidConnectionType(fromType:toType:)``. The port type is defined individually for the left and the right port of each slot with the ``GraphNode/setSlot(slotIndex:enableLeftPort:typeLeft:colorLeft:enableRightPort:typeRight:colorRight:customIconLeft:customIconRight:drawStylebox:)`` method.
    /// 
    /// See also ``isValidConnectionType(fromType:toType:)``.
    /// 
    public final func removeValidConnectionType(fromType: Int32, toType: Int32) {
        withUnsafePointer(to: fromType) { pArg0 in
            withUnsafePointer(to: toType) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(GraphEdit.method_remove_valid_connection_type, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_valid_connection_type: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_valid_connection_type")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2522259332)!
            }
            
        }
        
    }()
    
    /// Returns whether it's possible to make a connection between two different port types. The port type is defined individually for the left and the right port of each slot with the ``GraphNode/setSlot(slotIndex:enableLeftPort:typeLeft:colorLeft:enableRightPort:typeRight:colorRight:customIconLeft:customIconRight:drawStylebox:)`` method.
    /// 
    /// See also ``addValidConnectionType(fromType:toType:)`` and ``removeValidConnectionType(fromType:toType:)``.
    /// 
    public final func isValidConnectionType(fromType: Int32, toType: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: fromType) { pArg0 in
            withUnsafePointer(to: toType) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(GraphEdit.method_is_valid_connection_type, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_connection_line: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_connection_line")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3932192302)!
            }
            
        }
        
    }()
    
    /// Returns the points which would make up a connection between `fromNode` and `toNode`.
    public final func getConnectionLine(fromNode: Vector2, toNode: Vector2) -> PackedVector2Array {
        let _result: PackedVector2Array = PackedVector2Array ()
        withUnsafePointer(to: fromNode) { pArg0 in
            withUnsafePointer(to: toNode) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(GraphEdit.method_get_connection_line, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_attach_graph_element_to_frame: GDExtensionMethodBindPtr = {
        let methodName = StringName("attach_graph_element_to_frame")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3740211285)!
            }
            
        }
        
    }()
    
    /// Attaches the `element` ``GraphElement`` to the `frame` ``GraphFrame``.
    public final func attachGraphElementToFrame(element: StringName, frame: StringName) {
        withUnsafePointer(to: element.content) { pArg0 in
            withUnsafePointer(to: frame.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(GraphEdit.method_attach_graph_element_to_frame, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_detach_graph_element_from_frame: GDExtensionMethodBindPtr = {
        let methodName = StringName("detach_graph_element_from_frame")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Detaches the `element` ``GraphElement`` from the ``GraphFrame`` it is currently attached to.
    public final func detachGraphElementFromFrame(element: StringName) {
        withUnsafePointer(to: element.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_detach_graph_element_from_frame, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_element_frame: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_element_frame")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 988084372)!
            }
            
        }
        
    }()
    
    /// Returns the ``GraphFrame`` that contains the ``GraphElement`` with the given name.
    public final func getElementFrame(element: StringName) -> GraphFrame? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: element.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_get_element_frame, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_attached_nodes_of_frame: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_attached_nodes_of_frame")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 689397652)!
            }
            
        }
        
    }()
    
    /// Returns an array of node names that are attached to the ``GraphFrame`` with the given name.
    public final func getAttachedNodesOfFrame(_ frame: StringName) -> VariantCollection<StringName> {
        var _result: Int64 = 0
        withUnsafePointer(to: frame.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_get_attached_nodes_of_frame, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return VariantCollection<StringName>(content: _result)
    }
    
    fileprivate static var method_set_panning_scheme: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_panning_scheme")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 18893313)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_panning_scheme(_ scheme: GraphEdit.PanningScheme) {
        withUnsafePointer(to: scheme.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_set_panning_scheme, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_panning_scheme: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_panning_scheme")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 549924446)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_panning_scheme() -> GraphEdit.PanningScheme {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(GraphEdit.method_get_panning_scheme, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return GraphEdit.PanningScheme (rawValue: _result)!
    }
    
    fileprivate static var method_set_zoom: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_zoom")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_zoom(_ zoom: Double) {
        withUnsafePointer(to: zoom) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_set_zoom, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_zoom: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_zoom")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_zoom() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(GraphEdit.method_get_zoom, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_zoom_min: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_zoom_min")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_zoom_min(_ zoomMin: Double) {
        withUnsafePointer(to: zoomMin) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_set_zoom_min, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_zoom_min: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_zoom_min")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_zoom_min() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(GraphEdit.method_get_zoom_min, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_zoom_max: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_zoom_max")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_zoom_max(_ zoomMax: Double) {
        withUnsafePointer(to: zoomMax) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_set_zoom_max, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_zoom_max: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_zoom_max")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_zoom_max() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(GraphEdit.method_get_zoom_max, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_zoom_step: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_zoom_step")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_zoom_step(_ zoomStep: Double) {
        withUnsafePointer(to: zoomStep) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_set_zoom_step, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_zoom_step: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_zoom_step")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_zoom_step() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(GraphEdit.method_get_zoom_step, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_show_grid: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_show_grid")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_show_grid(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_set_show_grid, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_showing_grid: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_showing_grid")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_showing_grid() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(GraphEdit.method_is_showing_grid, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_grid_pattern: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_grid_pattern")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1074098205)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_grid_pattern(_ pattern: GraphEdit.GridPattern) {
        withUnsafePointer(to: pattern.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_set_grid_pattern, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_grid_pattern: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_grid_pattern")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286127528)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_grid_pattern() -> GraphEdit.GridPattern {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(GraphEdit.method_get_grid_pattern, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return GraphEdit.GridPattern (rawValue: _result)!
    }
    
    fileprivate static var method_set_snapping_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_snapping_enabled")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_snapping_enabled(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_set_snapping_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_snapping_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_snapping_enabled")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_snapping_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(GraphEdit.method_is_snapping_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_snapping_distance: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_snapping_distance")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_snapping_distance(_ pixels: Int32) {
        withUnsafePointer(to: pixels) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_set_snapping_distance, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_snapping_distance: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_snapping_distance")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_snapping_distance() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(GraphEdit.method_get_snapping_distance, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_connection_lines_curvature: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_connection_lines_curvature")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_connection_lines_curvature(_ curvature: Double) {
        withUnsafePointer(to: curvature) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_set_connection_lines_curvature, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_connection_lines_curvature: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_connection_lines_curvature")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_connection_lines_curvature() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(GraphEdit.method_get_connection_lines_curvature, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_connection_lines_thickness: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_connection_lines_thickness")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_connection_lines_thickness(_ pixels: Double) {
        withUnsafePointer(to: pixels) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_set_connection_lines_thickness, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_connection_lines_thickness: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_connection_lines_thickness")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_connection_lines_thickness() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(GraphEdit.method_get_connection_lines_thickness, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_connection_lines_antialiased: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_connection_lines_antialiased")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_connection_lines_antialiased(_ pixels: Bool) {
        withUnsafePointer(to: pixels) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_set_connection_lines_antialiased, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_connection_lines_antialiased: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_connection_lines_antialiased")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_connection_lines_antialiased() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(GraphEdit.method_is_connection_lines_antialiased, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_minimap_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_minimap_size")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 743155724)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_minimap_size(_ size: Vector2) {
        withUnsafePointer(to: size) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_set_minimap_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_minimap_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_minimap_size")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_minimap_size() -> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall(GraphEdit.method_get_minimap_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_minimap_opacity: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_minimap_opacity")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_minimap_opacity(_ opacity: Double) {
        withUnsafePointer(to: opacity) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_set_minimap_opacity, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_minimap_opacity: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_minimap_opacity")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_minimap_opacity() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(GraphEdit.method_get_minimap_opacity, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_minimap_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_minimap_enabled")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_minimap_enabled(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_set_minimap_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_minimap_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_minimap_enabled")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_minimap_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(GraphEdit.method_is_minimap_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_show_menu: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_show_menu")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_show_menu(_ hidden: Bool) {
        withUnsafePointer(to: hidden) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_set_show_menu, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_showing_menu: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_showing_menu")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_showing_menu() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(GraphEdit.method_is_showing_menu, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_show_zoom_label: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_show_zoom_label")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_show_zoom_label(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_set_show_zoom_label, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_showing_zoom_label: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_showing_zoom_label")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_showing_zoom_label() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(GraphEdit.method_is_showing_zoom_label, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_show_grid_buttons: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_show_grid_buttons")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_show_grid_buttons(_ hidden: Bool) {
        withUnsafePointer(to: hidden) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_set_show_grid_buttons, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_showing_grid_buttons: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_showing_grid_buttons")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_showing_grid_buttons() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(GraphEdit.method_is_showing_grid_buttons, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_show_zoom_buttons: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_show_zoom_buttons")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_show_zoom_buttons(_ hidden: Bool) {
        withUnsafePointer(to: hidden) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_set_show_zoom_buttons, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_showing_zoom_buttons: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_showing_zoom_buttons")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_showing_zoom_buttons() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(GraphEdit.method_is_showing_zoom_buttons, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_show_minimap_button: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_show_minimap_button")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_show_minimap_button(_ hidden: Bool) {
        withUnsafePointer(to: hidden) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_set_show_minimap_button, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_showing_minimap_button: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_showing_minimap_button")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_showing_minimap_button() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(GraphEdit.method_is_showing_minimap_button, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_show_arrange_button: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_show_arrange_button")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_show_arrange_button(_ hidden: Bool) {
        withUnsafePointer(to: hidden) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_set_show_arrange_button, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_showing_arrange_button: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_showing_arrange_button")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_showing_arrange_button() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(GraphEdit.method_is_showing_arrange_button, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_right_disconnects: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_right_disconnects")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_right_disconnects(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_set_right_disconnects, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_right_disconnects_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_right_disconnects_enabled")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_right_disconnects_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(GraphEdit.method_is_right_disconnects_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_menu_hbox: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_menu_hbox")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3590609951)!
            }
            
        }
        
    }()
    
    /// Gets the ``HBoxContainer`` that contains the zooming and grid snap controls in the top left of the graph. You can use this method to reposition the toolbar or to add your own custom controls to it.
    /// 
    /// > Warning: This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their ``CanvasItem/visible`` property.
    /// 
    public final func getMenuHbox() -> HBoxContainer? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(GraphEdit.method_get_menu_hbox, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_arrange_nodes: GDExtensionMethodBindPtr = {
        let methodName = StringName("arrange_nodes")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Rearranges selected nodes in a layout with minimum crossings between connections and uniform horizontal and vertical gap between nodes.
    public final func arrangeNodes() {
        gi.object_method_bind_ptrcall(GraphEdit.method_arrange_nodes, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_set_selected: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_selected")
        return withUnsafePointer(to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1078189570)!
            }
            
        }
        
    }()
    
    /// Sets the specified `node` as the one selected.
    public final func setSelected(node: Node?) {
        withUnsafePointer(to: node?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(GraphEdit.method_set_selected, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    override class func getVirtualDispatcher (name: StringName) -> GDExtensionClassCallVirtual? {
        guard implementedOverrides().contains(name) else { return nil }
        switch name.description {
            case "_get_connection_line":
                return _GraphEdit_proxy_get_connection_line
            case "_is_in_input_hotzone":
                return _GraphEdit_proxy_is_in_input_hotzone
            case "_is_in_output_hotzone":
                return _GraphEdit_proxy_is_in_output_hotzone
            case "_is_node_hover_valid":
                return _GraphEdit_proxy_is_node_hover_valid
            default:
                return super.getVirtualDispatcher (name: name)
        }
        
    }
    
    // Signals 
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ fromNode: StringName, _ fromPort: Int64, _ toNode: StringName, _ toPort: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0])!
                let arg_1 = Int64 (args [1])!
                let arg_2 = StringName (args [2])!
                let arg_3 = Int64 (args [3])!
                
                callback (arg_0, arg_1, arg_2, arg_3)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _, _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted to the GraphEdit when the connection between the `fromPort` of the `fromNode` ``GraphNode`` and the `toPort` of the `toNode` ``GraphNode`` is attempted to be created.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.connectionRequest.connect { fromNode, fromPort, toNode, toPort in
    ///    print ("caught signal")
    /// }
    /// ```
    public var connectionRequest: Signal1 { Signal1 (target: self, signalName: "connection_request") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ fromNode: StringName, _ fromPort: Int64, _ toNode: StringName, _ toPort: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0])!
                let arg_1 = Int64 (args [1])!
                let arg_2 = StringName (args [2])!
                let arg_3 = Int64 (args [3])!
                
                callback (arg_0, arg_1, arg_2, arg_3)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _, _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted to the GraphEdit when the connection between `fromPort` of `fromNode` ``GraphNode`` and `toPort` of `toNode` ``GraphNode`` is attempted to be removed.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.disconnectionRequest.connect { fromNode, fromPort, toNode, toPort in
    ///    print ("caught signal")
    /// }
    /// ```
    public var disconnectionRequest: Signal2 { Signal2 (target: self, signalName: "disconnection_request") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal3/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal3/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal3/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal3 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal3 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ fromNode: StringName, _ fromPort: Int64, _ releasePosition: Vector2) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0])!
                let arg_1 = Int64 (args [1])!
                let arg_2 = Vector2 (args [2])!
                
                callback (arg_0, arg_1, arg_2)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when user drags a connection from an output port into the empty space of the graph.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.connectionToEmpty.connect { fromNode, fromPort, releasePosition in
    ///    print ("caught signal")
    /// }
    /// ```
    public var connectionToEmpty: Signal3 { Signal3 (target: self, signalName: "connection_to_empty") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal4/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal4/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal4/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal4 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal4 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ toNode: StringName, _ toPort: Int64, _ releasePosition: Vector2) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0])!
                let arg_1 = Int64 (args [1])!
                let arg_2 = Vector2 (args [2])!
                
                callback (arg_0, arg_1, arg_2)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when user drags a connection from an input port into the empty space of the graph.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.connectionFromEmpty.connect { toNode, toPort, releasePosition in
    ///    print ("caught signal")
    /// }
    /// ```
    public var connectionFromEmpty: Signal4 { Signal4 (target: self, signalName: "connection_from_empty") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal5/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal5/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal5/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal5 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal5 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ fromNode: StringName, _ fromPort: Int64, _ isOutput: Bool) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0])!
                let arg_1 = Int64 (args [1])!
                let arg_2 = Bool (args [2])!
                
                callback (arg_0, arg_1, arg_2)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted at the beginning of a connection drag.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.connectionDragStarted.connect { fromNode, fromPort, isOutput in
    ///    print ("caught signal")
    /// }
    /// ```
    public var connectionDragStarted: Signal5 { Signal5 (target: self, signalName: "connection_drag_started") }
    
    /// Emitted at the end of a connection drag.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.connectionDragEnded.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var connectionDragEnded: SimpleSignal { SimpleSignal (target: self, signalName: "connection_drag_ended") }
    
    /// Emitted when this ``GraphEdit`` captures a `ui_copy` action ([kbd]Ctrl + C[/kbd] by default). In general, this signal indicates that the selected ``GraphElement``s should be copied.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.copyNodesRequest.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var copyNodesRequest: SimpleSignal { SimpleSignal (target: self, signalName: "copy_nodes_request") }
    
    /// Emitted when this ``GraphEdit`` captures a `ui_paste` action ([kbd]Ctrl + V[/kbd] by default). In general, this signal indicates that previously copied ``GraphElement``s should be pasted.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.pasteNodesRequest.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var pasteNodesRequest: SimpleSignal { SimpleSignal (target: self, signalName: "paste_nodes_request") }
    
    /// Emitted when this ``GraphEdit`` captures a `ui_graph_duplicate` action ([kbd]Ctrl + D[/kbd] by default). In general, this signal indicates that the selected ``GraphElement``s should be duplicated.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.duplicateNodesRequest.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var duplicateNodesRequest: SimpleSignal { SimpleSignal (target: self, signalName: "duplicate_nodes_request") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal6/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal6/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal6/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal6 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal6 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ nodes: VariantCollection<StringName>) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = VariantCollection<StringName> (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when this ``GraphEdit`` captures a `ui_graph_delete` action ([kbd]Delete[/kbd] by default).
    /// 
    /// `nodes` is an array of node names that should be removed. These usually include all selected nodes.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.deleteNodesRequest.connect { nodes in
    ///    print ("caught signal")
    /// }
    /// ```
    public var deleteNodesRequest: Signal6 { Signal6 (target: self, signalName: "delete_nodes_request") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal7/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal7/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal7/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal7 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal7 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ node: Node) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0].toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? Node ?? Node (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the given ``GraphElement`` node is selected.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.nodeSelected.connect { node in
    ///    print ("caught signal")
    /// }
    /// ```
    public var nodeSelected: Signal7 { Signal7 (target: self, signalName: "node_selected") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal8/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal8/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal8/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal8 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal8 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ node: Node) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0].toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? Node ?? Node (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the given ``GraphElement`` node is deselected.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.nodeDeselected.connect { node in
    ///    print ("caught signal")
    /// }
    /// ```
    public var nodeDeselected: Signal8 { Signal8 (target: self, signalName: "node_deselected") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal9/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal9/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal9/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal9 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal9 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ frame: GraphFrame, _ newRect: Vector2) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0].toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? GraphFrame ?? GraphFrame (nativeHandle: ptr_0!)
                let arg_1 = Vector2 (args [1])!
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the ``GraphFrame`` `frame` is resized to `newRect`.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.frameRectChanged.connect { frame, newRect in
    ///    print ("caught signal")
    /// }
    /// ```
    public var frameRectChanged: Signal9 { Signal9 (target: self, signalName: "frame_rect_changed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal10/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal10/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal10/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal10 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal10 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ atPosition: Vector2) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Vector2 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a popup is requested. Happens on right-clicking in the GraphEdit. `atPosition` is the position of the mouse pointer when the signal is sent.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.popupRequest.connect { atPosition in
    ///    print ("caught signal")
    /// }
    /// ```
    public var popupRequest: Signal10 { Signal10 (target: self, signalName: "popup_request") }
    
    /// Emitted at the beginning of a ``GraphElement``'s movement.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.beginNodeMove.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var beginNodeMove: SimpleSignal { SimpleSignal (target: self, signalName: "begin_node_move") }
    
    /// Emitted at the end of a ``GraphElement``'s movement.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.endNodeMove.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var endNodeMove: SimpleSignal { SimpleSignal (target: self, signalName: "end_node_move") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal11/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal11/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal11/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal11 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal11 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ elements: GArray, _ frame: StringName) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = GArray (args [0])!
                let arg_1 = StringName (args [1])!
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when one or more ``GraphElement``s are dropped onto the ``GraphFrame`` named `frame`, when they were not previously attached to any other one.
    /// 
    /// `elements` is an array of ``GraphElement``s to be attached.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.graphElementsLinkedToFrameRequest.connect { elements, frame in
    ///    print ("caught signal")
    /// }
    /// ```
    public var graphElementsLinkedToFrameRequest: Signal11 { Signal11 (target: self, signalName: "graph_elements_linked_to_frame_request") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal12/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal12/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal12/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal12 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal12 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ offset: Vector2) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Vector2 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the scroll offset is changed by the user. It will not be emitted when changed in code.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.scrollOffsetChanged.connect { offset in
    ///    print ("caught signal")
    /// }
    /// ```
    public var scrollOffsetChanged: Signal12 { Signal12 (target: self, signalName: "scroll_offset_changed") }
    
}

// Support methods for proxies
func _GraphEdit_proxy_get_connection_line (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<GraphEdit>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._getConnectionLine (fromPosition: args [0]!.assumingMemoryBound (to: Vector2.self).pointee, toPosition: args [1]!.assumingMemoryBound (to: Vector2.self).pointee)
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // PackedVector2Array
    ret.content = PackedVector2Array.zero
}

func _GraphEdit_proxy_is_in_input_hotzone (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<GraphEdit>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._isInInputHotzone (inNode: lookupLiveObject (handleAddress: resolved_0) as? Object ?? Object (nativeHandle: resolved_0), inPort: args [1]!.assumingMemoryBound (to: Int32.self).pointee, mousePosition: args [2]!.assumingMemoryBound (to: Vector2.self).pointee)
    retPtr!.storeBytes (of: ret, as: Bool.self)
}

func _GraphEdit_proxy_is_in_output_hotzone (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<GraphEdit>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._isInOutputHotzone (inNode: lookupLiveObject (handleAddress: resolved_0) as? Object ?? Object (nativeHandle: resolved_0), inPort: args [1]!.assumingMemoryBound (to: Int32.self).pointee, mousePosition: args [2]!.assumingMemoryBound (to: Vector2.self).pointee)
    retPtr!.storeBytes (of: ret, as: Bool.self)
}

func _GraphEdit_proxy_is_node_hover_valid (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<GraphEdit>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._isNodeHoverValid (fromNode: StringName (content: args [0]!.assumingMemoryBound (to: Int64.self).pointee), fromPort: args [1]!.assumingMemoryBound (to: Int32.self).pointee, toNode: StringName (content: args [2]!.assumingMemoryBound (to: Int64.self).pointee), toPort: args [3]!.assumingMemoryBound (to: Int32.self).pointee)
    retPtr!.storeBytes (of: ret, as: Bool.self)
}

