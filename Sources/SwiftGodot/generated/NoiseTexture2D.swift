// This file is auto-generated, do not edit.
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
#if canImport(Darwin)
import Darwin
#elseif os(Windows)
import ucrt
import WinSDK
#elseif canImport(Android)
import Android
#elseif canImport(Glibc)
import Glibc
#elseif canImport(Musl)
import Musl
#else
#error("Unable to identify your C library.")
#endif
#endif


/// A 2D texture filled with noise generated by a ``Noise`` object.
/// 
/// Uses the ``FastNoiseLite`` library or other noise generators to fill the texture data of your desired size. ``NoiseTexture2D`` can also generate normal map textures.
/// 
/// The class uses ``Thread``s to generate the texture data internally, so ``Texture2D/getImage()`` may return `null` if the generation process has not completed yet. In that case, you need to wait for the texture to be generated before accessing the image and the generated byte data:
/// 
open class NoiseTexture2D: Texture2D {
    private static var className = StringName("NoiseTexture2D")
    override open class var godotClassName: StringName { className }
    
    /* Properties */
    
    /// Width of the generated texture (in pixels).
    final public var width: Int32 {
        get {
            return getWidth ()
        }
        
        set {
            set_width (newValue)
        }
        
    }
    
    /// Height of the generated texture (in pixels).
    final public var height: Int32 {
        get {
            return getHeight ()
        }
        
        set {
            set_height (newValue)
        }
        
    }
    
    /// If `true`, inverts the noise texture. White becomes black, black becomes white.
    final public var invert: Bool {
        get {
            return get_invert ()
        }
        
        set {
            set_invert (newValue)
        }
        
    }
    
    /// Determines whether the noise image is calculated in 3D space. May result in reduced contrast.
    final public var in3dSpace: Bool {
        get {
            return is_in_3d_space ()
        }
        
        set {
            set_in_3d_space (newValue)
        }
        
    }
    
    /// Determines whether mipmaps are generated for this texture. Enabling this results in less texture aliasing in the distance, at the cost of increasing memory usage by roughly 33% and making the noise texture generation take longer.
    /// 
    /// > Note: ``generateMipmaps`` requires mipmap filtering to be enabled on the material using the ``NoiseTexture2D`` to have an effect.
    /// 
    final public var generateMipmaps: Bool {
        get {
            return is_generating_mipmaps ()
        }
        
        set {
            set_generate_mipmaps (newValue)
        }
        
    }
    
    /// If `true`, a seamless texture is requested from the ``Noise`` resource.
    /// 
    /// > Note: Seamless noise textures may take longer to generate and/or can have a lower contrast compared to non-seamless noise depending on the used ``Noise`` resource. This is because some implementations use higher dimensions for generating seamless noise.
    /// 
    /// > Note: The default ``FastNoiseLite`` implementation uses the fallback path for seamless generation. If using a ``width`` or ``height`` lower than the default, you may need to increase ``seamlessBlendSkirt`` to make seamless blending more effective.
    /// 
    final public var seamless: Bool {
        get {
            return get_seamless ()
        }
        
        set {
            set_seamless (newValue)
        }
        
    }
    
    /// Used for the default/fallback implementation of the seamless texture generation. It determines the distance over which the seams are blended. High values may result in less details and contrast. See ``Noise`` for further details.
    /// 
    /// > Note: If using a ``width`` or ``height`` lower than the default, you may need to increase ``seamlessBlendSkirt`` to make seamless blending more effective.
    /// 
    final public var seamlessBlendSkirt: Double {
        get {
            return get_seamless_blend_skirt ()
        }
        
        set {
            set_seamless_blend_skirt (newValue)
        }
        
    }
    
    /// If `true`, the resulting texture contains a normal map created from the original noise interpreted as a bump map.
    final public var asNormalMap: Bool {
        get {
            return is_normal_map ()
        }
        
        set {
            set_as_normal_map (newValue)
        }
        
    }
    
    /// Strength of the bump maps used in this texture. A higher value will make the bump maps appear larger while a lower value will make them appear softer.
    final public var bumpStrength: Double {
        get {
            return get_bump_strength ()
        }
        
        set {
            set_bump_strength (newValue)
        }
        
    }
    
    /// If `true`, the noise image coming from the noise generator is normalized to the range `0.0` to `1.0`.
    /// 
    /// Turning normalization off can affect the contrast and allows you to generate non repeating tileable noise textures.
    /// 
    final public var normalize: Bool {
        get {
            return is_normalized ()
        }
        
        set {
            set_normalize (newValue)
        }
        
    }
    
    /// A ``Gradient`` which is used to map the luminance of each pixel to a color value.
    final public var colorRamp: Gradient? {
        get {
            return get_color_ramp ()
        }
        
        set {
            set_color_ramp (newValue)
        }
        
    }
    
    /// The instance of the ``Noise`` object.
    final public var noise: Noise? {
        get {
            return get_noise ()
        }
        
        set {
            set_noise (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static let method_set_width: GDExtensionMethodBindPtr = {
        var methodName = FastStringName("set_width")
        return withUnsafePointer(to: &NoiseTexture2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_width(_ width: Int32) {
        if handle == nil { Wrapped.attemptToUseObjectFreedByGodot() }
        withUnsafePointer(to: width) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(NoiseTexture2D.method_set_width, handle, pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static let method_set_height: GDExtensionMethodBindPtr = {
        var methodName = FastStringName("set_height")
        return withUnsafePointer(to: &NoiseTexture2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_height(_ height: Int32) {
        if handle == nil { Wrapped.attemptToUseObjectFreedByGodot() }
        withUnsafePointer(to: height) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(NoiseTexture2D.method_set_height, handle, pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static let method_set_invert: GDExtensionMethodBindPtr = {
        var methodName = FastStringName("set_invert")
        return withUnsafePointer(to: &NoiseTexture2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_invert(_ invert: Bool) {
        if handle == nil { Wrapped.attemptToUseObjectFreedByGodot() }
        withUnsafePointer(to: invert) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(NoiseTexture2D.method_set_invert, handle, pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static let method_get_invert: GDExtensionMethodBindPtr = {
        var methodName = FastStringName("get_invert")
        return withUnsafePointer(to: &NoiseTexture2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_invert() -> Bool {
        if handle == nil { Wrapped.attemptToUseObjectFreedByGodot() }
        var _result: Bool = false
        gi.object_method_bind_ptrcall(NoiseTexture2D.method_get_invert, handle, nil, &_result)
        return _result
    }
    
    fileprivate static let method_set_in_3d_space: GDExtensionMethodBindPtr = {
        var methodName = FastStringName("set_in_3d_space")
        return withUnsafePointer(to: &NoiseTexture2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_in_3d_space(_ enable: Bool) {
        if handle == nil { Wrapped.attemptToUseObjectFreedByGodot() }
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(NoiseTexture2D.method_set_in_3d_space, handle, pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static let method_is_in_3d_space: GDExtensionMethodBindPtr = {
        var methodName = FastStringName("is_in_3d_space")
        return withUnsafePointer(to: &NoiseTexture2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_in_3d_space() -> Bool {
        if handle == nil { Wrapped.attemptToUseObjectFreedByGodot() }
        var _result: Bool = false
        gi.object_method_bind_ptrcall(NoiseTexture2D.method_is_in_3d_space, handle, nil, &_result)
        return _result
    }
    
    fileprivate static let method_set_generate_mipmaps: GDExtensionMethodBindPtr = {
        var methodName = FastStringName("set_generate_mipmaps")
        return withUnsafePointer(to: &NoiseTexture2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_generate_mipmaps(_ invert: Bool) {
        if handle == nil { Wrapped.attemptToUseObjectFreedByGodot() }
        withUnsafePointer(to: invert) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(NoiseTexture2D.method_set_generate_mipmaps, handle, pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static let method_is_generating_mipmaps: GDExtensionMethodBindPtr = {
        var methodName = FastStringName("is_generating_mipmaps")
        return withUnsafePointer(to: &NoiseTexture2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_generating_mipmaps() -> Bool {
        if handle == nil { Wrapped.attemptToUseObjectFreedByGodot() }
        var _result: Bool = false
        gi.object_method_bind_ptrcall(NoiseTexture2D.method_is_generating_mipmaps, handle, nil, &_result)
        return _result
    }
    
    fileprivate static let method_set_seamless: GDExtensionMethodBindPtr = {
        var methodName = FastStringName("set_seamless")
        return withUnsafePointer(to: &NoiseTexture2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_seamless(_ seamless: Bool) {
        if handle == nil { Wrapped.attemptToUseObjectFreedByGodot() }
        withUnsafePointer(to: seamless) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(NoiseTexture2D.method_set_seamless, handle, pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static let method_get_seamless: GDExtensionMethodBindPtr = {
        var methodName = FastStringName("get_seamless")
        return withUnsafePointer(to: &NoiseTexture2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_seamless() -> Bool {
        if handle == nil { Wrapped.attemptToUseObjectFreedByGodot() }
        var _result: Bool = false
        gi.object_method_bind_ptrcall(NoiseTexture2D.method_get_seamless, handle, nil, &_result)
        return _result
    }
    
    fileprivate static let method_set_seamless_blend_skirt: GDExtensionMethodBindPtr = {
        var methodName = FastStringName("set_seamless_blend_skirt")
        return withUnsafePointer(to: &NoiseTexture2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_seamless_blend_skirt(_ seamlessBlendSkirt: Double) {
        if handle == nil { Wrapped.attemptToUseObjectFreedByGodot() }
        withUnsafePointer(to: seamlessBlendSkirt) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(NoiseTexture2D.method_set_seamless_blend_skirt, handle, pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static let method_get_seamless_blend_skirt: GDExtensionMethodBindPtr = {
        var methodName = FastStringName("get_seamless_blend_skirt")
        return withUnsafePointer(to: &NoiseTexture2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 191475506)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_seamless_blend_skirt() -> Double {
        if handle == nil { Wrapped.attemptToUseObjectFreedByGodot() }
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(NoiseTexture2D.method_get_seamless_blend_skirt, handle, nil, &_result)
        return _result
    }
    
    fileprivate static let method_set_as_normal_map: GDExtensionMethodBindPtr = {
        var methodName = FastStringName("set_as_normal_map")
        return withUnsafePointer(to: &NoiseTexture2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_as_normal_map(_ asNormalMap: Bool) {
        if handle == nil { Wrapped.attemptToUseObjectFreedByGodot() }
        withUnsafePointer(to: asNormalMap) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(NoiseTexture2D.method_set_as_normal_map, handle, pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static let method_is_normal_map: GDExtensionMethodBindPtr = {
        var methodName = FastStringName("is_normal_map")
        return withUnsafePointer(to: &NoiseTexture2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_normal_map() -> Bool {
        if handle == nil { Wrapped.attemptToUseObjectFreedByGodot() }
        var _result: Bool = false
        gi.object_method_bind_ptrcall(NoiseTexture2D.method_is_normal_map, handle, nil, &_result)
        return _result
    }
    
    fileprivate static let method_set_bump_strength: GDExtensionMethodBindPtr = {
        var methodName = FastStringName("set_bump_strength")
        return withUnsafePointer(to: &NoiseTexture2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_bump_strength(_ bumpStrength: Double) {
        if handle == nil { Wrapped.attemptToUseObjectFreedByGodot() }
        withUnsafePointer(to: bumpStrength) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(NoiseTexture2D.method_set_bump_strength, handle, pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static let method_get_bump_strength: GDExtensionMethodBindPtr = {
        var methodName = FastStringName("get_bump_strength")
        return withUnsafePointer(to: &NoiseTexture2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 191475506)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_bump_strength() -> Double {
        if handle == nil { Wrapped.attemptToUseObjectFreedByGodot() }
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(NoiseTexture2D.method_get_bump_strength, handle, nil, &_result)
        return _result
    }
    
    fileprivate static let method_set_normalize: GDExtensionMethodBindPtr = {
        var methodName = FastStringName("set_normalize")
        return withUnsafePointer(to: &NoiseTexture2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_normalize(_ normalize: Bool) {
        if handle == nil { Wrapped.attemptToUseObjectFreedByGodot() }
        withUnsafePointer(to: normalize) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(NoiseTexture2D.method_set_normalize, handle, pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static let method_is_normalized: GDExtensionMethodBindPtr = {
        var methodName = FastStringName("is_normalized")
        return withUnsafePointer(to: &NoiseTexture2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_normalized() -> Bool {
        if handle == nil { Wrapped.attemptToUseObjectFreedByGodot() }
        var _result: Bool = false
        gi.object_method_bind_ptrcall(NoiseTexture2D.method_is_normalized, handle, nil, &_result)
        return _result
    }
    
    fileprivate static let method_set_color_ramp: GDExtensionMethodBindPtr = {
        var methodName = FastStringName("set_color_ramp")
        return withUnsafePointer(to: &NoiseTexture2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2756054477)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_color_ramp(_ gradient: Gradient?) {
        if handle == nil { Wrapped.attemptToUseObjectFreedByGodot() }
        withUnsafePointer(to: gradient?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(NoiseTexture2D.method_set_color_ramp, handle, pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static let method_get_color_ramp: GDExtensionMethodBindPtr = {
        var methodName = FastStringName("get_color_ramp")
        return withUnsafePointer(to: &NoiseTexture2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 132272999)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_color_ramp() -> Gradient? {
        if handle == nil { Wrapped.attemptToUseObjectFreedByGodot() }
        var _result = GodotNativeObjectPointer(bitPattern: 0)
        gi.object_method_bind_ptrcall(NoiseTexture2D.method_get_color_ramp, handle, nil, &_result)
        guard let _result else { return nil } ; return getOrInitSwiftObject (nativeHandle: _result, ownsRef: true)
    }
    
    fileprivate static let method_set_noise: GDExtensionMethodBindPtr = {
        var methodName = FastStringName("set_noise")
        return withUnsafePointer(to: &NoiseTexture2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4135492439)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_noise(_ noise: Noise?) {
        if handle == nil { Wrapped.attemptToUseObjectFreedByGodot() }
        withUnsafePointer(to: noise?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(NoiseTexture2D.method_set_noise, handle, pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static let method_get_noise: GDExtensionMethodBindPtr = {
        var methodName = FastStringName("get_noise")
        return withUnsafePointer(to: &NoiseTexture2D.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 185851837)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_noise() -> Noise? {
        if handle == nil { Wrapped.attemptToUseObjectFreedByGodot() }
        var _result = GodotNativeObjectPointer(bitPattern: 0)
        gi.object_method_bind_ptrcall(NoiseTexture2D.method_get_noise, handle, nil, &_result)
        guard let _result else { return nil } ; return getOrInitSwiftObject (nativeHandle: _result, ownsRef: true)
    }
    
}

