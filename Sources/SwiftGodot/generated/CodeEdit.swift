// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
import Foundation
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A multiline text editor designed for editing code.
/// 
/// CodeEdit is a specialized ``TextEdit`` designed for editing plain text code files. It has many features commonly found in code editors such as line numbers, line folding, code completion, indent management, and string/comment management.
/// 
/// > Note: Regardless of locale, ``CodeEdit`` will by default always use left-to-right text direction to correctly display source code.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``breakpointToggled``
/// - ``codeCompletionRequested``
/// - ``symbolLookup``
/// - ``symbolValidate``
open class CodeEdit: TextEdit {
    override open class var godotClassName: StringName { "CodeEdit" }
    public enum CodeCompletionKind: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Marks the option as a class.
        case `class` = 0 // KIND_CLASS
        /// Marks the option as a function.
        case function = 1 // KIND_FUNCTION
        /// Marks the option as a Godot signal.
        case signal = 2 // KIND_SIGNAL
        /// Marks the option as a variable.
        case variable = 3 // KIND_VARIABLE
        /// Marks the option as a member.
        case member = 4 // KIND_MEMBER
        /// Marks the option as an enum entry.
        case `enum` = 5 // KIND_ENUM
        /// Marks the option as a constant.
        case constant = 6 // KIND_CONSTANT
        /// Marks the option as a Godot node path.
        case nodePath = 7 // KIND_NODE_PATH
        /// Marks the option as a file path.
        case filePath = 8 // KIND_FILE_PATH
        /// Marks the option as unclassified or plain text.
        case plainText = 9 // KIND_PLAIN_TEXT
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .`class`: return ".`class`"
                case .function: return ".function"
                case .signal: return ".signal"
                case .variable: return ".variable"
                case .member: return ".member"
                case .`enum`: return ".`enum`"
                case .constant: return ".constant"
                case .nodePath: return ".nodePath"
                case .filePath: return ".filePath"
                case .plainText: return ".plainText"
            }
            
        }
        
    }
    
    public enum CodeCompletionLocation: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The option is local to the location of the code completion query - e.g. a local variable. Subsequent value of location represent options from the outer class, the exact value represent how far they are (in terms of inner classes).
        case local = 0 // LOCATION_LOCAL
        /// The option is from the containing class or a parent class, relative to the location of the code completion query. Perform a bitwise OR with the class depth (e.g. `0` for the local class, `1` for the parent, `2` for the grandparent, etc.) to store the depth of an option in the class or a parent class.
        case parentMask = 256 // LOCATION_PARENT_MASK
        /// The option is from user code which is not local and not in a derived class (e.g. Autoload Singletons).
        case otherUserCode = 512 // LOCATION_OTHER_USER_CODE
        /// The option is from other engine code, not covered by the other enum constants - e.g. built-in classes.
        case other = 1024 // LOCATION_OTHER
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .local: return ".local"
                case .parentMask: return ".parentMask"
                case .otherUserCode: return ".otherUserCode"
                case .other: return ".other"
            }
            
        }
        
    }
    
    
    /* Properties */
    
    /// Set when a validated word from [signal symbol_validate] is clicked, the [signal symbol_lookup] should be emitted.
    final public var symbolLookupOnClick: Bool {
        get {
            return is_symbol_lookup_on_click_enabled ()
        }
        
        set {
            set_symbol_lookup_on_click_enabled (newValue)
        }
        
    }
    
    /// Sets whether line folding is allowed.
    final public var lineFolding: Bool {
        get {
            return is_line_folding_enabled ()
        }
        
        set {
            set_line_folding_enabled (newValue)
        }
        
    }
    
    /// Draws vertical lines at the provided columns. The first entry is considered a main hard guideline and is draw more prominently.
    final public var lineLengthGuidelines: VariantCollection<Int64> {
        get {
            return get_line_length_guidelines ()
        }
        
        set {
            set_line_length_guidelines (newValue)
        }
        
    }
    
    /// Sets if breakpoints should be drawn in the gutter. This gutter is shared with bookmarks and executing lines.
    final public var guttersDrawBreakpointsGutter: Bool {
        get {
            return is_drawing_breakpoints_gutter ()
        }
        
        set {
            set_draw_breakpoints_gutter (newValue)
        }
        
    }
    
    /// Sets if bookmarked should be drawn in the gutter. This gutter is shared with breakpoints and executing lines.
    final public var guttersDrawBookmarks: Bool {
        get {
            return is_drawing_bookmarks_gutter ()
        }
        
        set {
            set_draw_bookmarks_gutter (newValue)
        }
        
    }
    
    /// Sets if executing lines should be marked in the gutter. This gutter is shared with breakpoints and bookmarks lines.
    final public var guttersDrawExecutingLines: Bool {
        get {
            return is_drawing_executing_lines_gutter ()
        }
        
        set {
            set_draw_executing_lines_gutter (newValue)
        }
        
    }
    
    /// Sets if line numbers should be drawn in the gutter.
    final public var guttersDrawLineNumbers: Bool {
        get {
            return is_draw_line_numbers_enabled ()
        }
        
        set {
            set_draw_line_numbers (newValue)
        }
        
    }
    
    /// Sets if line numbers drawn in the gutter are zero padded.
    final public var guttersZeroPadLineNumbers: Bool {
        get {
            return is_line_numbers_zero_padded ()
        }
        
        set {
            set_line_numbers_zero_padded (newValue)
        }
        
    }
    
    /// Sets if foldable lines icons should be drawn in the gutter.
    final public var guttersDrawFoldGutter: Bool {
        get {
            return is_drawing_fold_gutter ()
        }
        
        set {
            set_draw_fold_gutter (newValue)
        }
        
    }
    
    /// Sets the string delimiters. All existing string delimiters will be removed.
    final public var delimiterStrings: VariantCollection<String> {
        get {
            return get_string_delimiters ()
        }
        
        set {
            set_string_delimiters (newValue)
        }
        
    }
    
    /// Sets the comment delimiters. All existing comment delimiters will be removed.
    final public var delimiterComments: VariantCollection<String> {
        get {
            return get_comment_delimiters ()
        }
        
        set {
            set_comment_delimiters (newValue)
        }
        
    }
    
    /// Sets whether code completion is allowed.
    final public var codeCompletionEnabled: Bool {
        get {
            return is_code_completion_enabled ()
        }
        
        set {
            set_code_completion_enabled (newValue)
        }
        
    }
    
    /// Sets prefixes that will trigger code completion.
    final public var codeCompletionPrefixes: VariantCollection<String> {
        get {
            return get_code_completion_prefixes ()
        }
        
        set {
            set_code_completion_prefixes (newValue)
        }
        
    }
    
    /// Size of the tabulation indent (one [kbd]Tab[/kbd] press) in characters. If ``indentUseSpaces`` is enabled the number of spaces to use.
    final public var indentSize: Int32 {
        get {
            return get_indent_size ()
        }
        
        set {
            set_indent_size (newValue)
        }
        
    }
    
    /// Use spaces instead of tabs for indentation.
    final public var indentUseSpaces: Bool {
        get {
            return is_indent_using_spaces ()
        }
        
        set {
            set_indent_using_spaces (newValue)
        }
        
    }
    
    /// Sets whether automatic indent are enabled, this will add an extra indent if a prefix or brace is found.
    final public var indentAutomatic: Bool {
        get {
            return is_auto_indent_enabled ()
        }
        
        set {
            set_auto_indent_enabled (newValue)
        }
        
    }
    
    /// Prefixes to trigger an automatic indent.
    final public var indentAutomaticPrefixes: VariantCollection<String> {
        get {
            return get_auto_indent_prefixes ()
        }
        
        set {
            set_auto_indent_prefixes (newValue)
        }
        
    }
    
    /// Sets whether brace pairs should be autocompleted.
    final public var autoBraceCompletionEnabled: Bool {
        get {
            return is_auto_brace_completion_enabled ()
        }
        
        set {
            set_auto_brace_completion_enabled (newValue)
        }
        
    }
    
    /// Highlight mismatching brace pairs.
    final public var autoBraceCompletionHighlightMatching: Bool {
        get {
            return is_highlight_matching_braces_enabled ()
        }
        
        set {
            set_highlight_matching_braces_enabled (newValue)
        }
        
    }
    
    /// Sets the brace pairs to be autocompleted.
    final public var autoBraceCompletionPairs: GDictionary {
        get {
            return get_auto_brace_completion_pairs ()
        }
        
        set {
            set_auto_brace_completion_pairs (newValue)
        }
        
    }
    
    /* Methods */
    /// Override this method to define how the selected entry should be inserted. If `replace` is `true`, any existing text should be replaced.
    @_documentation(visibility: public)
    open func _confirmCodeCompletion(replace: Bool) {
    }
    
    /// Override this method to define what happens when the user requests code completion. If `force` is `true`, any checks should be bypassed.
    @_documentation(visibility: public)
    open func _requestCodeCompletion(force: Bool) {
    }
    
    /// Override this method to define what items in `candidates` should be displayed.
    /// 
    /// Both `candidates` and the return is a ``GArray`` of ``GDictionary``, see ``getCodeCompletionOption(index:)`` for ``GDictionary`` content.
    /// 
    @_documentation(visibility: public)
    open func _filterCodeCompletionCandidates(_ candidates: VariantCollection<GDictionary>) -> VariantCollection<GDictionary> {
        return VariantCollection<GDictionary>()
    }
    
    fileprivate static var method_set_indent_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_indent_size")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_indent_size(_ size: Int32) {
        withUnsafePointer(to: size) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_set_indent_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_indent_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_indent_size")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_indent_size() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(CodeEdit.method_get_indent_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_indent_using_spaces: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_indent_using_spaces")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_indent_using_spaces(_ useSpaces: Bool) {
        withUnsafePointer(to: useSpaces) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_set_indent_using_spaces, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_indent_using_spaces: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_indent_using_spaces")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_indent_using_spaces() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(CodeEdit.method_is_indent_using_spaces, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_auto_indent_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_auto_indent_enabled")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_auto_indent_enabled(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_set_auto_indent_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_auto_indent_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_auto_indent_enabled")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_auto_indent_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(CodeEdit.method_is_auto_indent_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_auto_indent_prefixes: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_auto_indent_prefixes")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 381264803)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_auto_indent_prefixes(_ prefixes: VariantCollection<String>) {
        withUnsafePointer(to: prefixes.array.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_set_auto_indent_prefixes, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_auto_indent_prefixes: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_auto_indent_prefixes")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_auto_indent_prefixes() -> VariantCollection<String> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall(CodeEdit.method_get_auto_indent_prefixes, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return VariantCollection<String>(content: _result)
    }
    
    fileprivate static var method_do_indent: GDExtensionMethodBindPtr = {
        let methodName = StringName("do_indent")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Perform an indent as if the user activated the "ui_text_indent" action.
    public final func doIndent() {
        gi.object_method_bind_ptrcall(CodeEdit.method_do_indent, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_indent_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName("indent_lines")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Indents selected lines, or in the case of no selection the caret line by one.
    public final func indentLines() {
        gi.object_method_bind_ptrcall(CodeEdit.method_indent_lines, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_unindent_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName("unindent_lines")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Unindents selected lines, or in the case of no selection the caret line by one. Same as performing "ui_text_unindent" action.
    public final func unindentLines() {
        gi.object_method_bind_ptrcall(CodeEdit.method_unindent_lines, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_convert_indent: GDExtensionMethodBindPtr = {
        let methodName = StringName("convert_indent")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 423910286)!
            }
            
        }
        
    }()
    
    /// Converts the indents of lines between `fromLine` and `toLine` to tabs or spaces as set by ``indentUseSpaces``.
    /// 
    /// Values of `-1` convert the entire text.
    /// 
    public final func convertIndent(fromLine: Int32 = -1, toLine: Int32 = -1) {
        withUnsafePointer(to: fromLine) { pArg0 in
            withUnsafePointer(to: toLine) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CodeEdit.method_convert_indent, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_auto_brace_completion_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_auto_brace_completion_enabled")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_auto_brace_completion_enabled(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_set_auto_brace_completion_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_auto_brace_completion_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_auto_brace_completion_enabled")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_auto_brace_completion_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(CodeEdit.method_is_auto_brace_completion_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_highlight_matching_braces_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_highlight_matching_braces_enabled")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_highlight_matching_braces_enabled(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_set_highlight_matching_braces_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_highlight_matching_braces_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_highlight_matching_braces_enabled")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_highlight_matching_braces_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(CodeEdit.method_is_highlight_matching_braces_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_add_auto_brace_completion_pair: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_auto_brace_completion_pair")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3186203200)!
            }
            
        }
        
    }()
    
    /// Adds a brace pair.
    /// 
    /// Both the start and end keys must be symbols. Only the start key has to be unique.
    /// 
    public final func addAutoBraceCompletionPair(startKey: String, endKey: String) {
        let startKey = GString(startKey)
        withUnsafePointer(to: startKey.content) { pArg0 in
            let endKey = GString(endKey)
            withUnsafePointer(to: endKey.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CodeEdit.method_add_auto_brace_completion_pair, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_auto_brace_completion_pairs: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_auto_brace_completion_pairs")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4155329257)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_auto_brace_completion_pairs(_ pairs: GDictionary) {
        withUnsafePointer(to: pairs.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_set_auto_brace_completion_pairs, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_auto_brace_completion_pairs: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_auto_brace_completion_pairs")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3102165223)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_auto_brace_completion_pairs() -> GDictionary {
        let _result: GDictionary = GDictionary ()
        gi.object_method_bind_ptrcall(CodeEdit.method_get_auto_brace_completion_pairs, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_has_auto_brace_completion_open_key: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_auto_brace_completion_open_key")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3927539163)!
            }
            
        }
        
    }()
    
    /// Returns `true` if open key `openKey` exists.
    public final func hasAutoBraceCompletionOpenKey(_ openKey: String) -> Bool {
        var _result: Bool = false
        let openKey = GString(openKey)
        withUnsafePointer(to: openKey.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_has_auto_brace_completion_open_key, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_auto_brace_completion_close_key: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_auto_brace_completion_close_key")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3927539163)!
            }
            
        }
        
    }()
    
    /// Returns `true` if close key `closeKey` exists.
    public final func hasAutoBraceCompletionCloseKey(_ closeKey: String) -> Bool {
        var _result: Bool = false
        let closeKey = GString(closeKey)
        withUnsafePointer(to: closeKey.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_has_auto_brace_completion_close_key, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_auto_brace_completion_close_key: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_auto_brace_completion_close_key")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3135753539)!
            }
            
        }
        
    }()
    
    /// Gets the matching auto brace close key for `openKey`.
    public final func getAutoBraceCompletionCloseKey(openKey: String) -> String {
        let _result = GString ()
        let openKey = GString(openKey)
        withUnsafePointer(to: openKey.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_get_auto_brace_completion_close_key, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_set_draw_breakpoints_gutter: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_draw_breakpoints_gutter")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_draw_breakpoints_gutter(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_set_draw_breakpoints_gutter, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_drawing_breakpoints_gutter: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_drawing_breakpoints_gutter")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_drawing_breakpoints_gutter() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(CodeEdit.method_is_drawing_breakpoints_gutter, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_draw_bookmarks_gutter: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_draw_bookmarks_gutter")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_draw_bookmarks_gutter(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_set_draw_bookmarks_gutter, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_drawing_bookmarks_gutter: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_drawing_bookmarks_gutter")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_drawing_bookmarks_gutter() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(CodeEdit.method_is_drawing_bookmarks_gutter, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_draw_executing_lines_gutter: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_draw_executing_lines_gutter")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_draw_executing_lines_gutter(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_set_draw_executing_lines_gutter, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_drawing_executing_lines_gutter: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_drawing_executing_lines_gutter")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_drawing_executing_lines_gutter() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(CodeEdit.method_is_drawing_executing_lines_gutter, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_line_as_breakpoint: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_line_as_breakpoint")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Sets the line as breakpointed.
    public final func setLineAsBreakpoint(line: Int32, breakpointed: Bool) {
        withUnsafePointer(to: line) { pArg0 in
            withUnsafePointer(to: breakpointed) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CodeEdit.method_set_line_as_breakpoint, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_line_breakpointed: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_line_breakpointed")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns whether the line at the specified index is breakpointed or not.
    public final func isLineBreakpointed(line: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: line) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_is_line_breakpointed, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_clear_breakpointed_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear_breakpointed_lines")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears all breakpointed lines.
    public final func clearBreakpointedLines() {
        gi.object_method_bind_ptrcall(CodeEdit.method_clear_breakpointed_lines, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_get_breakpointed_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_breakpointed_lines")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1930428628)!
            }
            
        }
        
    }()
    
    /// Gets all breakpointed lines.
    public final func getBreakpointedLines() -> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        gi.object_method_bind_ptrcall(CodeEdit.method_get_breakpointed_lines, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_line_as_bookmarked: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_line_as_bookmarked")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Sets the line as bookmarked.
    public final func setLineAsBookmarked(line: Int32, bookmarked: Bool) {
        withUnsafePointer(to: line) { pArg0 in
            withUnsafePointer(to: bookmarked) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CodeEdit.method_set_line_as_bookmarked, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_line_bookmarked: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_line_bookmarked")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns whether the line at the specified index is bookmarked or not.
    public final func isLineBookmarked(line: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: line) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_is_line_bookmarked, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_clear_bookmarked_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear_bookmarked_lines")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears all bookmarked lines.
    public final func clearBookmarkedLines() {
        gi.object_method_bind_ptrcall(CodeEdit.method_clear_bookmarked_lines, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_get_bookmarked_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_bookmarked_lines")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1930428628)!
            }
            
        }
        
    }()
    
    /// Gets all bookmarked lines.
    public final func getBookmarkedLines() -> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        gi.object_method_bind_ptrcall(CodeEdit.method_get_bookmarked_lines, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_line_as_executing: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_line_as_executing")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Sets the line as executing.
    public final func setLineAsExecuting(line: Int32, executing: Bool) {
        withUnsafePointer(to: line) { pArg0 in
            withUnsafePointer(to: executing) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CodeEdit.method_set_line_as_executing, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_line_executing: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_line_executing")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns whether the line at the specified index is marked as executing or not.
    public final func isLineExecuting(line: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: line) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_is_line_executing, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_clear_executing_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear_executing_lines")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears all executed lines.
    public final func clearExecutingLines() {
        gi.object_method_bind_ptrcall(CodeEdit.method_clear_executing_lines, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_get_executing_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_executing_lines")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1930428628)!
            }
            
        }
        
    }()
    
    /// Gets all executing lines.
    public final func getExecutingLines() -> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        gi.object_method_bind_ptrcall(CodeEdit.method_get_executing_lines, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_draw_line_numbers: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_draw_line_numbers")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_draw_line_numbers(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_set_draw_line_numbers, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_draw_line_numbers_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_draw_line_numbers_enabled")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_draw_line_numbers_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(CodeEdit.method_is_draw_line_numbers_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_line_numbers_zero_padded: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_line_numbers_zero_padded")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_line_numbers_zero_padded(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_set_line_numbers_zero_padded, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_line_numbers_zero_padded: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_line_numbers_zero_padded")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_line_numbers_zero_padded() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(CodeEdit.method_is_line_numbers_zero_padded, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_draw_fold_gutter: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_draw_fold_gutter")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_draw_fold_gutter(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_set_draw_fold_gutter, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_drawing_fold_gutter: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_drawing_fold_gutter")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_drawing_fold_gutter() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(CodeEdit.method_is_drawing_fold_gutter, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_line_folding_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_line_folding_enabled")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_line_folding_enabled(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_set_line_folding_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_line_folding_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_line_folding_enabled")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_line_folding_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(CodeEdit.method_is_line_folding_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_can_fold_line: GDExtensionMethodBindPtr = {
        let methodName = StringName("can_fold_line")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns if the given line is foldable, that is, it has indented lines right below it or a comment / string block.
    public final func canFoldLine(_ line: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: line) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_can_fold_line, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_fold_line: GDExtensionMethodBindPtr = {
        let methodName = StringName("fold_line")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Folds the given line, if possible (see ``canFoldLine(_:)``).
    public final func foldLine(_ line: Int32) {
        withUnsafePointer(to: line) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_fold_line, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_unfold_line: GDExtensionMethodBindPtr = {
        let methodName = StringName("unfold_line")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Unfolds all lines that were previously folded.
    public final func unfoldLine(_ line: Int32) {
        withUnsafePointer(to: line) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_unfold_line, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_fold_all_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName("fold_all_lines")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Folds all lines that are possible to be folded (see ``canFoldLine(_:)``).
    public final func foldAllLines() {
        gi.object_method_bind_ptrcall(CodeEdit.method_fold_all_lines, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_unfold_all_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName("unfold_all_lines")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Unfolds all lines, folded or not.
    public final func unfoldAllLines() {
        gi.object_method_bind_ptrcall(CodeEdit.method_unfold_all_lines, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_toggle_foldable_line: GDExtensionMethodBindPtr = {
        let methodName = StringName("toggle_foldable_line")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Toggle the folding of the code block at the given line.
    public final func toggleFoldableLine(_ line: Int32) {
        withUnsafePointer(to: line) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_toggle_foldable_line, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_toggle_foldable_lines_at_carets: GDExtensionMethodBindPtr = {
        let methodName = StringName("toggle_foldable_lines_at_carets")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Toggle the folding of the code block on all lines with a caret on them.
    public final func toggleFoldableLinesAtCarets() {
        gi.object_method_bind_ptrcall(CodeEdit.method_toggle_foldable_lines_at_carets, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_is_line_folded: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_line_folded")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns whether the line at the specified index is folded or not.
    public final func isLineFolded(line: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: line) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_is_line_folded, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_folded_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_folded_lines")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    /// Returns all lines that are current folded.
    public final func getFoldedLines() -> VariantCollection<Int64> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall(CodeEdit.method_get_folded_lines, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return VariantCollection<Int64>(content: _result)
    }
    
    fileprivate static var method_create_code_region: GDExtensionMethodBindPtr = {
        let methodName = StringName("create_code_region")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Creates a new code region with the selection. At least one single line comment delimiter have to be defined (see ``addCommentDelimiter(startKey:endKey:lineOnly:)``).
    /// 
    /// A code region is a part of code that is highlighted when folded and can help organize your script.
    /// 
    /// Code region start and end tags can be customized (see ``setCodeRegionTags(start:end:)``).
    /// 
    /// Code regions are delimited using start and end tags (respectively `region` and `endregion` by default) preceded by one line comment delimiter. (eg. `#region` and `#endregion`)
    /// 
    public final func createCodeRegion() {
        gi.object_method_bind_ptrcall(CodeEdit.method_create_code_region, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_get_code_region_start_tag: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_code_region_start_tag")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the code region start tag (without comment delimiter).
    public final func getCodeRegionStartTag() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(CodeEdit.method_get_code_region_start_tag, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_code_region_end_tag: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_code_region_end_tag")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the code region end tag (without comment delimiter).
    public final func getCodeRegionEndTag() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(CodeEdit.method_get_code_region_end_tag, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_set_code_region_tags: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_code_region_tags")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 708800718)!
            }
            
        }
        
    }()
    
    /// Sets the code region start and end tags (without comment delimiter).
    public final func setCodeRegionTags(start: String = "region", end: String = "endregion") {
        let start = GString(start)
        withUnsafePointer(to: start.content) { pArg0 in
            let end = GString(end)
            withUnsafePointer(to: end.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CodeEdit.method_set_code_region_tags, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_line_code_region_start: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_line_code_region_start")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns whether the line at the specified index is a code region start.
    public final func isLineCodeRegionStart(line: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: line) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_is_line_code_region_start, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_line_code_region_end: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_line_code_region_end")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns whether the line at the specified index is a code region end.
    public final func isLineCodeRegionEnd(line: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: line) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_is_line_code_region_end, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_add_string_delimiter: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_string_delimiter")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3146098955)!
            }
            
        }
        
    }()
    
    /// Defines a string delimiter from `startKey` to `endKey`. Both keys should be symbols, and `startKey` must not be shared with other delimiters.
    /// 
    /// If `lineOnly` is `true` or `endKey` is an empty ``String``, the region does not carry over to the next line.
    /// 
    public final func addStringDelimiter(startKey: String, endKey: String, lineOnly: Bool = false) {
        let startKey = GString(startKey)
        withUnsafePointer(to: startKey.content) { pArg0 in
            let endKey = GString(endKey)
            withUnsafePointer(to: endKey.content) { pArg1 in
                withUnsafePointer(to: lineOnly) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(CodeEdit.method_add_string_delimiter, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_remove_string_delimiter: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_string_delimiter")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Removes the string delimiter with `startKey`.
    public final func removeStringDelimiter(startKey: String) {
        let startKey = GString(startKey)
        withUnsafePointer(to: startKey.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_remove_string_delimiter, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_has_string_delimiter: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_string_delimiter")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3927539163)!
            }
            
        }
        
    }()
    
    /// Returns `true` if string `startKey` exists.
    public final func hasStringDelimiter(startKey: String) -> Bool {
        var _result: Bool = false
        let startKey = GString(startKey)
        withUnsafePointer(to: startKey.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_has_string_delimiter, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_string_delimiters: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_string_delimiters")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 381264803)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_string_delimiters(_ stringDelimiters: VariantCollection<String>) {
        withUnsafePointer(to: stringDelimiters.array.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_set_string_delimiters, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_clear_string_delimiters: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear_string_delimiters")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Removes all string delimiters.
    public final func clearStringDelimiters() {
        gi.object_method_bind_ptrcall(CodeEdit.method_clear_string_delimiters, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_get_string_delimiters: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_string_delimiters")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_string_delimiters() -> VariantCollection<String> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall(CodeEdit.method_get_string_delimiters, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return VariantCollection<String>(content: _result)
    }
    
    fileprivate static var method_is_in_string: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_in_string")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 688195400)!
            }
            
        }
        
    }()
    
    /// Returns the delimiter index if `line` `column` is in a string. If `column` is not provided, will return the delimiter index if the entire `line` is a string. Otherwise `-1`.
    public final func isInString(line: Int32, column: Int32 = -1) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: line) { pArg0 in
            withUnsafePointer(to: column) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CodeEdit.method_is_in_string, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_add_comment_delimiter: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_comment_delimiter")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3146098955)!
            }
            
        }
        
    }()
    
    /// Adds a comment delimiter from `startKey` to `endKey`. Both keys should be symbols, and `startKey` must not be shared with other delimiters.
    /// 
    /// If `lineOnly` is `true` or `endKey` is an empty ``String``, the region does not carry over to the next line.
    /// 
    public final func addCommentDelimiter(startKey: String, endKey: String, lineOnly: Bool = false) {
        let startKey = GString(startKey)
        withUnsafePointer(to: startKey.content) { pArg0 in
            let endKey = GString(endKey)
            withUnsafePointer(to: endKey.content) { pArg1 in
                withUnsafePointer(to: lineOnly) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(CodeEdit.method_add_comment_delimiter, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_remove_comment_delimiter: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_comment_delimiter")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Removes the comment delimiter with `startKey`.
    public final func removeCommentDelimiter(startKey: String) {
        let startKey = GString(startKey)
        withUnsafePointer(to: startKey.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_remove_comment_delimiter, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_has_comment_delimiter: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_comment_delimiter")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3927539163)!
            }
            
        }
        
    }()
    
    /// Returns `true` if comment `startKey` exists.
    public final func hasCommentDelimiter(startKey: String) -> Bool {
        var _result: Bool = false
        let startKey = GString(startKey)
        withUnsafePointer(to: startKey.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_has_comment_delimiter, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_comment_delimiters: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_comment_delimiters")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 381264803)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_comment_delimiters(_ commentDelimiters: VariantCollection<String>) {
        withUnsafePointer(to: commentDelimiters.array.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_set_comment_delimiters, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_clear_comment_delimiters: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear_comment_delimiters")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Removes all comment delimiters.
    public final func clearCommentDelimiters() {
        gi.object_method_bind_ptrcall(CodeEdit.method_clear_comment_delimiters, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_get_comment_delimiters: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_comment_delimiters")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_comment_delimiters() -> VariantCollection<String> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall(CodeEdit.method_get_comment_delimiters, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return VariantCollection<String>(content: _result)
    }
    
    fileprivate static var method_is_in_comment: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_in_comment")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 688195400)!
            }
            
        }
        
    }()
    
    /// Returns delimiter index if `line` `column` is in a comment. If `column` is not provided, will return delimiter index if the entire `line` is a comment. Otherwise `-1`.
    public final func isInComment(line: Int32, column: Int32 = -1) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: line) { pArg0 in
            withUnsafePointer(to: column) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CodeEdit.method_is_in_comment, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_delimiter_start_key: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_delimiter_start_key")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Gets the start key for a string or comment region index.
    public final func getDelimiterStartKey(delimiterIndex: Int32) -> String {
        let _result = GString ()
        withUnsafePointer(to: delimiterIndex) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_get_delimiter_start_key, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_get_delimiter_end_key: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_delimiter_end_key")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Gets the end key for a string or comment region index.
    public final func getDelimiterEndKey(delimiterIndex: Int32) -> String {
        let _result = GString ()
        withUnsafePointer(to: delimiterIndex) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_get_delimiter_end_key, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_get_delimiter_start_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_delimiter_start_position")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3016396712)!
            }
            
        }
        
    }()
    
    /// If `line` `column` is in a string or comment, returns the start position of the region. If not or no start could be found, both ``Vector2`` values will be `-1`.
    public final func getDelimiterStartPosition(line: Int32, column: Int32) -> Vector2 {
        var _result: Vector2 = Vector2 ()
        withUnsafePointer(to: line) { pArg0 in
            withUnsafePointer(to: column) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CodeEdit.method_get_delimiter_start_position, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_delimiter_end_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_delimiter_end_position")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3016396712)!
            }
            
        }
        
    }()
    
    /// If `line` `column` is in a string or comment, returns the end position of the region. If not or no end could be found, both ``Vector2`` values will be `-1`.
    public final func getDelimiterEndPosition(line: Int32, column: Int32) -> Vector2 {
        var _result: Vector2 = Vector2 ()
        withUnsafePointer(to: line) { pArg0 in
            withUnsafePointer(to: column) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CodeEdit.method_get_delimiter_end_position, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_code_hint: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_code_hint")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Sets the code hint text. Pass an empty string to clear.
    public final func setCodeHint(_ codeHint: String) {
        let codeHint = GString(codeHint)
        withUnsafePointer(to: codeHint.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_set_code_hint, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_code_hint_draw_below: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_code_hint_draw_below")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// Sets if the code hint should draw below the text.
    public final func setCodeHintDrawBelow(_ drawBelow: Bool) {
        withUnsafePointer(to: drawBelow) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_set_code_hint_draw_below, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_text_for_code_completion: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_text_for_code_completion")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the full text with char `0xFFFF` at the caret location.
    public final func getTextForCodeCompletion() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(CodeEdit.method_get_text_for_code_completion, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_request_code_completion: GDExtensionMethodBindPtr = {
        let methodName = StringName("request_code_completion")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 107499316)!
            }
            
        }
        
    }()
    
    /// Emits [signal code_completion_requested], if `force` is `true` will bypass all checks. Otherwise will check that the caret is in a word or in front of a prefix. Will ignore the request if all current options are of type file path, node path, or signal.
    public final func requestCodeCompletion(force: Bool = false) {
        withUnsafePointer(to: force) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_request_code_completion, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_code_completion_option: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_code_completion_option")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3944379502)!
            }
            
        }
        
    }()
    
    /// Submits an item to the queue of potential candidates for the autocomplete menu. Call ``updateCodeCompletionOptions(force:)`` to update the list.
    /// 
    /// `location` indicates location of the option relative to the location of the code completion query. See ``CodeEdit.CodeCompletionLocation`` for how to set this value.
    /// 
    /// > Note: This list will replace all current candidates.
    /// 
    public final func addCodeCompletionOption(type: CodeEdit.CodeCompletionKind, displayText: String, insertText: String, textColor: Color = Color (r: 1, g: 1, b: 1, a: 1), icon: Resource? = nil, value: Variant, location: Int32 = 1024) {
        withUnsafePointer(to: type.rawValue) { pArg0 in
            let displayText = GString(displayText)
            withUnsafePointer(to: displayText.content) { pArg1 in
                let insertText = GString(insertText)
                withUnsafePointer(to: insertText.content) { pArg2 in
                    withUnsafePointer(to: textColor) { pArg3 in
                        withUnsafePointer(to: icon?.handle) { pArg4 in
                            withUnsafePointer(to: value.content) { pArg5 in
                                withUnsafePointer(to: location) { pArg6 in
                                    withUnsafePointer(to: UnsafeRawPointersN7(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6)) { pArgs in
                                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 7) { pArgs in
                                            gi.object_method_bind_ptrcall(CodeEdit.method_add_code_completion_option, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_update_code_completion_options: GDExtensionMethodBindPtr = {
        let methodName = StringName("update_code_completion_options")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// Submits all completion options added with ``addCodeCompletionOption(type:displayText:insertText:textColor:icon:value:location:)``. Will try to force the autocomplete menu to popup, if `force` is `true`.
    /// 
    /// > Note: This will replace all current candidates.
    /// 
    public final func updateCodeCompletionOptions(force: Bool) {
        withUnsafePointer(to: force) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_update_code_completion_options, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_code_completion_options: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_code_completion_options")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    /// Gets all completion options, see ``getCodeCompletionOption(index:)`` for return content.
    public final func getCodeCompletionOptions() -> VariantCollection<GDictionary> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall(CodeEdit.method_get_code_completion_options, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return VariantCollection<GDictionary>(content: _result)
    }
    
    fileprivate static var method_get_code_completion_option: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_code_completion_option")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3485342025)!
            }
            
        }
        
    }()
    
    /// Gets the completion option at `index`. The return ``GDictionary`` has the following key-values:
    /// 
    /// `kind`: ``CodeEdit/CodeCompletionKind``
    /// 
    /// `display_text`: Text that is shown on the autocomplete menu.
    /// 
    /// `insert_text`: Text that is to be inserted when this item is selected.
    /// 
    /// `font_color`: Color of the text on the autocomplete menu.
    /// 
    /// `icon`: Icon to draw on the autocomplete menu.
    /// 
    /// `default_value`: Value of the symbol.
    /// 
    public final func getCodeCompletionOption(index: Int32) -> GDictionary {
        let _result: GDictionary = GDictionary ()
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_get_code_completion_option, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_code_completion_selected_index: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_code_completion_selected_index")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Gets the index of the current selected completion option.
    public final func getCodeCompletionSelectedIndex() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(CodeEdit.method_get_code_completion_selected_index, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_code_completion_selected_index: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_code_completion_selected_index")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Sets the current selected completion option.
    public final func setCodeCompletionSelectedIndex(_ index: Int32) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_set_code_completion_selected_index, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_confirm_code_completion: GDExtensionMethodBindPtr = {
        let methodName = StringName("confirm_code_completion")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 107499316)!
            }
            
        }
        
    }()
    
    /// Inserts the selected entry into the text. If `replace` is `true`, any existing text is replaced rather than merged.
    public final func confirmCodeCompletion(replace: Bool = false) {
        withUnsafePointer(to: replace) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_confirm_code_completion, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_cancel_code_completion: GDExtensionMethodBindPtr = {
        let methodName = StringName("cancel_code_completion")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Cancels the autocomplete menu.
    public final func cancelCodeCompletion() {
        gi.object_method_bind_ptrcall(CodeEdit.method_cancel_code_completion, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_set_code_completion_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_code_completion_enabled")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_code_completion_enabled(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_set_code_completion_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_code_completion_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_code_completion_enabled")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_code_completion_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(CodeEdit.method_is_code_completion_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_code_completion_prefixes: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_code_completion_prefixes")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 381264803)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_code_completion_prefixes(_ prefixes: VariantCollection<String>) {
        withUnsafePointer(to: prefixes.array.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_set_code_completion_prefixes, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_code_completion_prefixes: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_code_completion_prefixes")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_code_completion_prefixes() -> VariantCollection<String> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall(CodeEdit.method_get_code_completion_prefixes, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return VariantCollection<String>(content: _result)
    }
    
    fileprivate static var method_set_line_length_guidelines: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_line_length_guidelines")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 381264803)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_line_length_guidelines(_ guidelineColumns: VariantCollection<Int64>) {
        withUnsafePointer(to: guidelineColumns.array.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_set_line_length_guidelines, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_line_length_guidelines: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_line_length_guidelines")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_line_length_guidelines() -> VariantCollection<Int64> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall(CodeEdit.method_get_line_length_guidelines, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return VariantCollection<Int64>(content: _result)
    }
    
    fileprivate static var method_set_symbol_lookup_on_click_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_symbol_lookup_on_click_enabled")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_symbol_lookup_on_click_enabled(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_set_symbol_lookup_on_click_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_symbol_lookup_on_click_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_symbol_lookup_on_click_enabled")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_symbol_lookup_on_click_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(CodeEdit.method_is_symbol_lookup_on_click_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_text_for_symbol_lookup: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_text_for_symbol_lookup")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the full text with char `0xFFFF` at the cursor location.
    public final func getTextForSymbolLookup() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(CodeEdit.method_get_text_for_symbol_lookup, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_text_with_cursor_char: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_text_with_cursor_char")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1391810591)!
            }
            
        }
        
    }()
    
    /// Returns the full text with char `0xFFFF` at the specified location.
    public final func getTextWithCursorChar(line: Int32, column: Int32) -> String {
        let _result = GString ()
        withUnsafePointer(to: line) { pArg0 in
            withUnsafePointer(to: column) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(CodeEdit.method_get_text_with_cursor_char, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_set_symbol_lookup_word_as_valid: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_symbol_lookup_word_as_valid")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// Sets the symbol emitted by [signal symbol_validate] as a valid lookup.
    public final func setSymbolLookupWordAsValid(_ valid: Bool) {
        withUnsafePointer(to: valid) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(CodeEdit.method_set_symbol_lookup_word_as_valid, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_move_lines_up: GDExtensionMethodBindPtr = {
        let methodName = StringName("move_lines_up")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Moves all lines up that are selected or have a caret on them.
    public final func moveLinesUp() {
        gi.object_method_bind_ptrcall(CodeEdit.method_move_lines_up, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_move_lines_down: GDExtensionMethodBindPtr = {
        let methodName = StringName("move_lines_down")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Moves all lines down that are selected or have a caret on them.
    public final func moveLinesDown() {
        gi.object_method_bind_ptrcall(CodeEdit.method_move_lines_down, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_delete_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName("delete_lines")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Deletes all lines that are selected or have a caret on them.
    public final func deleteLines() {
        gi.object_method_bind_ptrcall(CodeEdit.method_delete_lines, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_duplicate_selection: GDExtensionMethodBindPtr = {
        let methodName = StringName("duplicate_selection")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Duplicates all selected text and duplicates all lines with a caret on them.
    public final func duplicateSelection() {
        gi.object_method_bind_ptrcall(CodeEdit.method_duplicate_selection, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_duplicate_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName("duplicate_lines")
        return withUnsafePointer(to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Duplicates all lines currently selected with any caret. Duplicates the entire line beneath the current one no matter where the caret is within the line.
    public final func duplicateLines() {
        gi.object_method_bind_ptrcall(CodeEdit.method_duplicate_lines, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    override class func getVirtualDispatcher (name: StringName) -> GDExtensionClassCallVirtual? {
        guard implementedOverrides().contains(name) else { return nil }
        switch name.description {
            case "_confirm_code_completion":
                return _CodeEdit_proxy_confirm_code_completion
            case "_filter_code_completion_candidates":
                return _CodeEdit_proxy_filter_code_completion_candidates
            case "_request_code_completion":
                return _CodeEdit_proxy_request_code_completion
            default:
                return super.getVirtualDispatcher (name: name)
        }
        
    }
    
    // Signals 
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ line: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a breakpoint is added or removed from a line. If the line is moved via backspace a removed is emitted at the old line.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.breakpointToggled.connect { line in
    ///    print ("caught signal")
    /// }
    /// ```
    public var breakpointToggled: Signal1 { Signal1 (target: self, signalName: "breakpoint_toggled") }
    
    /// Emitted when the user requests code completion.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.codeCompletionRequested.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var codeCompletionRequested: SimpleSignal { SimpleSignal (target: self, signalName: "code_completion_requested") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ symbol: String, _ line: Int64, _ column: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = GString (args [0])!.description
                let arg_1 = Int64 (args [1])!
                let arg_2 = Int64 (args [2])!
                
                callback (arg_0, arg_1, arg_2)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the user has clicked on a valid symbol.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.symbolLookup.connect { symbol, line, column in
    ///    print ("caught signal")
    /// }
    /// ```
    public var symbolLookup: Signal2 { Signal2 (target: self, signalName: "symbol_lookup") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal3/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal3/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal3/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal3 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal3 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ symbol: String) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = GString (args [0])!.description
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the user hovers over a symbol. The symbol should be validated and responded to, by calling ``setSymbolLookupWordAsValid(_:)``.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.symbolValidate.connect { symbol in
    ///    print ("caught signal")
    /// }
    /// ```
    public var symbolValidate: Signal3 { Signal3 (target: self, signalName: "symbol_validate") }
    
}

// Support methods for proxies
func _CodeEdit_proxy_confirm_code_completion (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<CodeEdit>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._confirmCodeCompletion (replace: args [0]!.assumingMemoryBound (to: Bool.self).pointee)
}

func _CodeEdit_proxy_filter_code_completion_candidates (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<CodeEdit>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._filterCodeCompletionCandidates (args [0]!.assumingMemoryBound (to: VariantCollection<GDictionary>.self).pointee)
    retPtr!.storeBytes (of: ret.array.content, as: type (of: ret.array.content)) // typedarray::Dictionary
}

func _CodeEdit_proxy_request_code_completion (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<CodeEdit>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._requestCodeCompletion (force: args [0]!.assumingMemoryBound (to: Bool.self).pointee)
}

