// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
import Foundation
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Exposes a 2D atlas texture as a set of tiles for a ``TileSet`` resource.
/// 
/// An atlas is a grid of tiles laid out on a texture. Each tile in the grid must be exposed using ``createTile(atlasCoords:size:)``. Those tiles are then indexed using their coordinates in the grid.
/// 
/// Each tile can also have a size in the grid coordinates, making it more or less cells in the atlas.
/// 
/// Alternatives version of a tile can be created using ``createAlternativeTile(atlasCoords:alternativeIdOverride:)``, which are then indexed using an alternative ID. The main tile (the one in the grid), is accessed with an alternative ID equal to 0.
/// 
/// Each tile alternate has a set of properties that is defined by the source's ``TileSet`` layers. Those properties are stored in a TileData object that can be accessed and modified using ``getTileData(atlasCoords:alternativeTile:)``.
/// 
/// As TileData properties are stored directly in the TileSetAtlasSource resource, their properties might also be set using `TileSetAtlasSource.set("<coords_x>:<coords_y>/<alternative_id>/<tile_data_property>")`.
/// 
open class TileSetAtlasSource: TileSetSource {
    override open class var godotClassName: StringName { "TileSetAtlasSource" }
    public enum TileAnimationMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Tile animations start at same time, looking identical.
        case `default` = 0 // TILE_ANIMATION_MODE_DEFAULT
        /// Tile animations start at random times, looking varied.
        case randomStartTimes = 1 // TILE_ANIMATION_MODE_RANDOM_START_TIMES
        /// Represents the size of the ``TileSetAtlasSource/TileAnimationMode`` enum.
        case max = 2 // TILE_ANIMATION_MODE_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .`default`: return ".`default`"
                case .randomStartTimes: return ".randomStartTimes"
                case .max: return ".max"
            }
            
        }
        
    }
    
    /* Constants */
    /// Represents cell's horizontal flip flag. Should be used directly with ``TileMap`` to flip placed tiles by altering their alternative IDs.
    /// 
    /// > Note: These transformations can be combined to do the equivalent of 0, 90, 180, and 270 degree rotations, as shown below:
    /// 
    public static let transformFlipH = 4096
    /// Represents cell's vertical flip flag. See ``transformFlipH`` for usage.
    public static let transformFlipV = 8192
    /// Represents cell's transposed flag. See ``transformFlipH`` for usage.
    public static let transformTranspose = 16384
    
    /* Properties */
    
    /// The atlas texture.
    final public var texture: Texture2D? {
        get {
            return get_texture ()
        }
        
        set {
            set_texture (newValue)
        }
        
    }
    
    /// Margins, in pixels, to offset the origin of the grid in the texture.
    final public var margins: Vector2i {
        get {
            return get_margins ()
        }
        
        set {
            set_margins (newValue)
        }
        
    }
    
    /// Separation, in pixels, between each tile texture region of the grid.
    final public var separation: Vector2i {
        get {
            return get_separation ()
        }
        
        set {
            set_separation (newValue)
        }
        
    }
    
    /// The base tile size in the texture (in pixel). This size must be bigger than the TileSet's `tile_size` value.
    final public var textureRegionSize: Vector2i {
        get {
            return get_texture_region_size ()
        }
        
        set {
            set_texture_region_size (newValue)
        }
        
    }
    
    /// If `true`, generates an internal texture with an additional one pixel padding around each tile. Texture padding avoids a common artifact where lines appear between tiles.
    /// 
    /// Disabling this setting might lead a small performance improvement, as generating the internal texture requires both memory and processing time when the TileSetAtlasSource resource is modified.
    /// 
    final public var useTexturePadding: Bool {
        get {
            return get_use_texture_padding ()
        }
        
        set {
            set_use_texture_padding (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_set_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_texture")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4051416890)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_texture(_ texture: Texture2D?) {
        withUnsafePointer(to: texture?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileSetAtlasSource.method_set_texture, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_texture")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3635182373)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_texture() -> Texture2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(TileSetAtlasSource.method_get_texture, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_margins: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_margins")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1130785943)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_margins(_ margins: Vector2i) {
        withUnsafePointer(to: margins) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileSetAtlasSource.method_set_margins, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_margins: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_margins")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3690982128)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_margins() -> Vector2i {
        var _result: Vector2i = Vector2i ()
        gi.object_method_bind_ptrcall(TileSetAtlasSource.method_get_margins, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_separation: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_separation")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1130785943)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_separation(_ separation: Vector2i) {
        withUnsafePointer(to: separation) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileSetAtlasSource.method_set_separation, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_separation: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_separation")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3690982128)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_separation() -> Vector2i {
        var _result: Vector2i = Vector2i ()
        gi.object_method_bind_ptrcall(TileSetAtlasSource.method_get_separation, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_texture_region_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_texture_region_size")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1130785943)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_texture_region_size(_ textureRegionSize: Vector2i) {
        withUnsafePointer(to: textureRegionSize) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileSetAtlasSource.method_set_texture_region_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_texture_region_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_texture_region_size")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3690982128)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_texture_region_size() -> Vector2i {
        var _result: Vector2i = Vector2i ()
        gi.object_method_bind_ptrcall(TileSetAtlasSource.method_get_texture_region_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_use_texture_padding: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_use_texture_padding")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_use_texture_padding(_ useTexturePadding: Bool) {
        withUnsafePointer(to: useTexturePadding) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileSetAtlasSource.method_set_use_texture_padding, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_use_texture_padding: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_use_texture_padding")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_use_texture_padding() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(TileSetAtlasSource.method_get_use_texture_padding, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_create_tile: GDExtensionMethodBindPtr = {
        let methodName = StringName("create_tile")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 190528769)!
            }
            
        }
        
    }()
    
    /// Creates a new tile at coordinates `atlasCoords` with the given `size`.
    public final func createTile(atlasCoords: Vector2i, size: Vector2i = Vector2i (x: 1, y: 1)) {
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileSetAtlasSource.method_create_tile, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_remove_tile: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_tile")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1130785943)!
            }
            
        }
        
    }()
    
    /// Remove a tile and its alternative at coordinates `atlasCoords`.
    public final func removeTile(atlasCoords: Vector2i) {
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileSetAtlasSource.method_remove_tile, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_move_tile_in_atlas: GDExtensionMethodBindPtr = {
        let methodName = StringName("move_tile_in_atlas")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3870111920)!
            }
            
        }
        
    }()
    
    /// Move the tile and its alternatives at the `atlasCoords` coordinates to the `newAtlasCoords` coordinates with the `newSize` size. This functions will fail if a tile is already present in the given area.
    /// 
    /// If `newAtlasCoords` is `Vector2i(-1, -1)`, keeps the tile's coordinates. If `newSize` is `Vector2i(-1, -1)`, keeps the tile's size.
    /// 
    /// To avoid an error, first check if a move is possible using ``hasRoomForTile(atlasCoords:size:animationColumns:animationSeparation:framesCount:ignoredTile:)``.
    /// 
    public final func moveTileInAtlas(atlasCoords: Vector2i, newAtlasCoords: Vector2i = Vector2i (x: -1, y: -1), newSize: Vector2i = Vector2i (x: -1, y: -1)) {
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: newAtlasCoords) { pArg1 in
                withUnsafePointer(to: newSize) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TileSetAtlasSource.method_move_tile_in_atlas, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_tile_size_in_atlas: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_tile_size_in_atlas")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3050897911)!
            }
            
        }
        
    }()
    
    /// Returns the size of the tile (in the grid coordinates system) at coordinates `atlasCoords`.
    public final func getTileSizeInAtlas(atlasCoords: Vector2i) -> Vector2i {
        var _result: Vector2i = Vector2i ()
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileSetAtlasSource.method_get_tile_size_in_atlas, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_room_for_tile: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_room_for_tile")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3018597268)!
            }
            
        }
        
    }()
    
    /// Returns whether there is enough room in an atlas to create/modify a tile with the given properties. If `ignoredTile` is provided, act as is the given tile was not present in the atlas. This may be used when you want to modify a tile's properties.
    public final func hasRoomForTile(atlasCoords: Vector2i, size: Vector2i, animationColumns: Int32, animationSeparation: Vector2i, framesCount: Int32, ignoredTile: Vector2i = Vector2i (x: -1, y: -1)) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: size) { pArg1 in
                withUnsafePointer(to: animationColumns) { pArg2 in
                    withUnsafePointer(to: animationSeparation) { pArg3 in
                        withUnsafePointer(to: framesCount) { pArg4 in
                            withUnsafePointer(to: ignoredTile) { pArg5 in
                                withUnsafePointer(to: UnsafeRawPointersN6(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5)) { pArgs in
                                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 6) { pArgs in
                                        gi.object_method_bind_ptrcall(TileSetAtlasSource.method_has_room_for_tile, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_tiles_to_be_removed_on_change: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_tiles_to_be_removed_on_change")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1240378054)!
            }
            
        }
        
    }()
    
    /// Returns an array of tiles coordinates ID that will be automatically removed when modifying one or several of those properties: `texture`, `margins`, `separation` or `textureRegionSize`. This can be used to undo changes that would have caused tiles data loss.
    public final func getTilesToBeRemovedOnChange(texture: Texture2D?, margins: Vector2i, separation: Vector2i, textureRegionSize: Vector2i) -> PackedVector2Array {
        let _result: PackedVector2Array = PackedVector2Array ()
        withUnsafePointer(to: texture?.handle) { pArg0 in
            withUnsafePointer(to: margins) { pArg1 in
                withUnsafePointer(to: separation) { pArg2 in
                    withUnsafePointer(to: textureRegionSize) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(TileSetAtlasSource.method_get_tiles_to_be_removed_on_change, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_tile_at_coords: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_tile_at_coords")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3050897911)!
            }
            
        }
        
    }()
    
    /// If there is a tile covering the `atlasCoords` coordinates, returns the top-left coordinates of the tile (thus its coordinate ID). Returns `Vector2i(-1, -1)` otherwise.
    public final func getTileAtCoords(atlasCoords: Vector2i) -> Vector2i {
        var _result: Vector2i = Vector2i ()
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileSetAtlasSource.method_get_tile_at_coords, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_has_tiles_outside_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_tiles_outside_texture")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Checks if the source has any tiles that don't fit the texture area (either partially or completely).
    public final func hasTilesOutsideTexture() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(TileSetAtlasSource.method_has_tiles_outside_texture, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_clear_tiles_outside_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear_tiles_outside_texture")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Removes all tiles that don't fit the available texture area. This method iterates over all the source's tiles, so it's advised to use ``hasTilesOutsideTexture()`` beforehand.
    public final func clearTilesOutsideTexture() {
        gi.object_method_bind_ptrcall(TileSetAtlasSource.method_clear_tiles_outside_texture, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_set_tile_animation_columns: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_tile_animation_columns")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3200960707)!
            }
            
        }
        
    }()
    
    /// Sets the number of columns in the animation layout of the tile at coordinates `atlasCoords`. If set to 0, then the different frames of the animation are laid out as a single horizontal line in the atlas.
    public final func setTileAnimationColumns(atlasCoords: Vector2i, frameColumns: Int32) {
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: frameColumns) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileSetAtlasSource.method_set_tile_animation_columns, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_tile_animation_columns: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_tile_animation_columns")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2485466453)!
            }
            
        }
        
    }()
    
    /// Returns how many columns the tile at `atlasCoords` has in its animation layout.
    public final func getTileAnimationColumns(atlasCoords: Vector2i) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileSetAtlasSource.method_get_tile_animation_columns, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_tile_animation_separation: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_tile_animation_separation")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1941061099)!
            }
            
        }
        
    }()
    
    /// Sets the margin (in grid tiles) between each tile in the animation layout of the tile at coordinates `atlasCoords` has.
    public final func setTileAnimationSeparation(atlasCoords: Vector2i, separation: Vector2i) {
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: separation) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileSetAtlasSource.method_set_tile_animation_separation, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_tile_animation_separation: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_tile_animation_separation")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3050897911)!
            }
            
        }
        
    }()
    
    /// Returns the separation (as in the atlas grid) between each frame of an animated tile at coordinates `atlasCoords`.
    public final func getTileAnimationSeparation(atlasCoords: Vector2i) -> Vector2i {
        var _result: Vector2i = Vector2i ()
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileSetAtlasSource.method_get_tile_animation_separation, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_tile_animation_speed: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_tile_animation_speed")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2262553149)!
            }
            
        }
        
    }()
    
    /// Sets the animation speed of the tile at coordinates `atlasCoords` has.
    public final func setTileAnimationSpeed(atlasCoords: Vector2i, speed: Double) {
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: speed) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileSetAtlasSource.method_set_tile_animation_speed, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_tile_animation_speed: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_tile_animation_speed")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 719993801)!
            }
            
        }
        
    }()
    
    /// Returns the animation speed of the tile at coordinates `atlasCoords`.
    public final func getTileAnimationSpeed(atlasCoords: Vector2i) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileSetAtlasSource.method_get_tile_animation_speed, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_tile_animation_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_tile_animation_mode")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3192753483)!
            }
            
        }
        
    }()
    
    /// Sets the tile animation mode of the tile at `atlasCoords` to `mode`. See also ``getTileAnimationMode(atlasCoords:)``.
    public final func setTileAnimationMode(atlasCoords: Vector2i, mode: TileSetAtlasSource.TileAnimationMode) {
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: mode.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileSetAtlasSource.method_set_tile_animation_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_tile_animation_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_tile_animation_mode")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4025349959)!
            }
            
        }
        
    }()
    
    /// Returns the tile animation mode of the tile at `atlasCoords`. See also ``setTileAnimationMode(atlasCoords:mode:)``.
    public final func getTileAnimationMode(atlasCoords: Vector2i) -> TileSetAtlasSource.TileAnimationMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileSetAtlasSource.method_get_tile_animation_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return TileSetAtlasSource.TileAnimationMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_tile_animation_frames_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_tile_animation_frames_count")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3200960707)!
            }
            
        }
        
    }()
    
    /// Sets how many animation frames the tile at coordinates `atlasCoords` has.
    public final func setTileAnimationFramesCount(atlasCoords: Vector2i, framesCount: Int32) {
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: framesCount) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileSetAtlasSource.method_set_tile_animation_frames_count, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_tile_animation_frames_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_tile_animation_frames_count")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2485466453)!
            }
            
        }
        
    }()
    
    /// Returns how many animation frames has the tile at coordinates `atlasCoords`.
    public final func getTileAnimationFramesCount(atlasCoords: Vector2i) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileSetAtlasSource.method_get_tile_animation_frames_count, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_tile_animation_frame_duration: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_tile_animation_frame_duration")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2843487787)!
            }
            
        }
        
    }()
    
    /// Sets the animation frame `duration` of frame `frameIndex` for the tile at coordinates `atlasCoords`.
    public final func setTileAnimationFrameDuration(atlasCoords: Vector2i, frameIndex: Int32, duration: Double) {
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: frameIndex) { pArg1 in
                withUnsafePointer(to: duration) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TileSetAtlasSource.method_set_tile_animation_frame_duration, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_tile_animation_frame_duration: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_tile_animation_frame_duration")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1802448425)!
            }
            
        }
        
    }()
    
    /// Returns the animation frame duration of frame `frameIndex` for the tile at coordinates `atlasCoords`.
    public final func getTileAnimationFrameDuration(atlasCoords: Vector2i, frameIndex: Int32) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: frameIndex) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileSetAtlasSource.method_get_tile_animation_frame_duration, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_tile_animation_total_duration: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_tile_animation_total_duration")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 719993801)!
            }
            
        }
        
    }()
    
    /// Returns the sum of the sum of the frame durations of the tile at coordinates `atlasCoords`. This value needs to be divided by the animation speed to get the actual animation loop duration.
    public final func getTileAnimationTotalDuration(atlasCoords: Vector2i) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileSetAtlasSource.method_get_tile_animation_total_duration, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_create_alternative_tile: GDExtensionMethodBindPtr = {
        let methodName = StringName("create_alternative_tile")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2226298068)!
            }
            
        }
        
    }()
    
    /// Creates an alternative tile for the tile at coordinates `atlasCoords`. If `alternativeIdOverride` is -1, give it an automatically generated unique ID, or assigns it the given ID otherwise.
    /// 
    /// Returns the new alternative identifier, or -1 if the alternative could not be created with a provided `alternativeIdOverride`.
    /// 
    public final func createAlternativeTile(atlasCoords: Vector2i, alternativeIdOverride: Int32 = -1) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: alternativeIdOverride) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileSetAtlasSource.method_create_alternative_tile, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_remove_alternative_tile: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_alternative_tile")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3200960707)!
            }
            
        }
        
    }()
    
    /// Remove a tile's alternative with alternative ID `alternativeTile`.
    /// 
    /// Calling this function with `alternativeTile` equals to 0 will fail, as the base tile alternative cannot be removed.
    /// 
    public final func removeAlternativeTile(atlasCoords: Vector2i, alternativeTile: Int32) {
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: alternativeTile) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileSetAtlasSource.method_remove_alternative_tile, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_alternative_tile_id: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_alternative_tile_id")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1499785778)!
            }
            
        }
        
    }()
    
    /// Change a tile's alternative ID from `alternativeTile` to `newId`.
    /// 
    /// Calling this function with `newId` of 0 will fail, as the base tile alternative cannot be moved.
    /// 
    public final func setAlternativeTileId(atlasCoords: Vector2i, alternativeTile: Int32, newId: Int32) {
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: alternativeTile) { pArg1 in
                withUnsafePointer(to: newId) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TileSetAtlasSource.method_set_alternative_tile_id, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_next_alternative_tile_id: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_next_alternative_tile_id")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2485466453)!
            }
            
        }
        
    }()
    
    /// Returns the alternative ID a following call to ``createAlternativeTile(atlasCoords:alternativeIdOverride:)`` would return.
    public final func getNextAlternativeTileId(atlasCoords: Vector2i) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileSetAtlasSource.method_get_next_alternative_tile_id, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_tile_data: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_tile_data")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3534028207)!
            }
            
        }
        
    }()
    
    /// Returns the ``TileData`` object for the given atlas coordinates and alternative ID.
    public final func getTileData(atlasCoords: Vector2i, alternativeTile: Int32) -> TileData? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: alternativeTile) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileSetAtlasSource.method_get_tile_data, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_atlas_grid_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_atlas_grid_size")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3690982128)!
            }
            
        }
        
    }()
    
    /// Returns the atlas grid size, which depends on how many tiles can fit in the texture. It thus depends on the ``texture``'s size, the atlas ``margins``, and the tiles' ``textureRegionSize``.
    public final func getAtlasGridSize() -> Vector2i {
        var _result: Vector2i = Vector2i ()
        gi.object_method_bind_ptrcall(TileSetAtlasSource.method_get_atlas_grid_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_tile_texture_region: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_tile_texture_region")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 241857547)!
            }
            
        }
        
    }()
    
    /// Returns a tile's texture region in the atlas texture. For animated tiles, a `frame` argument might be provided for the different frames of the animation.
    public final func getTileTextureRegion(atlasCoords: Vector2i, frame: Int32 = 0) -> Rect2i {
        var _result: Rect2i = Rect2i ()
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: frame) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileSetAtlasSource.method_get_tile_texture_region, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_runtime_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_runtime_texture")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3635182373)!
            }
            
        }
        
    }()
    
    /// If ``useTexturePadding`` is `false`, returns ``texture``. Otherwise, returns and internal ``ImageTexture`` created that includes the padding.
    public final func getRuntimeTexture() -> Texture2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(TileSetAtlasSource.method_get_runtime_texture, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_runtime_tile_texture_region: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_runtime_tile_texture_region")
        return withUnsafePointer(to: &TileSetAtlasSource.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 104874263)!
            }
            
        }
        
    }()
    
    /// Returns the region of the tile at coordinates `atlasCoords` for the given `frame` inside the texture returned by ``getRuntimeTexture()``.
    /// 
    /// > Note: If ``useTexturePadding`` is `false`, returns the same as ``getTileTextureRegion(atlasCoords:frame:)``.
    /// 
    public final func getRuntimeTileTextureRegion(atlasCoords: Vector2i, frame: Int32) -> Rect2i {
        var _result: Rect2i = Rect2i ()
        withUnsafePointer(to: atlasCoords) { pArg0 in
            withUnsafePointer(to: frame) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileSetAtlasSource.method_get_runtime_tile_texture_region, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
}

