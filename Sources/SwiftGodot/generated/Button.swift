// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
import Foundation
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A themed button that can contain text and an icon.
/// 
/// ``Button`` is the standard themed button. It can contain text and an icon, and it will display them according to the current ``Theme``.
/// 
/// **Example of creating a button and assigning an action when pressed by code:**
/// 
/// See also ``BaseButton`` which contains common properties and methods associated with this node.
/// 
/// > Note: Buttons do not interpret touch input and therefore don't support multitouch, since mouse emulation can only press one button at a given time. Use ``TouchScreenButton`` for buttons that trigger gameplay movement or actions.
/// 
open class Button: BaseButton {
    override open class var godotClassName: StringName { "Button" }
    
    /* Properties */
    
    /// The button's text that will be displayed inside the button's area.
    final public var text: String {
        get {
            return get_text ()
        }
        
        set {
            set_text (newValue)
        }
        
    }
    
    /// Button's icon, if text is present the icon will be placed before the text.
    /// 
    /// To edit margin and spacing of the icon, use [theme_item h_separation] theme property and `content_margin_*` properties of the used ``StyleBox``es.
    /// 
    final public var icon: Texture2D? {
        get {
            return get_button_icon ()
        }
        
        set {
            set_button_icon (newValue)
        }
        
    }
    
    /// Flat buttons don't display decoration.
    final public var flat: Bool {
        get {
            return is_flat ()
        }
        
        set {
            set_flat (newValue)
        }
        
    }
    
    /// Text alignment policy for the button's text, use one of the ``HorizontalAlignment`` constants.
    final public var alignment: HorizontalAlignment {
        get {
            return get_text_alignment ()
        }
        
        set {
            set_text_alignment (newValue)
        }
        
    }
    
    /// Sets the clipping behavior when the text exceeds the node's bounding rectangle. See ``TextServer.OverrunBehavior`` for a description of all modes.
    final public var textOverrunBehavior: TextServer.OverrunBehavior {
        get {
            return get_text_overrun_behavior ()
        }
        
        set {
            set_text_overrun_behavior (newValue)
        }
        
    }
    
    /// If set to something other than ``TextServer/AutowrapMode/autowrapOff``, the text gets wrapped inside the node's bounding rectangle.
    final public var autowrapMode: TextServer.AutowrapMode {
        get {
            return get_autowrap_mode ()
        }
        
        set {
            set_autowrap_mode (newValue)
        }
        
    }
    
    /// When this property is enabled, text that is too large to fit the button is clipped, when disabled the Button will always be wide enough to hold the text.
    final public var clipText: Bool {
        get {
            return get_clip_text ()
        }
        
        set {
            set_clip_text (newValue)
        }
        
    }
    
    /// Specifies if the icon should be aligned horizontally to the left, right, or center of a button. Uses the same ``HorizontalAlignment`` constants as the text alignment. If centered horizontally and vertically, text will draw on top of the icon.
    final public var iconAlignment: HorizontalAlignment {
        get {
            return get_icon_alignment ()
        }
        
        set {
            set_icon_alignment (newValue)
        }
        
    }
    
    /// Specifies if the icon should be aligned vertically to the top, bottom, or center of a button. Uses the same ``VerticalAlignment`` constants as the text alignment. If centered horizontally and vertically, text will draw on top of the icon.
    final public var verticalIconAlignment: VerticalAlignment {
        get {
            return get_vertical_icon_alignment ()
        }
        
        set {
            set_vertical_icon_alignment (newValue)
        }
        
    }
    
    /// When enabled, the button's icon will expand/shrink to fit the button's size while keeping its aspect. See also [theme_item icon_max_width].
    final public var expandIcon: Bool {
        get {
            return is_expand_icon ()
        }
        
        set {
            set_expand_icon (newValue)
        }
        
    }
    
    /// Base text writing direction.
    final public var textDirection: Control.TextDirection {
        get {
            return get_text_direction ()
        }
        
        set {
            set_text_direction (newValue)
        }
        
    }
    
    /// Language code used for line-breaking and text shaping algorithms, if left empty current locale is used instead.
    final public var language: String {
        get {
            return get_language ()
        }
        
        set {
            set_language (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_set_text: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_text")
        return withUnsafePointer(to: &Button.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_text(_ text: String) {
        let text = GString(text)
        withUnsafePointer(to: text.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Button.method_set_text, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_text: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_text")
        return withUnsafePointer(to: &Button.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_text() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(Button.method_get_text, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_set_text_overrun_behavior: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_text_overrun_behavior")
        return withUnsafePointer(to: &Button.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1008890932)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_text_overrun_behavior(_ overrunBehavior: TextServer.OverrunBehavior) {
        withUnsafePointer(to: overrunBehavior.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Button.method_set_text_overrun_behavior, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_text_overrun_behavior: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_text_overrun_behavior")
        return withUnsafePointer(to: &Button.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3779142101)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_text_overrun_behavior() -> TextServer.OverrunBehavior {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Button.method_get_text_overrun_behavior, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return TextServer.OverrunBehavior (rawValue: _result)!
    }
    
    fileprivate static var method_set_autowrap_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_autowrap_mode")
        return withUnsafePointer(to: &Button.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3289138044)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_autowrap_mode(_ autowrapMode: TextServer.AutowrapMode) {
        withUnsafePointer(to: autowrapMode.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Button.method_set_autowrap_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_autowrap_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_autowrap_mode")
        return withUnsafePointer(to: &Button.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1549071663)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_autowrap_mode() -> TextServer.AutowrapMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Button.method_get_autowrap_mode, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return TextServer.AutowrapMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_text_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_text_direction")
        return withUnsafePointer(to: &Button.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 119160795)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_text_direction(_ direction: Control.TextDirection) {
        withUnsafePointer(to: direction.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Button.method_set_text_direction, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_text_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_text_direction")
        return withUnsafePointer(to: &Button.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 797257663)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_text_direction() -> Control.TextDirection {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Button.method_get_text_direction, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Control.TextDirection (rawValue: _result)!
    }
    
    fileprivate static var method_set_language: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_language")
        return withUnsafePointer(to: &Button.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_language(_ language: String) {
        let language = GString(language)
        withUnsafePointer(to: language.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Button.method_set_language, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_language: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_language")
        return withUnsafePointer(to: &Button.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_language() -> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall(Button.method_get_language, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_set_button_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_button_icon")
        return withUnsafePointer(to: &Button.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4051416890)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_button_icon(_ texture: Texture2D?) {
        withUnsafePointer(to: texture?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Button.method_set_button_icon, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_button_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_button_icon")
        return withUnsafePointer(to: &Button.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3635182373)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_button_icon() -> Texture2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(Button.method_get_button_icon, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_flat: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_flat")
        return withUnsafePointer(to: &Button.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_flat(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Button.method_set_flat, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_flat: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_flat")
        return withUnsafePointer(to: &Button.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_flat() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Button.method_is_flat, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_clip_text: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_clip_text")
        return withUnsafePointer(to: &Button.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_clip_text(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Button.method_set_clip_text, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_clip_text: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_clip_text")
        return withUnsafePointer(to: &Button.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_clip_text() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Button.method_get_clip_text, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_text_alignment: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_text_alignment")
        return withUnsafePointer(to: &Button.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2312603777)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_text_alignment(_ alignment: HorizontalAlignment) {
        withUnsafePointer(to: alignment.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Button.method_set_text_alignment, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_text_alignment: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_text_alignment")
        return withUnsafePointer(to: &Button.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 341400642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_text_alignment() -> HorizontalAlignment {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Button.method_get_text_alignment, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return HorizontalAlignment (rawValue: _result)!
    }
    
    fileprivate static var method_set_icon_alignment: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_icon_alignment")
        return withUnsafePointer(to: &Button.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2312603777)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_icon_alignment(_ iconAlignment: HorizontalAlignment) {
        withUnsafePointer(to: iconAlignment.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Button.method_set_icon_alignment, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_icon_alignment: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_icon_alignment")
        return withUnsafePointer(to: &Button.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 341400642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_icon_alignment() -> HorizontalAlignment {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Button.method_get_icon_alignment, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return HorizontalAlignment (rawValue: _result)!
    }
    
    fileprivate static var method_set_vertical_icon_alignment: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_vertical_icon_alignment")
        return withUnsafePointer(to: &Button.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1796458609)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_vertical_icon_alignment(_ verticalIconAlignment: VerticalAlignment) {
        withUnsafePointer(to: verticalIconAlignment.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Button.method_set_vertical_icon_alignment, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_vertical_icon_alignment: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_vertical_icon_alignment")
        return withUnsafePointer(to: &Button.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3274884059)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_vertical_icon_alignment() -> VerticalAlignment {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Button.method_get_vertical_icon_alignment, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return VerticalAlignment (rawValue: _result)!
    }
    
    fileprivate static var method_set_expand_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_expand_icon")
        return withUnsafePointer(to: &Button.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_expand_icon(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Button.method_set_expand_icon, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_expand_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_expand_icon")
        return withUnsafePointer(to: &Button.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_expand_icon() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Button.method_is_expand_icon, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
}

