// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
import Foundation
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Our OpenXR interface.
/// 
/// The OpenXR interface allows Godot to interact with OpenXR runtimes and make it possible to create XR experiences and games.
/// 
/// Due to the needs of OpenXR this interface works slightly different than other plugin based XR interfaces. It needs to be initialized when Godot starts. You need to enable OpenXR, settings for this can be found in your games project settings under the XR heading. You do need to mark a viewport for use with XR in order for Godot to know which render result should be output to the headset.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``sessionBegun``
/// - ``sessionStopping``
/// - ``sessionFocussed``
/// - ``sessionVisible``
/// - ``sessionLossPending``
/// - ``instanceExiting``
/// - ``poseRecentered``
/// - ``refreshRateChanged``
open class OpenXRInterface: XRInterface {
    override open class var godotClassName: StringName { "OpenXRInterface" }
    public enum Hand: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Left hand.
        case left = 0 // HAND_LEFT
        /// Right hand.
        case right = 1 // HAND_RIGHT
        /// Maximum value for the hand enum.
        case max = 2 // HAND_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .left: return ".left"
                case .right: return ".right"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum HandMotionRange: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Full hand range, if user closes their hands, we make a full fist.
        case unobstructed = 0 // HAND_MOTION_RANGE_UNOBSTRUCTED
        /// Conform to controller, if user closes their hands, the tracked data conforms to the shape of the controller.
        case conformToController = 1 // HAND_MOTION_RANGE_CONFORM_TO_CONTROLLER
        /// Maximum value for the motion range enum.
        case max = 2 // HAND_MOTION_RANGE_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .unobstructed: return ".unobstructed"
                case .conformToController: return ".conformToController"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum HandTrackedSource: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The source of hand tracking data is unknown (the extension is likely unsupported).
        case unknown = 0 // HAND_TRACKED_SOURCE_UNKNOWN
        /// The source of hand tracking is unobstructed, this means that an accurate method of hand tracking is used, e.g. optical hand tracking, data gloves, etc.
        case unobstructed = 1 // HAND_TRACKED_SOURCE_UNOBSTRUCTED
        /// The source of hand tracking is a controller, bone positions are inferred from controller inputs.
        case controller = 2 // HAND_TRACKED_SOURCE_CONTROLLER
        /// Maximum value for the hand tracked source enum.
        case max = 3 // HAND_TRACKED_SOURCE_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .unknown: return ".unknown"
                case .unobstructed: return ".unobstructed"
                case .controller: return ".controller"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public enum HandJoints: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Palm joint.
        case palm = 0 // HAND_JOINT_PALM
        /// Wrist joint.
        case wrist = 1 // HAND_JOINT_WRIST
        /// Thumb metacarpal joint.
        case thumbMetacarpal = 2 // HAND_JOINT_THUMB_METACARPAL
        /// Thumb proximal joint.
        case thumbProximal = 3 // HAND_JOINT_THUMB_PROXIMAL
        /// Thumb distal joint.
        case thumbDistal = 4 // HAND_JOINT_THUMB_DISTAL
        /// Thumb tip joint.
        case thumbTip = 5 // HAND_JOINT_THUMB_TIP
        /// Index metacarpal joint.
        case indexMetacarpal = 6 // HAND_JOINT_INDEX_METACARPAL
        /// Index proximal joint.
        case indexProximal = 7 // HAND_JOINT_INDEX_PROXIMAL
        /// Index intermediate joint.
        case indexIntermediate = 8 // HAND_JOINT_INDEX_INTERMEDIATE
        /// Index distal joint.
        case indexDistal = 9 // HAND_JOINT_INDEX_DISTAL
        /// Index tip joint.
        case indexTip = 10 // HAND_JOINT_INDEX_TIP
        /// Middle metacarpal joint.
        case middleMetacarpal = 11 // HAND_JOINT_MIDDLE_METACARPAL
        /// Middle proximal joint.
        case middleProximal = 12 // HAND_JOINT_MIDDLE_PROXIMAL
        /// Middle intermediate joint.
        case middleIntermediate = 13 // HAND_JOINT_MIDDLE_INTERMEDIATE
        /// Middle distal joint.
        case middleDistal = 14 // HAND_JOINT_MIDDLE_DISTAL
        /// Middle tip joint.
        case middleTip = 15 // HAND_JOINT_MIDDLE_TIP
        /// Ring metacarpal joint.
        case ringMetacarpal = 16 // HAND_JOINT_RING_METACARPAL
        /// Ring proximal joint.
        case ringProximal = 17 // HAND_JOINT_RING_PROXIMAL
        /// Ring intermediate joint.
        case ringIntermediate = 18 // HAND_JOINT_RING_INTERMEDIATE
        /// Ring distal joint.
        case ringDistal = 19 // HAND_JOINT_RING_DISTAL
        /// Ring tip joint.
        case ringTip = 20 // HAND_JOINT_RING_TIP
        /// Little metacarpal joint.
        case littleMetacarpal = 21 // HAND_JOINT_LITTLE_METACARPAL
        /// Little proximal joint.
        case littleProximal = 22 // HAND_JOINT_LITTLE_PROXIMAL
        /// Little intermediate joint.
        case littleIntermediate = 23 // HAND_JOINT_LITTLE_INTERMEDIATE
        /// Little distal joint.
        case littleDistal = 24 // HAND_JOINT_LITTLE_DISTAL
        /// Little tip joint.
        case littleTip = 25 // HAND_JOINT_LITTLE_TIP
        /// Maximum value for the hand joint enum.
        case max = 26 // HAND_JOINT_MAX
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .palm: return ".palm"
                case .wrist: return ".wrist"
                case .thumbMetacarpal: return ".thumbMetacarpal"
                case .thumbProximal: return ".thumbProximal"
                case .thumbDistal: return ".thumbDistal"
                case .thumbTip: return ".thumbTip"
                case .indexMetacarpal: return ".indexMetacarpal"
                case .indexProximal: return ".indexProximal"
                case .indexIntermediate: return ".indexIntermediate"
                case .indexDistal: return ".indexDistal"
                case .indexTip: return ".indexTip"
                case .middleMetacarpal: return ".middleMetacarpal"
                case .middleProximal: return ".middleProximal"
                case .middleIntermediate: return ".middleIntermediate"
                case .middleDistal: return ".middleDistal"
                case .middleTip: return ".middleTip"
                case .ringMetacarpal: return ".ringMetacarpal"
                case .ringProximal: return ".ringProximal"
                case .ringIntermediate: return ".ringIntermediate"
                case .ringDistal: return ".ringDistal"
                case .ringTip: return ".ringTip"
                case .littleMetacarpal: return ".littleMetacarpal"
                case .littleProximal: return ".littleProximal"
                case .littleIntermediate: return ".littleIntermediate"
                case .littleDistal: return ".littleDistal"
                case .littleTip: return ".littleTip"
                case .max: return ".max"
            }
            
        }
        
    }
    
    public struct HandJointFlags: OptionSet, CustomDebugStringConvertible {
        public let rawValue: Int
        public init (rawValue: Int) {
            self.rawValue = rawValue
        }
        
        /// If set, the orientation data is valid, otherwise, the orientation data is unreliable and should not be used.
        public static let orientationValid = HandJointFlags (rawValue: 1)
        /// If set, the orientation data comes from tracking data, otherwise, the orientation data contains predicted data.
        public static let orientationTracked = HandJointFlags (rawValue: 2)
        /// If set, the positional data is valid, otherwise, the positional data is unreliable and should not be used.
        public static let positionValid = HandJointFlags (rawValue: 4)
        /// If set, the positional data comes from tracking data, otherwise, the positional data contains predicted data.
        public static let positionTracked = HandJointFlags (rawValue: 8)
        /// If set, our linear velocity data is valid, otherwise, the linear velocity data is unreliable and should not be used.
        public static let linearVelocityValid = HandJointFlags (rawValue: 16)
        /// If set, our angular velocity data is valid, otherwise, the angular velocity data is unreliable and should not be used.
        public static let angularVelocityValid = HandJointFlags (rawValue: 32)
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            var result = ""
            if self.contains (.orientationValid) { result += "orientationValid, " }
            if self.contains (.orientationTracked) { result += "orientationTracked, " }
            if self.contains (.positionValid) { result += "positionValid, " }
            if self.contains (.positionTracked) { result += "positionTracked, " }
            if self.contains (.linearVelocityValid) { result += "linearVelocityValid, " }
            if self.contains (.angularVelocityValid) { result += "angularVelocityValid, " }
            if result.hasSuffix (", ") { result.removeLast (2) }
            return result
        }
        
    }
    
    
    /* Properties */
    
    /// The display refresh rate for the current HMD. Only functional if this feature is supported by the OpenXR runtime and after the interface has been initialized.
    final public var displayRefreshRate: Double {
        get {
            return get_display_refresh_rate ()
        }
        
        set {
            set_display_refresh_rate (newValue)
        }
        
    }
    
    /// The render size multiplier for the current HMD. Must be set before the interface has been initialized.
    final public var renderTargetSizeMultiplier: Double {
        get {
            return get_render_target_size_multiplier ()
        }
        
        set {
            set_render_target_size_multiplier (newValue)
        }
        
    }
    
    /// Set foveation level from 0 (off) to 3 (high), the interface must be initialized before this is accessible.
    /// 
    /// > Note: Only works on compatibility renderer.
    /// 
    final public var foveationLevel: Int32 {
        get {
            return get_foveation_level ()
        }
        
        set {
            set_foveation_level (newValue)
        }
        
    }
    
    /// Enable dynamic foveation adjustment, the interface must be initialized before this is accessible. If enabled foveation will automatically adjusted between low and ``foveationLevel``.
    /// 
    /// > Note: Only works on compatibility renderer.
    /// 
    final public var foveationDynamic: Bool {
        get {
            return get_foveation_dynamic ()
        }
        
        set {
            set_foveation_dynamic (newValue)
        }
        
    }
    
    /// The minimum radius around the focal point where full quality is guaranteed if VRS is used as a percentage of screen size.
    /// 
    /// > Note: Mobile and Forward+ renderers only. Requires ``Viewport/vrsMode`` to be set to ``Viewport/VRSMode/vrsXr``.
    /// 
    final public var vrsMinRadius: Double {
        get {
            return get_vrs_min_radius ()
        }
        
        set {
            set_vrs_min_radius (newValue)
        }
        
    }
    
    /// The strength used to calculate the VRS density map. The greater this value, the more noticeable VRS is. This improves performance at the cost of quality.
    /// 
    /// > Note: Mobile and Forward+ renderers only. Requires ``Viewport/vrsMode`` to be set to ``Viewport/VRSMode/vrsXr``.
    /// 
    final public var vrsStrength: Double {
        get {
            return get_vrs_strength ()
        }
        
        set {
            set_vrs_strength (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_get_display_refresh_rate: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_display_refresh_rate")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_display_refresh_rate() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(OpenXRInterface.method_get_display_refresh_rate, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_display_refresh_rate: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_display_refresh_rate")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_display_refresh_rate(_ refreshRate: Double) {
        withUnsafePointer(to: refreshRate) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(OpenXRInterface.method_set_display_refresh_rate, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_render_target_size_multiplier: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_render_target_size_multiplier")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_render_target_size_multiplier() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(OpenXRInterface.method_get_render_target_size_multiplier, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_render_target_size_multiplier: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_render_target_size_multiplier")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_render_target_size_multiplier(_ multiplier: Double) {
        withUnsafePointer(to: multiplier) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(OpenXRInterface.method_set_render_target_size_multiplier, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_foveation_supported: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_foveation_supported")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if OpenXR's foveation extension is supported, the interface must be initialized before this returns a valid value.
    /// 
    /// > Note: This feature is only available on the compatibility renderer and currently only available on some stand alone headsets. For Vulkan set ``Viewport/vrsMode`` to `VRS_XR` on desktop.
    /// 
    public final func isFoveationSupported() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(OpenXRInterface.method_is_foveation_supported, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_foveation_level: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_foveation_level")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_foveation_level() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(OpenXRInterface.method_get_foveation_level, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_foveation_level: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_foveation_level")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_foveation_level(_ foveationLevel: Int32) {
        withUnsafePointer(to: foveationLevel) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(OpenXRInterface.method_set_foveation_level, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_foveation_dynamic: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_foveation_dynamic")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_foveation_dynamic() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(OpenXRInterface.method_get_foveation_dynamic, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_foveation_dynamic: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_foveation_dynamic")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_foveation_dynamic(_ foveationDynamic: Bool) {
        withUnsafePointer(to: foveationDynamic) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(OpenXRInterface.method_set_foveation_dynamic, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_action_set_active: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_action_set_active")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3927539163)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the given action set is active.
    public final func isActionSetActive(name: String) -> Bool {
        var _result: Bool = false
        let name = GString(name)
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(OpenXRInterface.method_is_action_set_active, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_action_set_active: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_action_set_active")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2678287736)!
            }
            
        }
        
    }()
    
    /// Sets the given action set as active or inactive.
    public final func setActionSetActive(name: String, active: Bool) {
        let name = GString(name)
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: active) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(OpenXRInterface.method_set_action_set_active, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_action_sets: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_action_sets")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    /// Returns a list of action sets registered with Godot (loaded from the action map at runtime).
    public final func getActionSets() -> GArray {
        let _result: GArray = GArray ()
        gi.object_method_bind_ptrcall(OpenXRInterface.method_get_action_sets, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_get_available_display_refresh_rates: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_available_display_refresh_rates")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    /// Returns display refresh rates supported by the current HMD. Only returned if this feature is supported by the OpenXR runtime and after the interface has been initialized.
    public final func getAvailableDisplayRefreshRates() -> GArray {
        let _result: GArray = GArray ()
        gi.object_method_bind_ptrcall(OpenXRInterface.method_get_available_display_refresh_rates, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_motion_range: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_motion_range")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 855158159)!
            }
            
        }
        
    }()
    
    /// If handtracking is enabled and motion range is supported, sets the currently configured motion range for `hand` to `motionRange`.
    public final func setMotionRange(hand: OpenXRInterface.Hand, motionRange: OpenXRInterface.HandMotionRange) {
        withUnsafePointer(to: hand.rawValue) { pArg0 in
            withUnsafePointer(to: motionRange.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(OpenXRInterface.method_set_motion_range, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_motion_range: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_motion_range")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3955838114)!
            }
            
        }
        
    }()
    
    /// If handtracking is enabled and motion range is supported, gets the currently configured motion range for `hand`.
    public final func getMotionRange(hand: OpenXRInterface.Hand) -> OpenXRInterface.HandMotionRange {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: hand.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(OpenXRInterface.method_get_motion_range, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return OpenXRInterface.HandMotionRange (rawValue: _result)!
    }
    
    fileprivate static var method_get_hand_tracking_source: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_hand_tracking_source")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4092421202)!
            }
            
        }
        
    }()
    
    /// If handtracking is enabled and hand tracking source is supported, gets the source of the hand tracking data for `hand`.
    public final func getHandTrackingSource(hand: OpenXRInterface.Hand) -> OpenXRInterface.HandTrackedSource {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: hand.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(OpenXRInterface.method_get_hand_tracking_source, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return OpenXRInterface.HandTrackedSource (rawValue: _result)!
    }
    
    fileprivate static var method_get_hand_joint_flags: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_hand_joint_flags")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 720567706)!
            }
            
        }
        
    }()
    
    /// If handtracking is enabled, returns flags that inform us of the validity of the tracking data.
    public final func getHandJointFlags(hand: OpenXRInterface.Hand, joint: OpenXRInterface.HandJoints) -> OpenXRInterface.HandJointFlags {
        var _result: OpenXRInterface.HandJointFlags = OpenXRInterface.HandJointFlags ()
        withUnsafePointer(to: hand.rawValue) { pArg0 in
            withUnsafePointer(to: joint.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(OpenXRInterface.method_get_hand_joint_flags, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_hand_joint_rotation: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_hand_joint_rotation")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1974618321)!
            }
            
        }
        
    }()
    
    /// If handtracking is enabled, returns the rotation of a joint (`joint`) of a hand (`hand`) as provided by OpenXR.
    public final func getHandJointRotation(hand: OpenXRInterface.Hand, joint: OpenXRInterface.HandJoints) -> Quaternion {
        var _result: Quaternion = Quaternion ()
        withUnsafePointer(to: hand.rawValue) { pArg0 in
            withUnsafePointer(to: joint.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(OpenXRInterface.method_get_hand_joint_rotation, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_hand_joint_position: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_hand_joint_position")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3529194242)!
            }
            
        }
        
    }()
    
    /// If handtracking is enabled, returns the position of a joint (`joint`) of a hand (`hand`) as provided by OpenXR. This is relative to ``XROrigin3D`` without worldscale applied!
    public final func getHandJointPosition(hand: OpenXRInterface.Hand, joint: OpenXRInterface.HandJoints) -> Vector3 {
        var _result: Vector3 = Vector3 ()
        withUnsafePointer(to: hand.rawValue) { pArg0 in
            withUnsafePointer(to: joint.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(OpenXRInterface.method_get_hand_joint_position, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_hand_joint_radius: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_hand_joint_radius")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 901522724)!
            }
            
        }
        
    }()
    
    /// If handtracking is enabled, returns the radius of a joint (`joint`) of a hand (`hand`) as provided by OpenXR. This is without worldscale applied!
    public final func getHandJointRadius(hand: OpenXRInterface.Hand, joint: OpenXRInterface.HandJoints) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: hand.rawValue) { pArg0 in
            withUnsafePointer(to: joint.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(OpenXRInterface.method_get_hand_joint_radius, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_hand_joint_linear_velocity: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_hand_joint_linear_velocity")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3529194242)!
            }
            
        }
        
    }()
    
    /// If handtracking is enabled, returns the linear velocity of a joint (`joint`) of a hand (`hand`) as provided by OpenXR. This is relative to ``XROrigin3D`` without worldscale applied!
    public final func getHandJointLinearVelocity(hand: OpenXRInterface.Hand, joint: OpenXRInterface.HandJoints) -> Vector3 {
        var _result: Vector3 = Vector3 ()
        withUnsafePointer(to: hand.rawValue) { pArg0 in
            withUnsafePointer(to: joint.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(OpenXRInterface.method_get_hand_joint_linear_velocity, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_hand_joint_angular_velocity: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_hand_joint_angular_velocity")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3529194242)!
            }
            
        }
        
    }()
    
    /// If handtracking is enabled, returns the angular velocity of a joint (`joint`) of a hand (`hand`) as provided by OpenXR. This is relative to ``XROrigin3D``!
    public final func getHandJointAngularVelocity(hand: OpenXRInterface.Hand, joint: OpenXRInterface.HandJoints) -> Vector3 {
        var _result: Vector3 = Vector3 ()
        withUnsafePointer(to: hand.rawValue) { pArg0 in
            withUnsafePointer(to: joint.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(OpenXRInterface.method_get_hand_joint_angular_velocity, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_hand_tracking_supported: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_hand_tracking_supported")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    /// Returns `true` if OpenXR's hand tracking is supported and enabled.
    /// 
    /// > Note: This only returns a valid value after OpenXR has been initialized.
    /// 
    public final func isHandTrackingSupported() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(OpenXRInterface.method_is_hand_tracking_supported, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_is_hand_interaction_supported: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_hand_interaction_supported")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if OpenXR's hand interaction profile is supported and enabled.
    /// 
    /// > Note: This only returns a valid value after OpenXR has been initialized.
    /// 
    public final func isHandInteractionSupported() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(OpenXRInterface.method_is_hand_interaction_supported, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_is_eye_gaze_interaction_supported: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_eye_gaze_interaction_supported")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    /// Returns the capabilities of the eye gaze interaction extension.
    /// 
    /// > Note: This only returns a valid value after OpenXR has been initialized.
    /// 
    public final func isEyeGazeInteractionSupported() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(OpenXRInterface.method_is_eye_gaze_interaction_supported, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_vrs_min_radius: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_vrs_min_radius")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_vrs_min_radius() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(OpenXRInterface.method_get_vrs_min_radius, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_vrs_min_radius: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_vrs_min_radius")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_vrs_min_radius(_ radius: Double) {
        withUnsafePointer(to: radius) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(OpenXRInterface.method_set_vrs_min_radius, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_vrs_strength: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_vrs_strength")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_vrs_strength() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(OpenXRInterface.method_get_vrs_strength, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_vrs_strength: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_vrs_strength")
        return withUnsafePointer(to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_vrs_strength(_ strength: Double) {
        withUnsafePointer(to: strength) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(OpenXRInterface.method_set_vrs_strength, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    // Signals 
    /// Informs our OpenXR session has been started.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.sessionBegun.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var sessionBegun: SimpleSignal { SimpleSignal (target: self, signalName: "session_begun") }
    
    /// Informs our OpenXR session is stopping.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.sessionStopping.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var sessionStopping: SimpleSignal { SimpleSignal (target: self, signalName: "session_stopping") }
    
    /// Informs our OpenXR session now has focus.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.sessionFocussed.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var sessionFocussed: SimpleSignal { SimpleSignal (target: self, signalName: "session_focussed") }
    
    /// Informs our OpenXR session is now visible (output is being sent to the HMD).
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.sessionVisible.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var sessionVisible: SimpleSignal { SimpleSignal (target: self, signalName: "session_visible") }
    
    /// Informs our OpenXR session is in the process of being lost.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.sessionLossPending.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var sessionLossPending: SimpleSignal { SimpleSignal (target: self, signalName: "session_loss_pending") }
    
    /// Informs our OpenXR instance is exiting.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.instanceExiting.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var instanceExiting: SimpleSignal { SimpleSignal (target: self, signalName: "instance_exiting") }
    
    /// Informs the user queued a recenter of the player position.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.poseRecentered.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var poseRecentered: SimpleSignal { SimpleSignal (target: self, signalName: "pose_recentered") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ refreshRate: Double) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Double (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Informs the user the HMD refresh rate has changed.
    /// 
    /// **Node:** Only emitted if XR runtime supports the refresh rate extension.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.refreshRateChanged.connect { refreshRate in
    ///    print ("caught signal")
    /// }
    /// ```
    public var refreshRateChanged: Signal1 { Signal1 (target: self, signalName: "refresh_rate_changed") }
    
}

