// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
import Foundation
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A modal window used to display a list of options.
/// 
/// ``PopupMenu`` is a modal window used to display a list of options. Useful for toolbars and context menus.
/// 
/// The size of a ``PopupMenu`` can be limited by using ``Window/maxSize``. If the height of the list of items is larger than the maximum height of the ``PopupMenu``, a ``ScrollContainer`` within the popup will allow the user to scroll the contents. If no maximum size is set, or if it is set to `0`, the ``PopupMenu`` height will be limited by its parent rect.
/// 
/// All `set_*` methods allow negative item indices, i.e. `-1` to access the last item, `-2` to select the second-to-last item, and so on.
/// 
/// **Incremental search:** Like ``ItemList`` and ``Tree``, ``PopupMenu`` supports searching within the list while the control is focused. Press a key that matches the first letter of an item's name to select the first item starting with the given letter. After that point, there are two ways to perform incremental search: 1) Press the same key again before the timeout duration to select the next item starting with the same letter. 2) Press letter keys that match the rest of the word before the timeout duration to match to select the item in question directly. Both of these actions will be reset to the beginning of the list if the timeout duration has passed since the last keystroke was registered. You can adjust the timeout duration by changing ``ProjectSettings/gui/timers/incrementalSearchMaxIntervalMsec``.
/// 
/// > Note: The ID values used for items are limited to 32 bits, not full 64 bits of integer. This has a range of `-2^32` to `2^32 - 1`, i.e. `-2147483648` to `2147483647`.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``idPressed``
/// - ``idFocused``
/// - ``indexPressed``
/// - ``menuChanged``
open class PopupMenu: Popup {
    override open class var godotClassName: StringName { "PopupMenu" }
    
    /* Properties */
    
    /// If `true`, hides the ``PopupMenu`` when an item is selected.
    final public var hideOnItemSelection: Bool {
        get {
            return is_hide_on_item_selection ()
        }
        
        set {
            set_hide_on_item_selection (newValue)
        }
        
    }
    
    /// If `true`, hides the ``PopupMenu`` when a checkbox or radio button is selected.
    final public var hideOnCheckableItemSelection: Bool {
        get {
            return is_hide_on_checkable_item_selection ()
        }
        
        set {
            set_hide_on_checkable_item_selection (newValue)
        }
        
    }
    
    /// If `true`, hides the ``PopupMenu`` when a state item is selected.
    final public var hideOnStateItemSelection: Bool {
        get {
            return is_hide_on_state_item_selection ()
        }
        
        set {
            set_hide_on_state_item_selection (newValue)
        }
        
    }
    
    /// Sets the delay time in seconds for the submenu item to popup on mouse hovering. If the popup menu is added as a child of another (acting as a submenu), it will inherit the delay time of the parent menu item.
    final public var submenuPopupDelay: Double {
        get {
            return get_submenu_popup_delay ()
        }
        
        set {
            set_submenu_popup_delay (newValue)
        }
        
    }
    
    /// If `true`, allows navigating ``PopupMenu`` with letter keys.
    final public var allowSearch: Bool {
        get {
            return get_allow_search ()
        }
        
        set {
            set_allow_search (newValue)
        }
        
    }
    
    /// If set to one of the values of ``NativeMenu.SystemMenus``, this ``PopupMenu`` is bound to the special system menu. Only one ``PopupMenu`` can be bound to each special menu at a time.
    final public var systemMenuId: NativeMenu.SystemMenus {
        get {
            return get_system_menu ()
        }
        
        set {
            set_system_menu (newValue)
        }
        
    }
    
    /// If `true`, ``MenuBar`` will use native menu when supported.
    final public var preferNativeMenu: Bool {
        get {
            return is_prefer_native_menu ()
        }
        
        set {
            set_prefer_native_menu (newValue)
        }
        
    }
    
    /// The number of items currently in the list.
    final public var itemCount: Int32 {
        get {
            return get_item_count ()
        }
        
        set {
            set_item_count (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_activate_item_by_event: GDExtensionMethodBindPtr = {
        let methodName = StringName("activate_item_by_event")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3716412023)!
            }
            
        }
        
    }()
    
    /// Checks the provided `event` against the ``PopupMenu``'s shortcuts and accelerators, and activates the first item with matching events. If `forGlobalOnly` is `true`, only shortcuts and accelerators with `global` set to `true` will be called.
    /// 
    /// Returns `true` if an item was successfully activated.
    /// 
    /// > Note: Certain ``Control``s, such as ``MenuButton``, will call this method automatically.
    /// 
    public final func activateItemByEvent(_ event: InputEvent?, forGlobalOnly: Bool = false) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: event?.handle) { pArg0 in
            withUnsafePointer(to: forGlobalOnly) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(PopupMenu.method_activate_item_by_event, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_prefer_native_menu: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_prefer_native_menu")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_prefer_native_menu(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_set_prefer_native_menu, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_prefer_native_menu: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_prefer_native_menu")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_prefer_native_menu() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(PopupMenu.method_is_prefer_native_menu, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_add_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_item")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3674230041)!
            }
            
        }
        
    }()
    
    /// Adds a new item with text `label`.
    /// 
    /// An `id` can optionally be provided, as well as an accelerator (`accel`). If no `id` is provided, one will be created from the index. If no `accel` is provided, then the default value of 0 (corresponding to ``@GlobalScope.KEY_NONE``) will be assigned to the item (which means it won't have any accelerator). See ``getItemAccelerator(index:)`` for more info on accelerators.
    /// 
    /// > Note: The provided `id` is used only in [signal id_pressed] and [signal id_focused] signals. It's not related to the `index` arguments in e.g. ``setItemChecked(index:checked:)``.
    /// 
    public final func addItem(label: String, id: Int32 = -1, accel: Key = .none) {
        let label = GString(label)
        withUnsafePointer(to: label.content) { pArg0 in
            withUnsafePointer(to: id) { pArg1 in
                withUnsafePointer(to: accel.rawValue) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(PopupMenu.method_add_item, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_icon_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_icon_item")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1086190128)!
            }
            
        }
        
    }()
    
    /// Adds a new item with text `label` and icon `texture`.
    /// 
    /// An `id` can optionally be provided, as well as an accelerator (`accel`). If no `id` is provided, one will be created from the index. If no `accel` is provided, then the default value of 0 (corresponding to ``@GlobalScope.KEY_NONE``) will be assigned to the item (which means it won't have any accelerator). See ``getItemAccelerator(index:)`` for more info on accelerators.
    /// 
    public final func addIconItem(texture: Texture2D?, label: String, id: Int32 = -1, accel: Key = .none) {
        withUnsafePointer(to: texture?.handle) { pArg0 in
            let label = GString(label)
            withUnsafePointer(to: label.content) { pArg1 in
                withUnsafePointer(to: id) { pArg2 in
                    withUnsafePointer(to: accel.rawValue) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(PopupMenu.method_add_icon_item, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_check_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_check_item")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3674230041)!
            }
            
        }
        
    }()
    
    /// Adds a new checkable item with text `label`.
    /// 
    /// An `id` can optionally be provided, as well as an accelerator (`accel`). If no `id` is provided, one will be created from the index. If no `accel` is provided, then the default value of 0 (corresponding to ``@GlobalScope.KEY_NONE``) will be assigned to the item (which means it won't have any accelerator). See ``getItemAccelerator(index:)`` for more info on accelerators.
    /// 
    /// > Note: Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See ``setItemChecked(index:checked:)`` for more info on how to control it.
    /// 
    public final func addCheckItem(label: String, id: Int32 = -1, accel: Key = .none) {
        let label = GString(label)
        withUnsafePointer(to: label.content) { pArg0 in
            withUnsafePointer(to: id) { pArg1 in
                withUnsafePointer(to: accel.rawValue) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(PopupMenu.method_add_check_item, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_icon_check_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_icon_check_item")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1086190128)!
            }
            
        }
        
    }()
    
    /// Adds a new checkable item with text `label` and icon `texture`.
    /// 
    /// An `id` can optionally be provided, as well as an accelerator (`accel`). If no `id` is provided, one will be created from the index. If no `accel` is provided, then the default value of 0 (corresponding to ``@GlobalScope.KEY_NONE``) will be assigned to the item (which means it won't have any accelerator). See ``getItemAccelerator(index:)`` for more info on accelerators.
    /// 
    /// > Note: Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See ``setItemChecked(index:checked:)`` for more info on how to control it.
    /// 
    public final func addIconCheckItem(texture: Texture2D?, label: String, id: Int32 = -1, accel: Key = .none) {
        withUnsafePointer(to: texture?.handle) { pArg0 in
            let label = GString(label)
            withUnsafePointer(to: label.content) { pArg1 in
                withUnsafePointer(to: id) { pArg2 in
                    withUnsafePointer(to: accel.rawValue) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(PopupMenu.method_add_icon_check_item, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_radio_check_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_radio_check_item")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3674230041)!
            }
            
        }
        
    }()
    
    /// Adds a new radio check button with text `label`.
    /// 
    /// An `id` can optionally be provided, as well as an accelerator (`accel`). If no `id` is provided, one will be created from the index. If no `accel` is provided, then the default value of 0 (corresponding to ``@GlobalScope.KEY_NONE``) will be assigned to the item (which means it won't have any accelerator). See ``getItemAccelerator(index:)`` for more info on accelerators.
    /// 
    /// > Note: Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See ``setItemChecked(index:checked:)`` for more info on how to control it.
    /// 
    public final func addRadioCheckItem(label: String, id: Int32 = -1, accel: Key = .none) {
        let label = GString(label)
        withUnsafePointer(to: label.content) { pArg0 in
            withUnsafePointer(to: id) { pArg1 in
                withUnsafePointer(to: accel.rawValue) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(PopupMenu.method_add_radio_check_item, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_icon_radio_check_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_icon_radio_check_item")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1086190128)!
            }
            
        }
        
    }()
    
    /// Same as ``addIconCheckItem(texture:label:id:accel:)``, but uses a radio check button.
    public final func addIconRadioCheckItem(texture: Texture2D?, label: String, id: Int32 = -1, accel: Key = .none) {
        withUnsafePointer(to: texture?.handle) { pArg0 in
            let label = GString(label)
            withUnsafePointer(to: label.content) { pArg1 in
                withUnsafePointer(to: id) { pArg2 in
                    withUnsafePointer(to: accel.rawValue) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(PopupMenu.method_add_icon_radio_check_item, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_multistate_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_multistate_item")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 150780458)!
            }
            
        }
        
    }()
    
    /// Adds a new multistate item with text `label`.
    /// 
    /// Contrarily to normal binary items, multistate items can have more than two states, as defined by `maxStates`. The default value is defined by `defaultState`.
    /// 
    /// An `id` can optionally be provided, as well as an accelerator (`accel`). If no `id` is provided, one will be created from the index. If no `accel` is provided, then the default value of 0 (corresponding to ``@GlobalScope.KEY_NONE``) will be assigned to the item (which means it won't have any accelerator). See ``getItemAccelerator(index:)`` for more info on accelerators.
    /// 
    /// > Note: Multistate items don't update their state automatically and must be done manually. See ``toggleItemMultistate(index:)``, ``setItemMultistate(index:state:)`` and ``getItemMultistate(index:)`` for more info on how to control it.
    /// 
    /// Example usage:
    /// 
    public final func addMultistateItem(label: String, maxStates: Int32, defaultState: Int32 = 0, id: Int32 = -1, accel: Key = .none) {
        let label = GString(label)
        withUnsafePointer(to: label.content) { pArg0 in
            withUnsafePointer(to: maxStates) { pArg1 in
                withUnsafePointer(to: defaultState) { pArg2 in
                    withUnsafePointer(to: id) { pArg3 in
                        withUnsafePointer(to: accel.rawValue) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    gi.object_method_bind_ptrcall(PopupMenu.method_add_multistate_item, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_shortcut: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_shortcut")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3451850107)!
            }
            
        }
        
    }()
    
    /// Adds a ``Shortcut``.
    /// 
    /// An `id` can optionally be provided. If no `id` is provided, one will be created from the index.
    /// 
    /// If `allowEcho` is `true`, the shortcut can be activated with echo events.
    /// 
    public final func addShortcut(_ shortcut: Shortcut?, id: Int32 = -1, global: Bool = false, allowEcho: Bool = false) {
        withUnsafePointer(to: shortcut?.handle) { pArg0 in
            withUnsafePointer(to: id) { pArg1 in
                withUnsafePointer(to: global) { pArg2 in
                    withUnsafePointer(to: allowEcho) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(PopupMenu.method_add_shortcut, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_icon_shortcut: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_icon_shortcut")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2997871092)!
            }
            
        }
        
    }()
    
    /// Adds a new item and assigns the specified ``Shortcut`` and icon `texture` to it. Sets the label of the checkbox to the ``Shortcut``'s name.
    /// 
    /// An `id` can optionally be provided. If no `id` is provided, one will be created from the index.
    /// 
    /// If `allowEcho` is `true`, the shortcut can be activated with echo events.
    /// 
    public final func addIconShortcut(texture: Texture2D?, shortcut: Shortcut?, id: Int32 = -1, global: Bool = false, allowEcho: Bool = false) {
        withUnsafePointer(to: texture?.handle) { pArg0 in
            withUnsafePointer(to: shortcut?.handle) { pArg1 in
                withUnsafePointer(to: id) { pArg2 in
                    withUnsafePointer(to: global) { pArg3 in
                        withUnsafePointer(to: allowEcho) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    gi.object_method_bind_ptrcall(PopupMenu.method_add_icon_shortcut, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_check_shortcut: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_check_shortcut")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1642193386)!
            }
            
        }
        
    }()
    
    /// Adds a new checkable item and assigns the specified ``Shortcut`` to it. Sets the label of the checkbox to the ``Shortcut``'s name.
    /// 
    /// An `id` can optionally be provided. If no `id` is provided, one will be created from the index.
    /// 
    /// > Note: Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See ``setItemChecked(index:checked:)`` for more info on how to control it.
    /// 
    public final func addCheckShortcut(_ shortcut: Shortcut?, id: Int32 = -1, global: Bool = false) {
        withUnsafePointer(to: shortcut?.handle) { pArg0 in
            withUnsafePointer(to: id) { pArg1 in
                withUnsafePointer(to: global) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(PopupMenu.method_add_check_shortcut, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_icon_check_shortcut: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_icon_check_shortcut")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3856247530)!
            }
            
        }
        
    }()
    
    /// Adds a new checkable item and assigns the specified ``Shortcut`` and icon `texture` to it. Sets the label of the checkbox to the ``Shortcut``'s name.
    /// 
    /// An `id` can optionally be provided. If no `id` is provided, one will be created from the index.
    /// 
    /// > Note: Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See ``setItemChecked(index:checked:)`` for more info on how to control it.
    /// 
    public final func addIconCheckShortcut(texture: Texture2D?, shortcut: Shortcut?, id: Int32 = -1, global: Bool = false) {
        withUnsafePointer(to: texture?.handle) { pArg0 in
            withUnsafePointer(to: shortcut?.handle) { pArg1 in
                withUnsafePointer(to: id) { pArg2 in
                    withUnsafePointer(to: global) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(PopupMenu.method_add_icon_check_shortcut, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_radio_check_shortcut: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_radio_check_shortcut")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1642193386)!
            }
            
        }
        
    }()
    
    /// Adds a new radio check button and assigns a ``Shortcut`` to it. Sets the label of the checkbox to the ``Shortcut``'s name.
    /// 
    /// An `id` can optionally be provided. If no `id` is provided, one will be created from the index.
    /// 
    /// > Note: Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See ``setItemChecked(index:checked:)`` for more info on how to control it.
    /// 
    public final func addRadioCheckShortcut(_ shortcut: Shortcut?, id: Int32 = -1, global: Bool = false) {
        withUnsafePointer(to: shortcut?.handle) { pArg0 in
            withUnsafePointer(to: id) { pArg1 in
                withUnsafePointer(to: global) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(PopupMenu.method_add_radio_check_shortcut, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_icon_radio_check_shortcut: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_icon_radio_check_shortcut")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3856247530)!
            }
            
        }
        
    }()
    
    /// Same as ``addIconCheckShortcut(texture:shortcut:id:global:)``, but uses a radio check button.
    public final func addIconRadioCheckShortcut(texture: Texture2D?, shortcut: Shortcut?, id: Int32 = -1, global: Bool = false) {
        withUnsafePointer(to: texture?.handle) { pArg0 in
            withUnsafePointer(to: shortcut?.handle) { pArg1 in
                withUnsafePointer(to: id) { pArg2 in
                    withUnsafePointer(to: global) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(PopupMenu.method_add_icon_radio_check_shortcut, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_submenu_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_submenu_item")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2979222410)!
            }
            
        }
        
    }()
    
    /// Adds an item that will act as a submenu of the parent ``PopupMenu`` node when clicked. The `submenu` argument must be the name of an existing ``PopupMenu`` that has been added as a child to this node. This submenu will be shown when the item is clicked, hovered for long enough, or activated using the `ui_select` or `ui_right` input actions.
    /// 
    /// An `id` can optionally be provided. If no `id` is provided, one will be created from the index.
    /// 
    public final func addSubmenuItem(label: String, submenu: String, id: Int32 = -1) {
        let label = GString(label)
        withUnsafePointer(to: label.content) { pArg0 in
            let submenu = GString(submenu)
            withUnsafePointer(to: submenu.content) { pArg1 in
                withUnsafePointer(to: id) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(PopupMenu.method_add_submenu_item, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_submenu_node_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_submenu_node_item")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1325455216)!
            }
            
        }
        
    }()
    
    /// Adds an item that will act as a submenu of the parent ``PopupMenu`` node when clicked. This submenu will be shown when the item is clicked, hovered for long enough, or activated using the `ui_select` or `ui_right` input actions.
    /// 
    /// `submenu` must be either child of this ``PopupMenu`` or has no parent node (in which case it will be automatically added as a child). If the `submenu` popup has another parent, this method will fail.
    /// 
    /// An `id` can optionally be provided. If no `id` is provided, one will be created from the index.
    /// 
    public final func addSubmenuNodeItem(label: String, submenu: PopupMenu?, id: Int32 = -1) {
        let label = GString(label)
        withUnsafePointer(to: label.content) { pArg0 in
            withUnsafePointer(to: submenu?.handle) { pArg1 in
                withUnsafePointer(to: id) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(PopupMenu.method_add_submenu_node_item, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_text: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_text")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 501894301)!
            }
            
        }
        
    }()
    
    /// Sets the text of the item at the given `index`.
    public final func setItemText(index: Int32, text: String) {
        withUnsafePointer(to: index) { pArg0 in
            let text = GString(text)
            withUnsafePointer(to: text.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(PopupMenu.method_set_item_text, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_text_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_text_direction")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1707680378)!
            }
            
        }
        
    }()
    
    /// Sets item's text base writing direction.
    public final func setItemTextDirection(index: Int32, direction: Control.TextDirection) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: direction.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(PopupMenu.method_set_item_text_direction, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_language: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_language")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 501894301)!
            }
            
        }
        
    }()
    
    /// Sets language code of item's text used for line-breaking and text shaping algorithms, if left empty current locale is used instead.
    public final func setItemLanguage(index: Int32, language: String) {
        withUnsafePointer(to: index) { pArg0 in
            let language = GString(language)
            withUnsafePointer(to: language.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(PopupMenu.method_set_item_language, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_icon")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 666127730)!
            }
            
        }
        
    }()
    
    /// Replaces the ``Texture2D`` icon of the item at the given `index`.
    public final func setItemIcon(index: Int32, icon: Texture2D?) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: icon?.handle) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(PopupMenu.method_set_item_icon, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_icon_max_width: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_icon_max_width")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Sets the maximum allowed width of the icon for the item at the given `index`. This limit is applied on top of the default size of the icon and on top of [theme_item icon_max_width]. The height is adjusted according to the icon's ratio.
    public final func setItemIconMaxWidth(index: Int32, width: Int32) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: width) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(PopupMenu.method_set_item_icon_max_width, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_icon_modulate: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_icon_modulate")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2878471219)!
            }
            
        }
        
    }()
    
    /// Sets a modulating ``Color`` of the item's icon at the given `index`.
    public final func setItemIconModulate(index: Int32, modulate: Color) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: modulate) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(PopupMenu.method_set_item_icon_modulate, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_checked: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_checked")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Sets the checkstate status of the item at the given `index`.
    public final func setItemChecked(index: Int32, checked: Bool) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: checked) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(PopupMenu.method_set_item_checked, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_id: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_id")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Sets the `id` of the item at the given `index`.
    /// 
    /// The `id` is used in [signal id_pressed] and [signal id_focused] signals.
    /// 
    public final func setItemId(index: Int32, id: Int32) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: id) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(PopupMenu.method_set_item_id, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_accelerator: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_accelerator")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2992817551)!
            }
            
        }
        
    }()
    
    /// Sets the accelerator of the item at the given `index`. An accelerator is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. `accel` is generally a combination of ``KeyModifierMask``s and ``Key``s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` ([kbd]Ctrl + A[/kbd]).
    public final func setItemAccelerator(index: Int32, accel: Key) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: accel.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(PopupMenu.method_set_item_accelerator, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_metadata: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_metadata")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2152698145)!
            }
            
        }
        
    }()
    
    /// Sets the metadata of an item, which may be of any type. You can later get it with ``getItemMetadata(index:)``, which provides a simple way of assigning context data to items.
    public final func setItemMetadata(index: Int32, metadata: Variant) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: metadata.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(PopupMenu.method_set_item_metadata, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_disabled")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Enables/disables the item at the given `index`. When it is disabled, it can't be selected and its action can't be invoked.
    public final func setItemDisabled(index: Int32, disabled: Bool) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: disabled) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(PopupMenu.method_set_item_disabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_submenu: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_submenu")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 501894301)!
            }
            
        }
        
    }()
    
    /// Sets the submenu of the item at the given `index`. The submenu is the name of a child ``PopupMenu`` node that would be shown when the item is clicked.
    public final func setItemSubmenu(index: Int32, submenu: String) {
        withUnsafePointer(to: index) { pArg0 in
            let submenu = GString(submenu)
            withUnsafePointer(to: submenu.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(PopupMenu.method_set_item_submenu, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_submenu_node: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_submenu_node")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1068370740)!
            }
            
        }
        
    }()
    
    /// Sets the submenu of the item at the given `index`. The submenu is a ``PopupMenu`` node that would be shown when the item is clicked. It must either be a child of this ``PopupMenu`` or has no parent (in which case it will be automatically added as a child). If the `submenu` popup has another parent, this method will fail.
    public final func setItemSubmenuNode(index: Int32, submenu: PopupMenu?) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: submenu?.handle) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(PopupMenu.method_set_item_submenu_node, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_as_separator: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_as_separator")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Mark the item at the given `index` as a separator, which means that it would be displayed as a line. If `false`, sets the type of the item to plain text.
    public final func setItemAsSeparator(index: Int32, enable: Bool) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: enable) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(PopupMenu.method_set_item_as_separator, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_as_checkable: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_as_checkable")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Sets whether the item at the given `index` has a checkbox. If `false`, sets the type of the item to plain text.
    /// 
    /// > Note: Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually.
    /// 
    public final func setItemAsCheckable(index: Int32, enable: Bool) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: enable) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(PopupMenu.method_set_item_as_checkable, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_as_radio_checkable: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_as_radio_checkable")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Sets the type of the item at the given `index` to radio button. If `false`, sets the type of the item to plain text.
    public final func setItemAsRadioCheckable(index: Int32, enable: Bool) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: enable) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(PopupMenu.method_set_item_as_radio_checkable, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_tooltip: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_tooltip")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 501894301)!
            }
            
        }
        
    }()
    
    /// Sets the ``String`` tooltip of the item at the given `index`.
    public final func setItemTooltip(index: Int32, tooltip: String) {
        withUnsafePointer(to: index) { pArg0 in
            let tooltip = GString(tooltip)
            withUnsafePointer(to: tooltip.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(PopupMenu.method_set_item_tooltip, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_shortcut: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_shortcut")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 825127832)!
            }
            
        }
        
    }()
    
    /// Sets a ``Shortcut`` for the item at the given `index`.
    public final func setItemShortcut(index: Int32, shortcut: Shortcut?, global: Bool = false) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: shortcut?.handle) { pArg1 in
                withUnsafePointer(to: global) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(PopupMenu.method_set_item_shortcut, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_indent: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_indent")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Sets the horizontal offset of the item at the given `index`.
    public final func setItemIndent(index: Int32, indent: Int32) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: indent) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(PopupMenu.method_set_item_indent, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_multistate: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_multistate")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Sets the state of a multistate item. See ``addMultistateItem(label:maxStates:defaultState:id:accel:)`` for details.
    public final func setItemMultistate(index: Int32, state: Int32) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: state) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(PopupMenu.method_set_item_multistate, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_multistate_max: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_multistate_max")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Sets the max states of a multistate item. See ``addMultistateItem(label:maxStates:defaultState:id:accel:)`` for details.
    public final func setItemMultistateMax(index: Int32, maxStates: Int32) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: maxStates) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(PopupMenu.method_set_item_multistate_max, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_item_shortcut_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_shortcut_disabled")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Disables the ``Shortcut`` of the item at the given `index`.
    public final func setItemShortcutDisabled(index: Int32, disabled: Bool) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: disabled) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(PopupMenu.method_set_item_shortcut_disabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_toggle_item_checked: GDExtensionMethodBindPtr = {
        let methodName = StringName("toggle_item_checked")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Toggles the check state of the item at the given `index`.
    public final func toggleItemChecked(index: Int32) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_toggle_item_checked, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_toggle_item_multistate: GDExtensionMethodBindPtr = {
        let methodName = StringName("toggle_item_multistate")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Cycle to the next state of a multistate item. See ``addMultistateItem(label:maxStates:defaultState:id:accel:)`` for details.
    public final func toggleItemMultistate(index: Int32) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_toggle_item_multistate, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_item_text: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_text")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns the text of the item at the given `index`.
    public final func getItemText(index: Int32) -> String {
        let _result = GString ()
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_get_item_text, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_get_item_text_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_text_direction")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4235602388)!
            }
            
        }
        
    }()
    
    /// Returns item's text base writing direction.
    public final func getItemTextDirection(index: Int32) -> Control.TextDirection {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_get_item_text_direction, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return Control.TextDirection (rawValue: _result)!
    }
    
    fileprivate static var method_get_item_language: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_language")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns item's text language code.
    public final func getItemLanguage(index: Int32) -> String {
        let _result = GString ()
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_get_item_language, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_get_item_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_icon")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3536238170)!
            }
            
        }
        
    }()
    
    /// Returns the icon of the item at the given `index`.
    public final func getItemIcon(index: Int32) -> Texture2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_get_item_icon, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_item_icon_max_width: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_icon_max_width")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the maximum allowed width of the icon for the item at the given `index`.
    public final func getItemIconMaxWidth(index: Int32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_get_item_icon_max_width, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_item_icon_modulate: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_icon_modulate")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3457211756)!
            }
            
        }
        
    }()
    
    /// Returns a ``Color`` modulating the item's icon at the given `index`.
    public final func getItemIconModulate(index: Int32) -> Color {
        var _result: Color = Color ()
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_get_item_icon_modulate, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_item_checked: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_item_checked")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the item at the given `index` is checked.
    public final func isItemChecked(index: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_is_item_checked, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_item_id: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_id")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the ID of the item at the given `index`. `id` can be manually assigned, while index can not.
    public final func getItemId(index: Int32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_get_item_id, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_item_index: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_index")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the index of the item containing the specified `id`. Index is automatically assigned to each item by the engine and can not be set manually.
    public final func getItemIndex(id: Int32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: id) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_get_item_index, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_item_accelerator: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_accelerator")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 253789942)!
            }
            
        }
        
    }()
    
    /// Returns the accelerator of the item at the given `index`. An accelerator is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The return value is an integer which is generally a combination of ``KeyModifierMask``s and ``Key``s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` ([kbd]Ctrl + A[/kbd]). If no accelerator is defined for the specified `index`, ``getItemAccelerator(index:)`` returns `0` (corresponding to ``@GlobalScope.KEY_NONE``).
    public final func getItemAccelerator(index: Int32) -> Key {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_get_item_accelerator, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return Key (rawValue: _result)!
    }
    
    fileprivate static var method_get_item_metadata: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_metadata")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4227898402)!
            }
            
        }
        
    }()
    
    /// Returns the metadata of the specified item, which might be of any type. You can set it with ``setItemMetadata(index:metadata:)``, which provides a simple way of assigning context data to items.
    public final func getItemMetadata(index: Int32) -> Variant {
        let _result: Variant = Variant ()
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_get_item_metadata, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_item_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_item_disabled")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the item at the given `index` is disabled. When it is disabled it can't be selected, or its action invoked.
    /// 
    /// See ``setItemDisabled(index:disabled:)`` for more info on how to disable an item.
    /// 
    public final func isItemDisabled(index: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_is_item_disabled, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_item_submenu: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_submenu")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns the submenu name of the item at the given `index`. See ``addSubmenuItem(label:submenu:id:)`` for more info on how to add a submenu.
    public final func getItemSubmenu(index: Int32) -> String {
        let _result = GString ()
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_get_item_submenu, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_get_item_submenu_node: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_submenu_node")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2100501353)!
            }
            
        }
        
    }()
    
    /// Returns the submenu of the item at the given `index`, or `null` if no submenu was added. See ``addSubmenuNodeItem(label:submenu:id:)`` for more info on how to add a submenu.
    public final func getItemSubmenuNode(index: Int32) -> PopupMenu? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_get_item_submenu_node, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_is_item_separator: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_item_separator")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the item is a separator. If it is, it will be displayed as a line. See ``addSeparator(label:id:)`` for more info on how to add a separator.
    public final func isItemSeparator(index: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_is_item_separator, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_item_checkable: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_item_checkable")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the item at the given `index` is checkable in some way, i.e. if it has a checkbox or radio button.
    /// 
    /// > Note: Checkable items just display a checkmark or radio button, but don't have any built-in checking behavior and must be checked/unchecked manually.
    /// 
    public final func isItemCheckable(index: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_is_item_checkable, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_item_radio_checkable: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_item_radio_checkable")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the item at the given `index` has radio button-style checkability.
    /// 
    /// > Note: This is purely cosmetic; you must add the logic for checking/unchecking items in radio groups.
    /// 
    public final func isItemRadioCheckable(index: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_is_item_radio_checkable, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_item_shortcut_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_item_shortcut_disabled")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the specified item's shortcut is disabled.
    public final func isItemShortcutDisabled(index: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_is_item_shortcut_disabled, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_item_tooltip: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_tooltip")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns the tooltip associated with the item at the given `index`.
    public final func getItemTooltip(index: Int32) -> String {
        let _result = GString ()
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_get_item_tooltip, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result.description
    }
    
    fileprivate static var method_get_item_shortcut: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_shortcut")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1449483325)!
            }
            
        }
        
    }()
    
    /// Returns the ``Shortcut`` associated with the item at the given `index`.
    public final func getItemShortcut(index: Int32) -> Shortcut? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_get_item_shortcut, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_item_indent: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_indent")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the horizontal offset of the item at the given `index`.
    public final func getItemIndent(index: Int32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_get_item_indent, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_item_multistate_max: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_multistate_max")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the max states of the item at the given `index`.
    public final func getItemMultistateMax(index: Int32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_get_item_multistate_max, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_item_multistate: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_multistate")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the state of the item at the given `index`.
    public final func getItemMultistate(index: Int32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_get_item_multistate, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_focused_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_focused_item")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Sets the currently focused item as the given `index`.
    /// 
    /// Passing `-1` as the index makes so that no item is focused.
    /// 
    public final func setFocusedItem(index: Int32) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_set_focused_item, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_focused_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_focused_item")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the index of the currently focused item. Returns `-1` if no item is focused.
    public final func getFocusedItem() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(PopupMenu.method_get_focused_item, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_item_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_item_count")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_item_count(_ count: Int32) {
        withUnsafePointer(to: count) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_set_item_count, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_item_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_item_count")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_item_count() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(PopupMenu.method_get_item_count, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_scroll_to_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("scroll_to_item")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Moves the scroll view to make the item at the given `index` visible.
    public final func scrollToItem(index: Int32) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_scroll_to_item, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_remove_item: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_item")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Removes the item at the given `index` from the menu.
    /// 
    /// > Note: The indices of items after the removed item will be shifted by one.
    /// 
    public final func removeItem(index: Int32) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_remove_item, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_separator: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_separator")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2266703459)!
            }
            
        }
        
    }()
    
    /// Adds a separator between items. Separators also occupy an index, which you can set by using the `id` parameter.
    /// 
    /// A `label` can optionally be provided, which will appear at the center of the separator.
    /// 
    public final func addSeparator(label: String = "", id: Int32 = -1) {
        let label = GString(label)
        withUnsafePointer(to: label.content) { pArg0 in
            withUnsafePointer(to: id) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(PopupMenu.method_add_separator, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 107499316)!
            }
            
        }
        
    }()
    
    /// Removes all items from the ``PopupMenu``. If `freeSubmenus` is `true`, the submenu nodes are automatically freed.
    public final func clear(freeSubmenus: Bool = false) {
        withUnsafePointer(to: freeSubmenus) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_clear, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_hide_on_item_selection: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_hide_on_item_selection")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_hide_on_item_selection(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_set_hide_on_item_selection, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_hide_on_item_selection: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_hide_on_item_selection")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_hide_on_item_selection() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(PopupMenu.method_is_hide_on_item_selection, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_hide_on_checkable_item_selection: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_hide_on_checkable_item_selection")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_hide_on_checkable_item_selection(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_set_hide_on_checkable_item_selection, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_hide_on_checkable_item_selection: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_hide_on_checkable_item_selection")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_hide_on_checkable_item_selection() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(PopupMenu.method_is_hide_on_checkable_item_selection, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_hide_on_state_item_selection: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_hide_on_state_item_selection")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_hide_on_state_item_selection(_ enable: Bool) {
        withUnsafePointer(to: enable) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_set_hide_on_state_item_selection, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_hide_on_state_item_selection: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_hide_on_state_item_selection")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_hide_on_state_item_selection() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(PopupMenu.method_is_hide_on_state_item_selection, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_submenu_popup_delay: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_submenu_popup_delay")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_submenu_popup_delay(_ seconds: Double) {
        withUnsafePointer(to: seconds) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_set_submenu_popup_delay, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_submenu_popup_delay: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_submenu_popup_delay")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_submenu_popup_delay() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(PopupMenu.method_get_submenu_popup_delay, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_allow_search: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_allow_search")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_allow_search(_ allow: Bool) {
        withUnsafePointer(to: allow) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_set_allow_search, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_allow_search: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_allow_search")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_allow_search() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(PopupMenu.method_get_allow_search, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_is_system_menu: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_system_menu")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the menu is bound to the special system menu.
    public final func isSystemMenu() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(PopupMenu.method_is_system_menu, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_system_menu: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_system_menu")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 600639674)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_system_menu(_ systemMenuId: NativeMenu.SystemMenus) {
        withUnsafePointer(to: systemMenuId.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(PopupMenu.method_set_system_menu, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_system_menu: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_system_menu")
        return withUnsafePointer(to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1222557358)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_system_menu() -> NativeMenu.SystemMenus {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(PopupMenu.method_get_system_menu, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return NativeMenu.SystemMenus (rawValue: _result)!
    }
    
    // Signals 
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ id: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when an item of some `id` is pressed or its accelerator is activated.
    /// 
    /// > Note: If `id` is negative (either explicitly or due to overflow), this will return the corresponding index instead.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.idPressed.connect { id in
    ///    print ("caught signal")
    /// }
    /// ```
    public var idPressed: Signal1 { Signal1 (target: self, signalName: "id_pressed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ id: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the user navigated to an item of some `id` using the ``ProjectSettings/input/uiUp`` or ``ProjectSettings/input/uiDown`` input action.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.idFocused.connect { id in
    ///    print ("caught signal")
    /// }
    /// ```
    public var idFocused: Signal2 { Signal2 (target: self, signalName: "id_focused") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal3/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal3/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal3/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal3 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal3 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ index: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when an item of some `index` is pressed or its accelerator is activated.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.indexPressed.connect { index in
    ///    print ("caught signal")
    /// }
    /// ```
    public var indexPressed: Signal3 { Signal3 (target: self, signalName: "index_pressed") }
    
    /// Emitted when any item is added, modified or removed.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.menuChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var menuChanged: SimpleSignal { SimpleSignal (target: self, signalName: "menu_changed") }
    
}

