// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
import Foundation
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Holds data that can be used to animate anything in the engine.
/// 
/// This resource holds data that can be used to animate anything in the engine. Animations are divided into tracks and each track must be linked to a node. The state of that node can be changed through time, by adding timed keys (events) to the track.
/// 
/// Animations are just data containers, and must be added to nodes such as an ``AnimationPlayer`` to be played back. Animation tracks have different types, each with its own set of dedicated methods. Check ``Animation/TrackType`` to see available types.
/// 
/// > Note: For 3D position/rotation/scale, using the dedicated .typePosition3d, .typeRotation3d and .typeScale3d track types instead of .typeValue is recommended for performance reasons.
/// 
open class Animation: Resource {
    override open class var godotClassName: StringName { "Animation" }
    public enum TrackType: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Value tracks set values in node properties, but only those which can be interpolated. For 3D position/rotation/scale, using the dedicated .typePosition3d, .typeRotation3d and .typeScale3d track types instead of .typeValue is recommended for performance reasons.
        case value = 0 // TYPE_VALUE
        /// 3D position track (values are stored in ``Vector3``s).
        case position3d = 1 // TYPE_POSITION_3D
        /// 3D rotation track (values are stored in ``Quaternion``s).
        case rotation3d = 2 // TYPE_ROTATION_3D
        /// 3D scale track (values are stored in ``Vector3``s).
        case scale3d = 3 // TYPE_SCALE_3D
        /// Blend shape track.
        case blendShape = 4 // TYPE_BLEND_SHAPE
        /// Method tracks call functions with given arguments per key.
        case method = 5 // TYPE_METHOD
        /// Bezier tracks are used to interpolate a value using custom curves. They can also be used to animate sub-properties of vectors and colors (e.g. alpha value of a ``Color``).
        case bezier = 6 // TYPE_BEZIER
        /// Audio tracks are used to play an audio stream with either type of ``AudioStreamPlayer``. The stream can be trimmed and previewed in the animation.
        case audio = 7 // TYPE_AUDIO
        /// Animation tracks play animations in other ``AnimationPlayer`` nodes.
        case animation = 8 // TYPE_ANIMATION
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .value: return ".value"
                case .position3d: return ".position3d"
                case .rotation3d: return ".rotation3d"
                case .scale3d: return ".scale3d"
                case .blendShape: return ".blendShape"
                case .method: return ".method"
                case .bezier: return ".bezier"
                case .audio: return ".audio"
                case .animation: return ".animation"
            }
            
        }
        
    }
    
    public enum InterpolationType: Int64, CaseIterable, CustomDebugStringConvertible {
        /// No interpolation (nearest value).
        case nearest = 0 // INTERPOLATION_NEAREST
        /// Linear interpolation.
        case linear = 1 // INTERPOLATION_LINEAR
        /// Cubic interpolation. This looks smoother than linear interpolation, but is more expensive to interpolate. Stick to .interpolationLinear for complex 3D animations imported from external software, even if it requires using a higher animation framerate in return.
        case cubic = 2 // INTERPOLATION_CUBIC
        /// Linear interpolation with shortest path rotation.
        /// 
        /// > Note: The result value is always normalized and may not match the key value.
        /// 
        case linearAngle = 3 // INTERPOLATION_LINEAR_ANGLE
        /// Cubic interpolation with shortest path rotation.
        /// 
        /// > Note: The result value is always normalized and may not match the key value.
        /// 
        case cubicAngle = 4 // INTERPOLATION_CUBIC_ANGLE
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .nearest: return ".nearest"
                case .linear: return ".linear"
                case .cubic: return ".cubic"
                case .linearAngle: return ".linearAngle"
                case .cubicAngle: return ".cubicAngle"
            }
            
        }
        
    }
    
    public enum UpdateMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Update between keyframes and hold the value.
        case continuous = 0 // UPDATE_CONTINUOUS
        /// Update at the keyframes.
        case discrete = 1 // UPDATE_DISCRETE
        /// Same as .updateContinuous but works as a flag to capture the value of the current object and perform interpolation in some methods. See also ``AnimationMixer/capture(name:duration:transType:easeType:)``, ``AnimationPlayer/playbackAutoCapture``, and ``AnimationPlayer/playWithCapture(name:duration:customBlend:customSpeed:fromEnd:transType:easeType:)``.
        case capture = 2 // UPDATE_CAPTURE
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .continuous: return ".continuous"
                case .discrete: return ".discrete"
                case .capture: return ".capture"
            }
            
        }
        
    }
    
    public enum LoopMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// At both ends of the animation, the animation will stop playing.
        case none = 0 // LOOP_NONE
        /// At both ends of the animation, the animation will be repeated without changing the playback direction.
        case linear = 1 // LOOP_LINEAR
        /// Repeats playback and reverse playback at both ends of the animation.
        case pingpong = 2 // LOOP_PINGPONG
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .none: return ".none"
                case .linear: return ".linear"
                case .pingpong: return ".pingpong"
            }
            
        }
        
    }
    
    public enum LoopedFlag: Int64, CaseIterable, CustomDebugStringConvertible {
        /// This flag indicates that the animation proceeds without any looping.
        case none = 0 // LOOPED_FLAG_NONE
        /// This flag indicates that the animation has reached the end of the animation and just after loop processed.
        case end = 1 // LOOPED_FLAG_END
        /// This flag indicates that the animation has reached the start of the animation and just after loop processed.
        case start = 2 // LOOPED_FLAG_START
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .none: return ".none"
                case .end: return ".end"
                case .start: return ".start"
            }
            
        }
        
    }
    
    public enum FindMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Finds the nearest time key.
        case nearest = 0 // FIND_MODE_NEAREST
        /// Finds only the key with approximating the time.
        case approx = 1 // FIND_MODE_APPROX
        /// Finds only the key with matching the time.
        case exact = 2 // FIND_MODE_EXACT
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .nearest: return ".nearest"
                case .approx: return ".approx"
                case .exact: return ".exact"
            }
            
        }
        
    }
    
    
    /* Properties */
    
    /// The total length of the animation (in seconds).
    /// 
    /// > Note: Length is not delimited by the last key, as this one may be before or after the end to ensure correct interpolation and looping.
    /// 
    final public var length: Double {
        get {
            return get_length ()
        }
        
        set {
            set_length (newValue)
        }
        
    }
    
    /// Determines the behavior of both ends of the animation timeline during animation playback. This is used for correct interpolation of animation cycles, and for hinting the player that it must restart the animation.
    final public var loopMode: Animation.LoopMode {
        get {
            return get_loop_mode ()
        }
        
        set {
            set_loop_mode (newValue)
        }
        
    }
    
    /// The animation step value.
    final public var step: Double {
        get {
            return get_step ()
        }
        
        set {
            set_step (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_add_track: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_track")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3843682357)!
            }
            
        }
        
    }()
    
    /// Adds a track to the Animation.
    public final func addTrack(type: Animation.TrackType, atPosition: Int32 = -1) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: type.rawValue) { pArg0 in
            withUnsafePointer(to: atPosition) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_add_track, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_remove_track: GDExtensionMethodBindPtr = {
        let methodName = StringName("remove_track")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Removes a track by specifying the track index.
    public final func removeTrack(trackIdx: Int32) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Animation.method_remove_track, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_track_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_track_count")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the amount of tracks in the animation.
    public final func getTrackCount() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(Animation.method_get_track_count, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_track_get_type: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_get_type")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3445944217)!
            }
            
        }
        
    }()
    
    /// Gets the type of a track.
    public final func trackGetType(trackIdx: Int32) -> Animation.TrackType {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Animation.method_track_get_type, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return Animation.TrackType (rawValue: _result)!
    }
    
    fileprivate static var method_track_get_path: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_get_path")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 408788394)!
            }
            
        }
        
    }()
    
    /// Gets the path of a track. For more information on the path format, see ``trackSetPath(trackIdx:path:)``.
    public final func trackGetPath(trackIdx: Int32) -> NodePath {
        let _result: NodePath = NodePath ()
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Animation.method_track_get_path, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_track_set_path: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_set_path")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2761262315)!
            }
            
        }
        
    }()
    
    /// Sets the path of a track. Paths must be valid scene-tree paths to a node and must be specified starting from the parent node of the node that will reproduce the animation. Tracks that control properties or bones must append their name after the path, separated by `":"`.
    /// 
    /// For example, `"character/skeleton:ankle"` or `"character/mesh:transform/local"`.
    /// 
    public final func trackSetPath(trackIdx: Int32, path: NodePath) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: path.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_track_set_path, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_find_track: GDExtensionMethodBindPtr = {
        let methodName = StringName("find_track")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 245376003)!
            }
            
        }
        
    }()
    
    /// Returns the index of the specified track. If the track is not found, return -1.
    public final func findTrack(path: NodePath, type: Animation.TrackType) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: path.content) { pArg0 in
            withUnsafePointer(to: type.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_find_track, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_track_move_up: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_move_up")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Moves a track up.
    public final func trackMoveUp(trackIdx: Int32) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Animation.method_track_move_up, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_track_move_down: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_move_down")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Moves a track down.
    public final func trackMoveDown(trackIdx: Int32) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Animation.method_track_move_down, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_track_move_to: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_move_to")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Changes the index position of track `trackIdx` to the one defined in `toIdx`.
    public final func trackMoveTo(trackIdx: Int32, toIdx: Int32) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: toIdx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_track_move_to, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_track_swap: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_swap")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Swaps the track `trackIdx`'s index position with the track `withIdx`.
    public final func trackSwap(trackIdx: Int32, withIdx: Int32) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: withIdx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_track_swap, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_track_set_imported: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_set_imported")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Sets the given track as imported or not.
    public final func trackSetImported(trackIdx: Int32, imported: Bool) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: imported) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_track_set_imported, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_track_is_imported: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_is_imported")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the given track is imported. Else, return `false`.
    public final func trackIsImported(trackIdx: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Animation.method_track_is_imported, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_track_set_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_set_enabled")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Enables/disables the given track. Tracks are enabled by default.
    public final func trackSetEnabled(trackIdx: Int32, enabled: Bool) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: enabled) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_track_set_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_track_is_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_is_enabled")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the track at index `trackIdx` is enabled.
    public final func trackIsEnabled(trackIdx: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Animation.method_track_is_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_position_track_insert_key: GDExtensionMethodBindPtr = {
        let methodName = StringName("position_track_insert_key")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2540608232)!
            }
            
        }
        
    }()
    
    /// Inserts a key in a given 3D position track. Returns the key index.
    public final func positionTrackInsertKey(trackIdx: Int32, time: Double, position: Vector3) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: time) { pArg1 in
                withUnsafePointer(to: position) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Animation.method_position_track_insert_key, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_rotation_track_insert_key: GDExtensionMethodBindPtr = {
        let methodName = StringName("rotation_track_insert_key")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4165004800)!
            }
            
        }
        
    }()
    
    /// Inserts a key in a given 3D rotation track. Returns the key index.
    public final func rotationTrackInsertKey(trackIdx: Int32, time: Double, rotation: Quaternion) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: time) { pArg1 in
                withUnsafePointer(to: rotation) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Animation.method_rotation_track_insert_key, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_scale_track_insert_key: GDExtensionMethodBindPtr = {
        let methodName = StringName("scale_track_insert_key")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2540608232)!
            }
            
        }
        
    }()
    
    /// Inserts a key in a given 3D scale track. Returns the key index.
    public final func scaleTrackInsertKey(trackIdx: Int32, time: Double, scale: Vector3) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: time) { pArg1 in
                withUnsafePointer(to: scale) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Animation.method_scale_track_insert_key, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_blend_shape_track_insert_key: GDExtensionMethodBindPtr = {
        let methodName = StringName("blend_shape_track_insert_key")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1534913637)!
            }
            
        }
        
    }()
    
    /// Inserts a key in a given blend shape track. Returns the key index.
    public final func blendShapeTrackInsertKey(trackIdx: Int32, time: Double, amount: Double) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: time) { pArg1 in
                withUnsafePointer(to: amount) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Animation.method_blend_shape_track_insert_key, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_position_track_interpolate: GDExtensionMethodBindPtr = {
        let methodName = StringName("position_track_interpolate")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3530011197)!
            }
            
        }
        
    }()
    
    /// Returns the interpolated position value at the given time (in seconds). The `trackIdx` must be the index of a 3D position track.
    public final func positionTrackInterpolate(trackIdx: Int32, timeSec: Double, backward: Bool = false) -> Vector3 {
        var _result: Vector3 = Vector3 ()
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: timeSec) { pArg1 in
                withUnsafePointer(to: backward) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Animation.method_position_track_interpolate, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_rotation_track_interpolate: GDExtensionMethodBindPtr = {
        let methodName = StringName("rotation_track_interpolate")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2915876792)!
            }
            
        }
        
    }()
    
    /// Returns the interpolated rotation value at the given time (in seconds). The `trackIdx` must be the index of a 3D rotation track.
    public final func rotationTrackInterpolate(trackIdx: Int32, timeSec: Double, backward: Bool = false) -> Quaternion {
        var _result: Quaternion = Quaternion ()
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: timeSec) { pArg1 in
                withUnsafePointer(to: backward) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Animation.method_rotation_track_interpolate, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_scale_track_interpolate: GDExtensionMethodBindPtr = {
        let methodName = StringName("scale_track_interpolate")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3530011197)!
            }
            
        }
        
    }()
    
    /// Returns the interpolated scale value at the given time (in seconds). The `trackIdx` must be the index of a 3D scale track.
    public final func scaleTrackInterpolate(trackIdx: Int32, timeSec: Double, backward: Bool = false) -> Vector3 {
        var _result: Vector3 = Vector3 ()
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: timeSec) { pArg1 in
                withUnsafePointer(to: backward) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Animation.method_scale_track_interpolate, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_blend_shape_track_interpolate: GDExtensionMethodBindPtr = {
        let methodName = StringName("blend_shape_track_interpolate")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2482365182)!
            }
            
        }
        
    }()
    
    /// Returns the interpolated blend shape value at the given time (in seconds). The `trackIdx` must be the index of a blend shape track.
    public final func blendShapeTrackInterpolate(trackIdx: Int32, timeSec: Double, backward: Bool = false) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: timeSec) { pArg1 in
                withUnsafePointer(to: backward) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Animation.method_blend_shape_track_interpolate, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_track_insert_key: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_insert_key")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 808952278)!
            }
            
        }
        
    }()
    
    /// Inserts a generic key in a given track. Returns the key index.
    public final func trackInsertKey(trackIdx: Int32, time: Double, key: Variant, transition: Double = 1) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: time) { pArg1 in
                withUnsafePointer(to: key.content) { pArg2 in
                    withUnsafePointer(to: transition) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(Animation.method_track_insert_key, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_track_remove_key: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_remove_key")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Removes a key by index in a given track.
    public final func trackRemoveKey(trackIdx: Int32, keyIdx: Int32) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: keyIdx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_track_remove_key, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_track_remove_key_at_time: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_remove_key_at_time")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1602489585)!
            }
            
        }
        
    }()
    
    /// Removes a key at `time` in a given track.
    public final func trackRemoveKeyAtTime(trackIdx: Int32, time: Double) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: time) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_track_remove_key_at_time, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_track_set_key_value: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_set_key_value")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2060538656)!
            }
            
        }
        
    }()
    
    /// Sets the value of an existing key.
    public final func trackSetKeyValue(trackIdx: Int32, key: Int32, value: Variant) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: key) { pArg1 in
                withUnsafePointer(to: value.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Animation.method_track_set_key_value, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_track_set_key_transition: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_set_key_transition")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3506521499)!
            }
            
        }
        
    }()
    
    /// Sets the transition curve (easing) for a specific key (see the built-in math function ``@GlobalScope.ease``).
    public final func trackSetKeyTransition(trackIdx: Int32, keyIdx: Int32, transition: Double) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: keyIdx) { pArg1 in
                withUnsafePointer(to: transition) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Animation.method_track_set_key_transition, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_track_set_key_time: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_set_key_time")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3506521499)!
            }
            
        }
        
    }()
    
    /// Sets the time of an existing key.
    public final func trackSetKeyTime(trackIdx: Int32, keyIdx: Int32, time: Double) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: keyIdx) { pArg1 in
                withUnsafePointer(to: time) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Animation.method_track_set_key_time, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_track_get_key_transition: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_get_key_transition")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3085491603)!
            }
            
        }
        
    }()
    
    /// Returns the transition curve (easing) for a specific key (see the built-in math function ``@GlobalScope.ease``).
    public final func trackGetKeyTransition(trackIdx: Int32, keyIdx: Int32) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: keyIdx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_track_get_key_transition, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_track_get_key_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_get_key_count")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the number of keys in a given track.
    public final func trackGetKeyCount(trackIdx: Int32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Animation.method_track_get_key_count, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_track_get_key_value: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_get_key_value")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 678354945)!
            }
            
        }
        
    }()
    
    /// Returns the value of a given key in a given track.
    public final func trackGetKeyValue(trackIdx: Int32, keyIdx: Int32) -> Variant {
        let _result: Variant = Variant ()
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: keyIdx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_track_get_key_value, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_track_get_key_time: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_get_key_time")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3085491603)!
            }
            
        }
        
    }()
    
    /// Returns the time at which the key is located.
    public final func trackGetKeyTime(trackIdx: Int32, keyIdx: Int32) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: keyIdx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_track_get_key_time, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_track_find_key: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_find_key")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4230953007)!
            }
            
        }
        
    }()
    
    /// Finds the key index by time in a given track. Optionally, only find it if the approx/exact time is given.
    /// 
    /// If `limit` is `true`, it does not return keys outside the animation range.
    /// 
    /// If `backward` is `true`, the direction is reversed in methods that rely on one directional processing.
    /// 
    /// For example, in case `findMode` is .nearest, if there is no key in the current position just after seeked, the first key found is retrieved by searching before the position, but if `backward` is `true`, the first key found is retrieved after the position.
    /// 
    public final func trackFindKey(trackIdx: Int32, time: Double, findMode: Animation.FindMode = .nearest, limit: Bool = false, backward: Bool = false) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: time) { pArg1 in
                withUnsafePointer(to: findMode.rawValue) { pArg2 in
                    withUnsafePointer(to: limit) { pArg3 in
                        withUnsafePointer(to: backward) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    gi.object_method_bind_ptrcall(Animation.method_track_find_key, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_track_set_interpolation_type: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_set_interpolation_type")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4112932513)!
            }
            
        }
        
    }()
    
    /// Sets the interpolation type of a given track.
    public final func trackSetInterpolationType(trackIdx: Int32, interpolation: Animation.InterpolationType) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: interpolation.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_track_set_interpolation_type, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_track_get_interpolation_type: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_get_interpolation_type")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1530756894)!
            }
            
        }
        
    }()
    
    /// Returns the interpolation type of a given track.
    public final func trackGetInterpolationType(trackIdx: Int32) -> Animation.InterpolationType {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Animation.method_track_get_interpolation_type, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return Animation.InterpolationType (rawValue: _result)!
    }
    
    fileprivate static var method_track_set_interpolation_loop_wrap: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_set_interpolation_loop_wrap")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// If `true`, the track at `trackIdx` wraps the interpolation loop.
    public final func trackSetInterpolationLoopWrap(trackIdx: Int32, interpolation: Bool) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: interpolation) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_track_set_interpolation_loop_wrap, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_track_get_interpolation_loop_wrap: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_get_interpolation_loop_wrap")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the track at `trackIdx` wraps the interpolation loop. New tracks wrap the interpolation loop by default.
    public final func trackGetInterpolationLoopWrap(trackIdx: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Animation.method_track_get_interpolation_loop_wrap, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_track_is_compressed: GDExtensionMethodBindPtr = {
        let methodName = StringName("track_is_compressed")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the track is compressed, `false` otherwise. See also ``compress(pageSize:fps:splitTolerance:)``.
    public final func trackIsCompressed(trackIdx: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Animation.method_track_is_compressed, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_value_track_set_update_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("value_track_set_update_mode")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2854058312)!
            }
            
        }
        
    }()
    
    /// Sets the update mode (see ``Animation/UpdateMode``) of a value track.
    public final func valueTrackSetUpdateMode(trackIdx: Int32, mode: Animation.UpdateMode) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: mode.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_value_track_set_update_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_value_track_get_update_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("value_track_get_update_mode")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1440326473)!
            }
            
        }
        
    }()
    
    /// Returns the update mode of a value track.
    public final func valueTrackGetUpdateMode(trackIdx: Int32) -> Animation.UpdateMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Animation.method_value_track_get_update_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return Animation.UpdateMode (rawValue: _result)!
    }
    
    fileprivate static var method_value_track_interpolate: GDExtensionMethodBindPtr = {
        let methodName = StringName("value_track_interpolate")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 747269075)!
            }
            
        }
        
    }()
    
    /// Returns the interpolated value at the given time (in seconds). The `trackIdx` must be the index of a value track.
    /// 
    /// A `backward` mainly affects the direction of key retrieval of the track with .updateDiscrete converted by ``AnimationMixer/AnimationCallbackModeDiscrete/forceContinuous`` to match the result with ``trackFindKey(trackIdx:time:findMode:limit:backward:)``.
    /// 
    public final func valueTrackInterpolate(trackIdx: Int32, timeSec: Double, backward: Bool = false) -> Variant {
        let _result: Variant = Variant ()
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: timeSec) { pArg1 in
                withUnsafePointer(to: backward) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Animation.method_value_track_interpolate, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_method_track_get_name: GDExtensionMethodBindPtr = {
        let methodName = StringName("method_track_get_name")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 351665558)!
            }
            
        }
        
    }()
    
    /// Returns the method name of a method track.
    public final func methodTrackGetName(trackIdx: Int32, keyIdx: Int32) -> StringName {
        let _result: StringName = StringName ()
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: keyIdx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_method_track_get_name, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_method_track_get_params: GDExtensionMethodBindPtr = {
        let methodName = StringName("method_track_get_params")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2345056839)!
            }
            
        }
        
    }()
    
    /// Returns the arguments values to be called on a method track for a given key in a given track.
    public final func methodTrackGetParams(trackIdx: Int32, keyIdx: Int32) -> GArray {
        let _result: GArray = GArray ()
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: keyIdx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_method_track_get_params, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_bezier_track_insert_key: GDExtensionMethodBindPtr = {
        let methodName = StringName("bezier_track_insert_key")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3656773645)!
            }
            
        }
        
    }()
    
    /// Inserts a Bezier Track key at the given `time` in seconds. The `trackIdx` must be the index of a Bezier Track.
    /// 
    /// `inHandle` is the left-side weight of the added Bezier curve point, `outHandle` is the right-side one, while `value` is the actual value at this point.
    /// 
    public final func bezierTrackInsertKey(trackIdx: Int32, time: Double, value: Double, inHandle: Vector2 = Vector2 (x: 0, y: 0), outHandle: Vector2 = Vector2 (x: 0, y: 0)) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: time) { pArg1 in
                withUnsafePointer(to: value) { pArg2 in
                    withUnsafePointer(to: inHandle) { pArg3 in
                        withUnsafePointer(to: outHandle) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    gi.object_method_bind_ptrcall(Animation.method_bezier_track_insert_key, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_bezier_track_set_key_value: GDExtensionMethodBindPtr = {
        let methodName = StringName("bezier_track_set_key_value")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3506521499)!
            }
            
        }
        
    }()
    
    /// Sets the value of the key identified by `keyIdx` to the given value. The `trackIdx` must be the index of a Bezier Track.
    public final func bezierTrackSetKeyValue(trackIdx: Int32, keyIdx: Int32, value: Double) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: keyIdx) { pArg1 in
                withUnsafePointer(to: value) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Animation.method_bezier_track_set_key_value, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_bezier_track_set_key_in_handle: GDExtensionMethodBindPtr = {
        let methodName = StringName("bezier_track_set_key_in_handle")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1719223284)!
            }
            
        }
        
    }()
    
    /// Sets the in handle of the key identified by `keyIdx` to value `inHandle`. The `trackIdx` must be the index of a Bezier Track.
    public final func bezierTrackSetKeyInHandle(trackIdx: Int32, keyIdx: Int32, inHandle: Vector2, balancedValueTimeRatio: Double = 1.0) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: keyIdx) { pArg1 in
                withUnsafePointer(to: inHandle) { pArg2 in
                    withUnsafePointer(to: balancedValueTimeRatio) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(Animation.method_bezier_track_set_key_in_handle, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_bezier_track_set_key_out_handle: GDExtensionMethodBindPtr = {
        let methodName = StringName("bezier_track_set_key_out_handle")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1719223284)!
            }
            
        }
        
    }()
    
    /// Sets the out handle of the key identified by `keyIdx` to value `outHandle`. The `trackIdx` must be the index of a Bezier Track.
    public final func bezierTrackSetKeyOutHandle(trackIdx: Int32, keyIdx: Int32, outHandle: Vector2, balancedValueTimeRatio: Double = 1.0) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: keyIdx) { pArg1 in
                withUnsafePointer(to: outHandle) { pArg2 in
                    withUnsafePointer(to: balancedValueTimeRatio) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(Animation.method_bezier_track_set_key_out_handle, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_bezier_track_get_key_value: GDExtensionMethodBindPtr = {
        let methodName = StringName("bezier_track_get_key_value")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3085491603)!
            }
            
        }
        
    }()
    
    /// Returns the value of the key identified by `keyIdx`. The `trackIdx` must be the index of a Bezier Track.
    public final func bezierTrackGetKeyValue(trackIdx: Int32, keyIdx: Int32) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: keyIdx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_bezier_track_get_key_value, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_bezier_track_get_key_in_handle: GDExtensionMethodBindPtr = {
        let methodName = StringName("bezier_track_get_key_in_handle")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3016396712)!
            }
            
        }
        
    }()
    
    /// Returns the in handle of the key identified by `keyIdx`. The `trackIdx` must be the index of a Bezier Track.
    public final func bezierTrackGetKeyInHandle(trackIdx: Int32, keyIdx: Int32) -> Vector2 {
        var _result: Vector2 = Vector2 ()
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: keyIdx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_bezier_track_get_key_in_handle, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_bezier_track_get_key_out_handle: GDExtensionMethodBindPtr = {
        let methodName = StringName("bezier_track_get_key_out_handle")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3016396712)!
            }
            
        }
        
    }()
    
    /// Returns the out handle of the key identified by `keyIdx`. The `trackIdx` must be the index of a Bezier Track.
    public final func bezierTrackGetKeyOutHandle(trackIdx: Int32, keyIdx: Int32) -> Vector2 {
        var _result: Vector2 = Vector2 ()
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: keyIdx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_bezier_track_get_key_out_handle, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_bezier_track_interpolate: GDExtensionMethodBindPtr = {
        let methodName = StringName("bezier_track_interpolate")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1900462983)!
            }
            
        }
        
    }()
    
    /// Returns the interpolated value at the given `time` (in seconds). The `trackIdx` must be the index of a Bezier Track.
    public final func bezierTrackInterpolate(trackIdx: Int32, time: Double) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: time) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_bezier_track_interpolate, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_audio_track_insert_key: GDExtensionMethodBindPtr = {
        let methodName = StringName("audio_track_insert_key")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4021027286)!
            }
            
        }
        
    }()
    
    /// Inserts an Audio Track key at the given `time` in seconds. The `trackIdx` must be the index of an Audio Track.
    /// 
    /// `stream` is the ``AudioStream`` resource to play. `startOffset` is the number of seconds cut off at the beginning of the audio stream, while `endOffset` is at the ending.
    /// 
    public final func audioTrackInsertKey(trackIdx: Int32, time: Double, stream: Resource?, startOffset: Double = 0, endOffset: Double = 0) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: time) { pArg1 in
                withUnsafePointer(to: stream?.handle) { pArg2 in
                    withUnsafePointer(to: startOffset) { pArg3 in
                        withUnsafePointer(to: endOffset) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    gi.object_method_bind_ptrcall(Animation.method_audio_track_insert_key, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_audio_track_set_key_stream: GDExtensionMethodBindPtr = {
        let methodName = StringName("audio_track_set_key_stream")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3886397084)!
            }
            
        }
        
    }()
    
    /// Sets the stream of the key identified by `keyIdx` to value `stream`. The `trackIdx` must be the index of an Audio Track.
    public final func audioTrackSetKeyStream(trackIdx: Int32, keyIdx: Int32, stream: Resource?) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: keyIdx) { pArg1 in
                withUnsafePointer(to: stream?.handle) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Animation.method_audio_track_set_key_stream, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_audio_track_set_key_start_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName("audio_track_set_key_start_offset")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3506521499)!
            }
            
        }
        
    }()
    
    /// Sets the start offset of the key identified by `keyIdx` to value `offset`. The `trackIdx` must be the index of an Audio Track.
    public final func audioTrackSetKeyStartOffset(trackIdx: Int32, keyIdx: Int32, offset: Double) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: keyIdx) { pArg1 in
                withUnsafePointer(to: offset) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Animation.method_audio_track_set_key_start_offset, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_audio_track_set_key_end_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName("audio_track_set_key_end_offset")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3506521499)!
            }
            
        }
        
    }()
    
    /// Sets the end offset of the key identified by `keyIdx` to value `offset`. The `trackIdx` must be the index of an Audio Track.
    public final func audioTrackSetKeyEndOffset(trackIdx: Int32, keyIdx: Int32, offset: Double) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: keyIdx) { pArg1 in
                withUnsafePointer(to: offset) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Animation.method_audio_track_set_key_end_offset, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_audio_track_get_key_stream: GDExtensionMethodBindPtr = {
        let methodName = StringName("audio_track_get_key_stream")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 635277205)!
            }
            
        }
        
    }()
    
    /// Returns the audio stream of the key identified by `keyIdx`. The `trackIdx` must be the index of an Audio Track.
    public final func audioTrackGetKeyStream(trackIdx: Int32, keyIdx: Int32) -> Resource? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: keyIdx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_audio_track_get_key_stream, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_audio_track_get_key_start_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName("audio_track_get_key_start_offset")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3085491603)!
            }
            
        }
        
    }()
    
    /// Returns the start offset of the key identified by `keyIdx`. The `trackIdx` must be the index of an Audio Track.
    /// 
    /// Start offset is the number of seconds cut off at the beginning of the audio stream.
    /// 
    public final func audioTrackGetKeyStartOffset(trackIdx: Int32, keyIdx: Int32) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: keyIdx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_audio_track_get_key_start_offset, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_audio_track_get_key_end_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName("audio_track_get_key_end_offset")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3085491603)!
            }
            
        }
        
    }()
    
    /// Returns the end offset of the key identified by `keyIdx`. The `trackIdx` must be the index of an Audio Track.
    /// 
    /// End offset is the number of seconds cut off at the ending of the audio stream.
    /// 
    public final func audioTrackGetKeyEndOffset(trackIdx: Int32, keyIdx: Int32) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: keyIdx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_audio_track_get_key_end_offset, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_audio_track_set_use_blend: GDExtensionMethodBindPtr = {
        let methodName = StringName("audio_track_set_use_blend")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Sets whether the track will be blended with other animations. If `true`, the audio playback volume changes depending on the blend value.
    public final func audioTrackSetUseBlend(trackIdx: Int32, enable: Bool) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: enable) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_audio_track_set_use_blend, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_audio_track_is_use_blend: GDExtensionMethodBindPtr = {
        let methodName = StringName("audio_track_is_use_blend")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the track at `trackIdx` will be blended with other animations.
    public final func audioTrackIsUseBlend(trackIdx: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Animation.method_audio_track_is_use_blend, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_animation_track_insert_key: GDExtensionMethodBindPtr = {
        let methodName = StringName("animation_track_insert_key")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 158676774)!
            }
            
        }
        
    }()
    
    /// Inserts a key with value `animation` at the given `time` (in seconds). The `trackIdx` must be the index of an Animation Track.
    public final func animationTrackInsertKey(trackIdx: Int32, time: Double, animation: StringName) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: time) { pArg1 in
                withUnsafePointer(to: animation.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Animation.method_animation_track_insert_key, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_animation_track_set_key_animation: GDExtensionMethodBindPtr = {
        let methodName = StringName("animation_track_set_key_animation")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 117615382)!
            }
            
        }
        
    }()
    
    /// Sets the key identified by `keyIdx` to value `animation`. The `trackIdx` must be the index of an Animation Track.
    public final func animationTrackSetKeyAnimation(trackIdx: Int32, keyIdx: Int32, animation: StringName) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: keyIdx) { pArg1 in
                withUnsafePointer(to: animation.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Animation.method_animation_track_set_key_animation, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_animation_track_get_key_animation: GDExtensionMethodBindPtr = {
        let methodName = StringName("animation_track_get_key_animation")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 351665558)!
            }
            
        }
        
    }()
    
    /// Returns the animation name at the key identified by `keyIdx`. The `trackIdx` must be the index of an Animation Track.
    public final func animationTrackGetKeyAnimation(trackIdx: Int32, keyIdx: Int32) -> StringName {
        let _result: StringName = StringName ()
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: keyIdx) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_animation_track_get_key_animation, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_length: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_length")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_length(_ timeSec: Double) {
        withUnsafePointer(to: timeSec) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Animation.method_set_length, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_length: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_length")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_length() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(Animation.method_get_length, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_loop_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_loop_mode")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3155355575)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_loop_mode(_ loopMode: Animation.LoopMode) {
        withUnsafePointer(to: loopMode.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Animation.method_set_loop_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_loop_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_loop_mode")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1988889481)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_loop_mode() -> Animation.LoopMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(Animation.method_get_loop_mode, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return Animation.LoopMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_step: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_step")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_step(_ sizeSec: Double) {
        withUnsafePointer(to: sizeSec) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(Animation.method_set_step, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_step: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_step")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_step() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(Animation.method_get_step, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clear the animation (clear all tracks and reset all).
    public final func clear() {
        gi.object_method_bind_ptrcall(Animation.method_clear, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_copy_track: GDExtensionMethodBindPtr = {
        let methodName = StringName("copy_track")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 148001024)!
            }
            
        }
        
    }()
    
    /// Adds a new track to `toAnimation` that is a copy of the given track from this animation.
    public final func copyTrack(trackIdx: Int32, toAnimation: Animation?) {
        withUnsafePointer(to: trackIdx) { pArg0 in
            withUnsafePointer(to: toAnimation?.handle) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(Animation.method_copy_track, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_compress: GDExtensionMethodBindPtr = {
        let methodName = StringName("compress")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3608408117)!
            }
            
        }
        
    }()
    
    /// Compress the animation and all its tracks in-place. This will make ``trackIsCompressed(trackIdx:)`` return `true` once called on this ``Animation``. Compressed tracks require less memory to be played, and are designed to be used for complex 3D animations (such as cutscenes) imported from external 3D software. Compression is lossy, but the difference is usually not noticeable in real world conditions.
    /// 
    /// > Note: Compressed tracks have various limitations (such as not being editable from the editor), so only use compressed animations if you actually need them.
    /// 
    public final func compress(pageSize: UInt32 = 8192, fps: UInt32 = 120, splitTolerance: Double = 4.0) {
        withUnsafePointer(to: pageSize) { pArg0 in
            withUnsafePointer(to: fps) { pArg1 in
                withUnsafePointer(to: splitTolerance) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(Animation.method_compress, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_capture_included: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_capture_included")
        return withUnsafePointer(to: &Animation.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    public final func isCaptureIncluded() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(Animation.method_is_capture_included, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
}

