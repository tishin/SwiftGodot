// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
import Foundation
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Proxy texture for simple frame-based animations.
/// 
/// ``AnimatedTexture`` is a resource format for frame-based animations, where multiple textures can be chained automatically with a predefined delay for each frame. Unlike ``AnimationPlayer`` or ``AnimatedSprite2D``, it isn't a ``Node``, but has the advantage of being usable anywhere a ``Texture2D`` resource can be used, e.g. in a ``TileSet``.
/// 
/// The playback of the animation is controlled by the ``speedScale`` property, as well as each frame's duration (see ``setFrameDuration(frame:duration:)``). The animation loops, i.e. it will restart at frame 0 automatically after playing the last frame.
/// 
/// ``AnimatedTexture`` currently requires all frame textures to have the same size, otherwise the bigger ones will be cropped to match the smallest one.
/// 
/// > Note: AnimatedTexture doesn't support using ``AtlasTexture``s. Each frame needs to be a separate ``Texture2D``.
/// 
/// > Warning: The current implementation is not efficient for the modern renderers.
/// 
open class AnimatedTexture: Texture2D {
    override open class var godotClassName: StringName { "AnimatedTexture" }
    /* Constants */
    /// The maximum number of frames supported by ``AnimatedTexture``. If you need more frames in your animation, use ``AnimationPlayer`` or ``AnimatedSprite2D``.
    public static let maxFrames = 256
    
    /* Properties */
    
    /// Number of frames to use in the animation. While you can create the frames independently with ``setFrameTexture(frame:texture:)``, you need to set this value for the animation to take new frames into account. The maximum number of frames is ``maxFrames``.
    final public var frames: Int32 {
        get {
            return get_frames ()
        }
        
        set {
            set_frames (newValue)
        }
        
    }
    
    /// Sets the currently visible frame of the texture. Setting this frame while playing resets the current frame time, so the newly selected frame plays for its whole configured frame duration.
    final public var currentFrame: Int32 {
        get {
            return get_current_frame ()
        }
        
        set {
            set_current_frame (newValue)
        }
        
    }
    
    /// If `true`, the animation will pause where it currently is (i.e. at ``currentFrame``). The animation will continue from where it was paused when changing this property to `false`.
    final public var pause: Bool {
        get {
            return get_pause ()
        }
        
        set {
            set_pause (newValue)
        }
        
    }
    
    /// If `true`, the animation will only play once and will not loop back to the first frame after reaching the end. Note that reaching the end will not set ``pause`` to `true`.
    final public var oneShot: Bool {
        get {
            return get_one_shot ()
        }
        
        set {
            set_one_shot (newValue)
        }
        
    }
    
    /// The animation speed is multiplied by this value. If set to a negative value, the animation is played in reverse.
    final public var speedScale: Double {
        get {
            return get_speed_scale ()
        }
        
        set {
            set_speed_scale (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_set_frames: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_frames")
        return withUnsafePointer(to: &AnimatedTexture.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_frames(_ frames: Int32) {
        withUnsafePointer(to: frames) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(AnimatedTexture.method_set_frames, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_frames: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_frames")
        return withUnsafePointer(to: &AnimatedTexture.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_frames() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(AnimatedTexture.method_get_frames, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_current_frame: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_current_frame")
        return withUnsafePointer(to: &AnimatedTexture.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_current_frame(_ frame: Int32) {
        withUnsafePointer(to: frame) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(AnimatedTexture.method_set_current_frame, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_current_frame: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_current_frame")
        return withUnsafePointer(to: &AnimatedTexture.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_current_frame() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(AnimatedTexture.method_get_current_frame, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_pause: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_pause")
        return withUnsafePointer(to: &AnimatedTexture.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_pause(_ pause: Bool) {
        withUnsafePointer(to: pause) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(AnimatedTexture.method_set_pause, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_pause: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_pause")
        return withUnsafePointer(to: &AnimatedTexture.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_pause() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(AnimatedTexture.method_get_pause, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_one_shot: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_one_shot")
        return withUnsafePointer(to: &AnimatedTexture.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_one_shot(_ oneShot: Bool) {
        withUnsafePointer(to: oneShot) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(AnimatedTexture.method_set_one_shot, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_one_shot: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_one_shot")
        return withUnsafePointer(to: &AnimatedTexture.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_one_shot() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(AnimatedTexture.method_get_one_shot, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_speed_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_speed_scale")
        return withUnsafePointer(to: &AnimatedTexture.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_speed_scale(_ scale: Double) {
        withUnsafePointer(to: scale) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(AnimatedTexture.method_set_speed_scale, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_speed_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_speed_scale")
        return withUnsafePointer(to: &AnimatedTexture.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_speed_scale() -> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall(AnimatedTexture.method_get_speed_scale, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_frame_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_frame_texture")
        return withUnsafePointer(to: &AnimatedTexture.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 666127730)!
            }
            
        }
        
    }()
    
    /// Assigns a ``Texture2D`` to the given frame. Frame IDs start at 0, so the first frame has ID 0, and the last frame of the animation has ID ``frames`` - 1.
    /// 
    /// You can define any number of textures up to ``maxFrames``, but keep in mind that only frames from 0 to ``frames`` - 1 will be part of the animation.
    /// 
    public final func setFrameTexture(frame: Int32, texture: Texture2D?) {
        withUnsafePointer(to: frame) { pArg0 in
            withUnsafePointer(to: texture?.handle) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(AnimatedTexture.method_set_frame_texture, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_frame_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_frame_texture")
        return withUnsafePointer(to: &AnimatedTexture.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3536238170)!
            }
            
        }
        
    }()
    
    /// Returns the given frame's ``Texture2D``.
    public final func getFrameTexture(frame: Int32) -> Texture2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: frame) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(AnimatedTexture.method_get_frame_texture, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_frame_duration: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_frame_duration")
        return withUnsafePointer(to: &AnimatedTexture.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1602489585)!
            }
            
        }
        
    }()
    
    /// Sets the duration of any given `frame`. The final duration is affected by the ``speedScale``. If set to `0`, the frame is skipped during playback.
    public final func setFrameDuration(frame: Int32, duration: Double) {
        withUnsafePointer(to: frame) { pArg0 in
            withUnsafePointer(to: duration) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(AnimatedTexture.method_set_frame_duration, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_frame_duration: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_frame_duration")
        return withUnsafePointer(to: &AnimatedTexture.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2339986948)!
            }
            
        }
        
    }()
    
    /// Returns the given `frame`'s duration, in seconds.
    public final func getFrameDuration(frame: Int32) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: frame) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(AnimatedTexture.method_get_frame_duration, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
}

