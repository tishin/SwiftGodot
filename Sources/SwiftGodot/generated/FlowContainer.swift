// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
import Foundation
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A container that arranges its child controls horizontally or vertically and wraps them around at the borders.
/// 
/// A container that arranges its child controls horizontally or vertically and wraps them around at the borders. This is similar to how text in a book wraps around when no more words can fit on a line.
open class FlowContainer: Container {
    override open class var godotClassName: StringName { "FlowContainer" }
    public enum AlignmentMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The child controls will be arranged at the beginning of the container, i.e. top if orientation is vertical, left if orientation is horizontal (right for RTL layout).
        case begin = 0 // ALIGNMENT_BEGIN
        /// The child controls will be centered in the container.
        case center = 1 // ALIGNMENT_CENTER
        /// The child controls will be arranged at the end of the container, i.e. bottom if orientation is vertical, right if orientation is horizontal (left for RTL layout).
        case end = 2 // ALIGNMENT_END
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .begin: return ".begin"
                case .center: return ".center"
                case .end: return ".end"
            }
            
        }
        
    }
    
    public enum LastWrapAlignmentMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The last partially filled row or column will wrap aligned to the previous row or column in accordance with ``alignment``.
        case inherit = 0 // LAST_WRAP_ALIGNMENT_INHERIT
        /// The last partially filled row or column will wrap aligned to the beginning of the previous row or column.
        case begin = 1 // LAST_WRAP_ALIGNMENT_BEGIN
        /// The last partially filled row or column will wrap aligned to the center of the previous row or column.
        case center = 2 // LAST_WRAP_ALIGNMENT_CENTER
        /// The last partially filled row or column will wrap aligned to the end of the previous row or column.
        case end = 3 // LAST_WRAP_ALIGNMENT_END
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .inherit: return ".inherit"
                case .begin: return ".begin"
                case .center: return ".center"
                case .end: return ".end"
            }
            
        }
        
    }
    
    
    /* Properties */
    
    /// The alignment of the container's children (must be one of .alignmentBegin, .alignmentCenter, or .alignmentEnd).
    final public var alignment: FlowContainer.AlignmentMode {
        get {
            return get_alignment ()
        }
        
        set {
            set_alignment (newValue)
        }
        
    }
    
    /// The wrap behavior of the last, partially filled row or column (must be one of .lastWrapAlignmentInherit, .lastWrapAlignmentBegin, .lastWrapAlignmentCenter, or .lastWrapAlignmentEnd).
    final public var lastWrapAlignment: FlowContainer.LastWrapAlignmentMode {
        get {
            return get_last_wrap_alignment ()
        }
        
        set {
            set_last_wrap_alignment (newValue)
        }
        
    }
    
    /// If `true`, the ``FlowContainer`` will arrange its children vertically, rather than horizontally.
    /// 
    /// Can't be changed when using ``HFlowContainer`` and ``VFlowContainer``.
    /// 
    final public var vertical: Bool {
        get {
            return is_vertical ()
        }
        
        set {
            set_vertical (newValue)
        }
        
    }
    
    /// If `true`, reverses fill direction. Horizontal ``FlowContainer``s will fill rows bottom to top, vertical ``FlowContainer``s will fill columns right to left.
    /// 
    /// When using a vertical ``FlowContainer`` with a right to left ``Control/layoutDirection``, columns will fill left to right instead.
    /// 
    final public var reverseFill: Bool {
        get {
            return is_reverse_fill ()
        }
        
        set {
            set_reverse_fill (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_get_line_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_line_count")
        return withUnsafePointer(to: &FlowContainer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the current line count.
    public final func getLineCount() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(FlowContainer.method_get_line_count, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_alignment: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_alignment")
        return withUnsafePointer(to: &FlowContainer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 575250951)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_alignment(_ alignment: FlowContainer.AlignmentMode) {
        withUnsafePointer(to: alignment.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(FlowContainer.method_set_alignment, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_alignment: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_alignment")
        return withUnsafePointer(to: &FlowContainer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3749743559)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_alignment() -> FlowContainer.AlignmentMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(FlowContainer.method_get_alignment, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return FlowContainer.AlignmentMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_last_wrap_alignment: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_last_wrap_alignment")
        return withUnsafePointer(to: &FlowContainer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2899697495)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_last_wrap_alignment(_ lastWrapAlignment: FlowContainer.LastWrapAlignmentMode) {
        withUnsafePointer(to: lastWrapAlignment.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(FlowContainer.method_set_last_wrap_alignment, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_last_wrap_alignment: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_last_wrap_alignment")
        return withUnsafePointer(to: &FlowContainer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3743456014)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_last_wrap_alignment() -> FlowContainer.LastWrapAlignmentMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(FlowContainer.method_get_last_wrap_alignment, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return FlowContainer.LastWrapAlignmentMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_vertical: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_vertical")
        return withUnsafePointer(to: &FlowContainer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_vertical(_ vertical: Bool) {
        withUnsafePointer(to: vertical) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(FlowContainer.method_set_vertical, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_vertical: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_vertical")
        return withUnsafePointer(to: &FlowContainer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_vertical() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(FlowContainer.method_is_vertical, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_reverse_fill: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_reverse_fill")
        return withUnsafePointer(to: &FlowContainer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_reverse_fill(_ reverseFill: Bool) {
        withUnsafePointer(to: reverseFill) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(FlowContainer.method_set_reverse_fill, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_reverse_fill: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_reverse_fill")
        return withUnsafePointer(to: &FlowContainer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_reverse_fill() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(FlowContainer.method_is_reverse_fill, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
}

