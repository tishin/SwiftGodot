// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
import Foundation
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Node for 2D tile-based maps.
/// 
/// Node for 2D tile-based maps. A ``TileMapLayer`` uses a ``TileSet`` which contain a list of tiles which are used to create grid-based maps. Unlike the ``TileMap`` node, which is deprecated, ``TileMapLayer`` has only one layer of tiles. You can use several ``TileMapLayer`` to achieve the same result as a ``TileMap`` node.
/// 
/// For performance reasons, all TileMap updates are batched at the end of a frame. Notably, this means that scene tiles from a ``TileSetScenesCollectionSource`` may be initialized after their parent. This is only queued when inside the scene tree.
/// 
/// To force an update earlier on, call ``updateInternals()``.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``changed``
open class TileMapLayer: Node2D {
    override open class var godotClassName: StringName { "TileMapLayer" }
    public enum DebugVisibilityMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Hide the collisions or navigation debug shapes in the editor, and use the debug settings to determine their visibility in game (i.e. ``SceneTree/debugCollisionsHint`` or ``SceneTree/debugNavigationHint``).
        case `default` = 0 // DEBUG_VISIBILITY_MODE_DEFAULT
        /// Always hide the collisions or navigation debug shapes.
        case forceHide = 2 // DEBUG_VISIBILITY_MODE_FORCE_HIDE
        /// Always show the collisions or navigation debug shapes.
        case forceShow = 1 // DEBUG_VISIBILITY_MODE_FORCE_SHOW
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .`default`: return ".`default`"
                case .forceHide: return ".forceHide"
                case .forceShow: return ".forceShow"
            }
            
        }
        
    }
    
    
    /* Properties */
    
    /// The raw tile map data as a byte array.
    final public var tileMapData: PackedByteArray {
        get {
            return get_tile_map_data_as_array ()
        }
        
        set {
            set_tile_map_data_from_array (newValue)
        }
        
    }
    
    /// If `false`, disables this ``TileMapLayer`` completely (rendering, collision, navigation, scene tiles, etc.)
    final public var enabled: Bool {
        get {
            return is_enabled ()
        }
        
        set {
            set_enabled (newValue)
        }
        
    }
    
    /// The ``TileSet`` used by this layer. The textures, collisions, and additional behavior of all available tiles are stored here.
    final public var tileSet: TileSet? {
        get {
            return get_tile_set ()
        }
        
        set {
            set_tile_set (newValue)
        }
        
    }
    
    /// This Y-sort origin value is added to each tile's Y-sort origin value. This allows, for example, to fake a different height level. This can be useful for top-down view games.
    final public var ySortOrigin: Int32 {
        get {
            return get_y_sort_origin ()
        }
        
        set {
            set_y_sort_origin (newValue)
        }
        
    }
    
    /// If ``CanvasItem/ySortEnabled`` is enabled, setting this to `true` will reverse the order the tiles are drawn on the X-axis.
    final public var xDrawOrderReversed: Bool {
        get {
            return is_x_draw_order_reversed ()
        }
        
        set {
            set_x_draw_order_reversed (newValue)
        }
        
    }
    
    /// The ``TileMapLayer``'s quadrant size. A quadrant is a group of tiles to be drawn together on a single canvas item, for optimization purposes. ``renderingQuadrantSize`` defines the length of a square's side, in the map's coordinate system, that forms the quadrant. Thus, the default quadrant size groups together `16 * 16 = 256` tiles.
    /// 
    /// The quadrant size does not apply on a Y-sorted ``TileMapLayer``, as tiles are grouped by Y position instead in that case.
    /// 
    /// > Note: As quadrants are created according to the map's coordinate system, the quadrant's "square shape" might not look like square in the ``TileMapLayer``'s local coordinate system.
    /// 
    final public var renderingQuadrantSize: Int32 {
        get {
            return get_rendering_quadrant_size ()
        }
        
        set {
            set_rendering_quadrant_size (newValue)
        }
        
    }
    
    /// Enable or disable collisions.
    final public var collisionEnabled: Bool {
        get {
            return is_collision_enabled ()
        }
        
        set {
            set_collision_enabled (newValue)
        }
        
    }
    
    /// If `true`, this ``TileMapLayer`` collision shapes will be instantiated as kinematic bodies. This can be needed for moving ``TileMapLayer`` nodes (i.e. moving platforms).
    final public var useKinematicBodies: Bool {
        get {
            return is_using_kinematic_bodies ()
        }
        
        set {
            set_use_kinematic_bodies (newValue)
        }
        
    }
    
    /// Show or hide the ``TileMapLayer``'s collision shapes. If set to .`default`, this depends on the show collision debug settings.
    final public var collisionVisibilityMode: TileMapLayer.DebugVisibilityMode {
        get {
            return get_collision_visibility_mode ()
        }
        
        set {
            set_collision_visibility_mode (newValue)
        }
        
    }
    
    /// If `true`, navigation regions are enabled.
    final public var navigationEnabled: Bool {
        get {
            return is_navigation_enabled ()
        }
        
        set {
            set_navigation_enabled (newValue)
        }
        
    }
    
    /// Show or hide the ``TileMapLayer``'s navigation meshes. If set to .`default`, this depends on the show navigation debug settings.
    final public var navigationVisibilityMode: TileMapLayer.DebugVisibilityMode {
        get {
            return get_navigation_visibility_mode ()
        }
        
        set {
            set_navigation_visibility_mode (newValue)
        }
        
    }
    
    /* Methods */
    /// Should return `true` if the tile at coordinates `coords` requires a runtime update.
    /// 
    /// > Warning: Make sure this function only returns `true` when needed. Any tile processed at runtime without a need for it will imply a significant performance penalty.
    /// 
    /// > Note: If the result of this function should change, use ``notifyRuntimeTileDataUpdate()`` to notify the ``TileMapLayer`` it needs an update.
    /// 
    @_documentation(visibility: public)
    open func _useTileDataRuntimeUpdate(coords: Vector2i) -> Bool {
        return false
    }
    
    /// Called with a ``TileData`` object about to be used internally by the ``TileMapLayer``, allowing its modification at runtime.
    /// 
    /// This method is only called if ``_useTileDataRuntimeUpdate(coords:)`` is implemented and returns `true` for the given tile `coords`.
    /// 
    /// > Warning: The `tileData` object's sub-resources are the same as the one in the TileSet. Modifying them might impact the whole TileSet. Instead, make sure to duplicate those resources.
    /// 
    /// > Note: If the properties of `tileData` object should change over time, use ``notifyRuntimeTileDataUpdate()`` to notify the ``TileMapLayer`` it needs an update.
    /// 
    @_documentation(visibility: public)
    open func _tileDataRuntimeUpdate(coords: Vector2i, tileData: TileData?) {
    }
    
    fileprivate static var method_set_cell: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_cell")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2428518503)!
            }
            
        }
        
    }()
    
    /// Sets the tile identifiers for the cell at coordinates `coords`. Each tile of the ``TileSet`` is identified using three parts:
    /// 
    /// - The source identifier `sourceId` identifies a ``TileSetSource`` identifier. See ``TileSet/setSourceId(_:newSourceId:)``,
    /// 
    /// - The atlas coordinate identifier `atlasCoords` identifies a tile coordinates in the atlas (if the source is a ``TileSetAtlasSource``). For ``TileSetScenesCollectionSource`` it should always be `Vector2i(0, 0)`,
    /// 
    /// - The alternative tile identifier `alternativeTile` identifies a tile alternative in the atlas (if the source is a ``TileSetAtlasSource``), and the scene for a ``TileSetScenesCollectionSource``.
    /// 
    /// If `sourceId` is set to `-1`, `atlasCoords` to `Vector2i(-1, -1)`, or `alternativeTile` to `-1`, the cell will be erased. An erased cell gets **all** its identifiers automatically set to their respective invalid values, namely `-1`, `Vector2i(-1, -1)` and `-1`.
    /// 
    public final func setCell(coords: Vector2i, sourceId: Int32 = -1, atlasCoords: Vector2i = Vector2i (x: -1, y: -1), alternativeTile: Int32 = 0) {
        withUnsafePointer(to: coords) { pArg0 in
            withUnsafePointer(to: sourceId) { pArg1 in
                withUnsafePointer(to: atlasCoords) { pArg2 in
                    withUnsafePointer(to: alternativeTile) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(TileMapLayer.method_set_cell, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_erase_cell: GDExtensionMethodBindPtr = {
        let methodName = StringName("erase_cell")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1130785943)!
            }
            
        }
        
    }()
    
    /// Erases the cell at coordinates `coords`.
    public final func eraseCell(coords: Vector2i) {
        withUnsafePointer(to: coords) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMapLayer.method_erase_cell, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_fix_invalid_tiles: GDExtensionMethodBindPtr = {
        let methodName = StringName("fix_invalid_tiles")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears cells containing tiles that do not exist in the ``tileSet``.
    public final func fixInvalidTiles() {
        gi.object_method_bind_ptrcall(TileMapLayer.method_fix_invalid_tiles, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName("clear")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears all cells.
    public final func clear() {
        gi.object_method_bind_ptrcall(TileMapLayer.method_clear, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_get_cell_source_id: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_cell_source_id")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2485466453)!
            }
            
        }
        
    }()
    
    /// Returns the tile source ID of the cell at coordinates `coords`. Returns `-1` if the cell does not exist.
    public final func getCellSourceId(coords: Vector2i) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: coords) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMapLayer.method_get_cell_source_id, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_cell_atlas_coords: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_cell_atlas_coords")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3050897911)!
            }
            
        }
        
    }()
    
    /// Returns the tile atlas coordinates ID of the cell at coordinates `coords`. Returns `Vector2i(-1, -1)` if the cell does not exist.
    public final func getCellAtlasCoords(_ coords: Vector2i) -> Vector2i {
        var _result: Vector2i = Vector2i ()
        withUnsafePointer(to: coords) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMapLayer.method_get_cell_atlas_coords, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_cell_alternative_tile: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_cell_alternative_tile")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2485466453)!
            }
            
        }
        
    }()
    
    /// Returns the tile alternative ID of the cell at coordinates `coords`.
    public final func getCellAlternativeTile(coords: Vector2i) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: coords) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMapLayer.method_get_cell_alternative_tile, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_cell_tile_data: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_cell_tile_data")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 205084707)!
            }
            
        }
        
    }()
    
    /// Returns the ``TileData`` object associated with the given cell, or `null` if the cell does not exist or is not a ``TileSetAtlasSource``.
    /// 
    public final func getCellTileData(coords: Vector2i) -> TileData? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: coords) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMapLayer.method_get_cell_tile_data, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_used_cells: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_used_cells")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    /// Returns a ``Vector2i`` array with the positions of all cells containing a tile. A cell is considered empty if its source identifier equals `-1`, its atlas coordinate identifier is `Vector2(-1, -1)` and its alternative identifier is `-1`.
    public final func getUsedCells() -> VariantCollection<Vector2i> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall(TileMapLayer.method_get_used_cells, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return VariantCollection<Vector2i>(content: _result)
    }
    
    fileprivate static var method_get_used_cells_by_id: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_used_cells_by_id")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4175304538)!
            }
            
        }
        
    }()
    
    /// Returns a ``Vector2i`` array with the positions of all cells containing a tile. Tiles may be filtered according to their source (`sourceId`), their atlas coordinates (`atlasCoords`), or alternative id (`alternativeTile`).
    /// 
    /// If a parameter has its value set to the default one, this parameter is not used to filter a cell. Thus, if all parameters have their respective default values, this method returns the same result as ``getUsedCells()``.
    /// 
    /// A cell is considered empty if its source identifier equals `-1`, its atlas coordinate identifier is `Vector2(-1, -1)` and its alternative identifier is `-1`.
    /// 
    public final func getUsedCellsById(sourceId: Int32 = -1, atlasCoords: Vector2i = Vector2i (x: -1, y: -1), alternativeTile: Int32 = -1) -> VariantCollection<Vector2i> {
        var _result: Int64 = 0
        withUnsafePointer(to: sourceId) { pArg0 in
            withUnsafePointer(to: atlasCoords) { pArg1 in
                withUnsafePointer(to: alternativeTile) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TileMapLayer.method_get_used_cells_by_id, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return VariantCollection<Vector2i>(content: _result)
    }
    
    fileprivate static var method_get_used_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_used_rect")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 410525958)!
            }
            
        }
        
    }()
    
    /// Returns a rectangle enclosing the used (non-empty) tiles of the map.
    public final func getUsedRect() -> Rect2i {
        var _result: Rect2i = Rect2i ()
        gi.object_method_bind_ptrcall(TileMapLayer.method_get_used_rect, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_pattern: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_pattern")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3820813253)!
            }
            
        }
        
    }()
    
    /// Creates and returns a new ``TileMapPattern`` from the given array of cells. See also ``setPattern(position:pattern:)``.
    public final func getPattern(coordsArray: VariantCollection<Vector2i>) -> TileMapPattern? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: coordsArray.array.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMapLayer.method_get_pattern, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_pattern: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_pattern")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1491151770)!
            }
            
        }
        
    }()
    
    /// Pastes the ``TileMapPattern`` at the given `position` in the tile map. See also ``getPattern(coordsArray:)``.
    public final func setPattern(position: Vector2i, pattern: TileMapPattern?) {
        withUnsafePointer(to: position) { pArg0 in
            withUnsafePointer(to: pattern?.handle) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileMapLayer.method_set_pattern, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_cells_terrain_connect: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_cells_terrain_connect")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 748968311)!
            }
            
        }
        
    }()
    
    /// Update all the cells in the `cells` coordinates array so that they use the given `terrain` for the given `terrainSet`. If an updated cell has the same terrain as one of its neighboring cells, this function tries to join the two. This function might update neighboring tiles if needed to create correct terrain transitions.
    /// 
    /// If `ignoreEmptyTerrains` is true, empty terrains will be ignored when trying to find the best fitting tile for the given terrain constraints.
    /// 
    /// > Note: To work correctly, this method requires the ``TileMapLayer``'s TileSet to have terrains set up with all required terrain combinations. Otherwise, it may produce unexpected results.
    /// 
    public final func setCellsTerrainConnect(cells: VariantCollection<Vector2i>, terrainSet: Int32, terrain: Int32, ignoreEmptyTerrains: Bool = true) {
        withUnsafePointer(to: cells.array.content) { pArg0 in
            withUnsafePointer(to: terrainSet) { pArg1 in
                withUnsafePointer(to: terrain) { pArg2 in
                    withUnsafePointer(to: ignoreEmptyTerrains) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(TileMapLayer.method_set_cells_terrain_connect, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_set_cells_terrain_path: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_cells_terrain_path")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 748968311)!
            }
            
        }
        
    }()
    
    /// Update all the cells in the `path` coordinates array so that they use the given `terrain` for the given `terrainSet`. The function will also connect two successive cell in the path with the same terrain. This function might update neighboring tiles if needed to create correct terrain transitions.
    /// 
    /// If `ignoreEmptyTerrains` is true, empty terrains will be ignored when trying to find the best fitting tile for the given terrain constraints.
    /// 
    /// > Note: To work correctly, this method requires the ``TileMapLayer``'s TileSet to have terrains set up with all required terrain combinations. Otherwise, it may produce unexpected results.
    /// 
    public final func setCellsTerrainPath(_ path: VariantCollection<Vector2i>, terrainSet: Int32, terrain: Int32, ignoreEmptyTerrains: Bool = true) {
        withUnsafePointer(to: path.array.content) { pArg0 in
            withUnsafePointer(to: terrainSet) { pArg1 in
                withUnsafePointer(to: terrain) { pArg2 in
                    withUnsafePointer(to: ignoreEmptyTerrains) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(TileMapLayer.method_set_cells_terrain_path, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_has_body_rid: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_body_rid")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4155700596)!
            }
            
        }
        
    }()
    
    /// Returns whether the provided `body` ``RID`` belongs to one of this ``TileMapLayer``'s cells.
    public final func hasBodyRid(body: RID) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: body.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMapLayer.method_has_body_rid, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_coords_for_body_rid: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_coords_for_body_rid")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 733700038)!
            }
            
        }
        
    }()
    
    /// Returns the coordinates of the tile for given physics body ``RID``. Such an ``RID`` can be retrieved from ``KinematicCollision2D/getColliderRid()``, when colliding with a tile.
    public final func getCoordsForBodyRid(body: RID) -> Vector2i {
        var _result: Vector2i = Vector2i ()
        withUnsafePointer(to: body.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMapLayer.method_get_coords_for_body_rid, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_update_internals: GDExtensionMethodBindPtr = {
        let methodName = StringName("update_internals")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Triggers a direct update of the ``TileMapLayer``. Usually, calling this function is not needed, as ``TileMapLayer`` node updates automatically when one of its properties or cells is modified.
    /// 
    /// However, for performance reasons, those updates are batched and delayed to the end of the frame. Calling this function will force the ``TileMapLayer`` to update right away instead.
    /// 
    /// > Warning: Updating the ``TileMapLayer`` is computationally expensive and may impact performance. Try to limit the number of updates and how many tiles they impact.
    /// 
    public final func updateInternals() {
        gi.object_method_bind_ptrcall(TileMapLayer.method_update_internals, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_notify_runtime_tile_data_update: GDExtensionMethodBindPtr = {
        let methodName = StringName("notify_runtime_tile_data_update")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2275361663)!
            }
            
        }
        
    }()
    
    /// Notifies the ``TileMapLayer`` node that calls to ``_useTileDataRuntimeUpdate(coords:)`` or ``_tileDataRuntimeUpdate(coords:tileData:)`` will lead to different results. This will thus trigger a ``TileMapLayer`` update.
    /// 
    /// > Warning: Updating the ``TileMapLayer`` is computationally expensive and may impact performance. Try to limit the number of calls to this function to avoid unnecessary update.
    /// 
    /// > Note: This does not trigger a direct update of the ``TileMapLayer``, the update will be done at the end of the frame as usual (unless you call ``updateInternals()``).
    /// 
    public final func notifyRuntimeTileDataUpdate() {
        gi.object_method_bind_ptrcall(TileMapLayer.method_notify_runtime_tile_data_update, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_map_pattern: GDExtensionMethodBindPtr = {
        let methodName = StringName("map_pattern")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1864516957)!
            }
            
        }
        
    }()
    
    /// Returns for the given coordinates `coordsInPattern` in a ``TileMapPattern`` the corresponding cell coordinates if the pattern was pasted at the `positionInTilemap` coordinates (see ``setPattern(position:pattern:)``). This mapping is required as in half-offset tile shapes, the mapping might not work by calculating `position_in_tile_map + coords_in_pattern`.
    public final func mapPattern(positionInTilemap: Vector2i, coordsInPattern: Vector2i, pattern: TileMapPattern?) -> Vector2i {
        var _result: Vector2i = Vector2i ()
        withUnsafePointer(to: positionInTilemap) { pArg0 in
            withUnsafePointer(to: coordsInPattern) { pArg1 in
                withUnsafePointer(to: pattern?.handle) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(TileMapLayer.method_map_pattern, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_surrounding_cells: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_surrounding_cells")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2673526557)!
            }
            
        }
        
    }()
    
    /// Returns the list of all neighboring cells to the one at `coords`.
    public final func getSurroundingCells(coords: Vector2i) -> VariantCollection<Vector2i> {
        var _result: Int64 = 0
        withUnsafePointer(to: coords) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMapLayer.method_get_surrounding_cells, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return VariantCollection<Vector2i>(content: _result)
    }
    
    fileprivate static var method_get_neighbor_cell: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_neighbor_cell")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 986575103)!
            }
            
        }
        
    }()
    
    /// Returns the neighboring cell to the one at coordinates `coords`, identified by the `neighbor` direction. This method takes into account the different layouts a TileMap can take.
    public final func getNeighborCell(coords: Vector2i, neighbor: TileSet.CellNeighbor) -> Vector2i {
        var _result: Vector2i = Vector2i ()
        withUnsafePointer(to: coords) { pArg0 in
            withUnsafePointer(to: neighbor.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(TileMapLayer.method_get_neighbor_cell, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_map_to_local: GDExtensionMethodBindPtr = {
        let methodName = StringName("map_to_local")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 108438297)!
            }
            
        }
        
    }()
    
    /// Returns the centered position of a cell in the ``TileMapLayer``'s local coordinate space. To convert the returned value into global coordinates, use ``Node2D/toGlobal(localPoint:)``. See also ``localToMap(localPosition:)``.
    /// 
    /// > Note: This may not correspond to the visual position of the tile, i.e. it ignores the ``TileData/textureOrigin`` property of individual tiles.
    /// 
    public final func mapToLocal(mapPosition: Vector2i) -> Vector2 {
        var _result: Vector2 = Vector2 ()
        withUnsafePointer(to: mapPosition) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMapLayer.method_map_to_local, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_local_to_map: GDExtensionMethodBindPtr = {
        let methodName = StringName("local_to_map")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 837806996)!
            }
            
        }
        
    }()
    
    /// Returns the map coordinates of the cell containing the given `localPosition`. If `localPosition` is in global coordinates, consider using ``Node2D/toLocal(globalPoint:)`` before passing it to this method. See also ``mapToLocal(mapPosition:)``.
    public final func localToMap(localPosition: Vector2) -> Vector2i {
        var _result: Vector2i = Vector2i ()
        withUnsafePointer(to: localPosition) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMapLayer.method_local_to_map, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_tile_map_data_from_array: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_tile_map_data_from_array")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2971499966)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_tile_map_data_from_array(_ tileMapLayerData: PackedByteArray) {
        withUnsafePointer(to: tileMapLayerData.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMapLayer.method_set_tile_map_data_from_array, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_tile_map_data_as_array: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_tile_map_data_as_array")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2362200018)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_tile_map_data_as_array() -> PackedByteArray {
        let _result: PackedByteArray = PackedByteArray ()
        gi.object_method_bind_ptrcall(TileMapLayer.method_get_tile_map_data_as_array, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_enabled")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_enabled(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMapLayer.method_set_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_enabled")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(TileMapLayer.method_is_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_tile_set: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_tile_set")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 774531446)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_tile_set(_ tileSet: TileSet?) {
        withUnsafePointer(to: tileSet?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMapLayer.method_set_tile_set, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_tile_set: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_tile_set")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2678226422)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_tile_set() -> TileSet? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall(TileMapLayer.method_get_tile_set, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_y_sort_origin: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_y_sort_origin")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_y_sort_origin(_ ySortOrigin: Int32) {
        withUnsafePointer(to: ySortOrigin) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMapLayer.method_set_y_sort_origin, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_y_sort_origin: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_y_sort_origin")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_y_sort_origin() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(TileMapLayer.method_get_y_sort_origin, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_x_draw_order_reversed: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_x_draw_order_reversed")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_x_draw_order_reversed(_ xDrawOrderReversed: Bool) {
        withUnsafePointer(to: xDrawOrderReversed) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMapLayer.method_set_x_draw_order_reversed, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_x_draw_order_reversed: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_x_draw_order_reversed")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_x_draw_order_reversed() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(TileMapLayer.method_is_x_draw_order_reversed, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_rendering_quadrant_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_rendering_quadrant_size")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_rendering_quadrant_size(_ size: Int32) {
        withUnsafePointer(to: size) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMapLayer.method_set_rendering_quadrant_size, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_rendering_quadrant_size: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_rendering_quadrant_size")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_rendering_quadrant_size() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(TileMapLayer.method_get_rendering_quadrant_size, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_collision_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_collision_enabled")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_collision_enabled(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMapLayer.method_set_collision_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_collision_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_collision_enabled")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_collision_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(TileMapLayer.method_is_collision_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_use_kinematic_bodies: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_use_kinematic_bodies")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_use_kinematic_bodies(_ useKinematicBodies: Bool) {
        withUnsafePointer(to: useKinematicBodies) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMapLayer.method_set_use_kinematic_bodies, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_using_kinematic_bodies: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_using_kinematic_bodies")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_using_kinematic_bodies() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(TileMapLayer.method_is_using_kinematic_bodies, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_collision_visibility_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_collision_visibility_mode")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3508099847)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_collision_visibility_mode(_ visibilityMode: TileMapLayer.DebugVisibilityMode) {
        withUnsafePointer(to: visibilityMode.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMapLayer.method_set_collision_visibility_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_collision_visibility_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_collision_visibility_mode")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 338220793)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_collision_visibility_mode() -> TileMapLayer.DebugVisibilityMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(TileMapLayer.method_get_collision_visibility_mode, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return TileMapLayer.DebugVisibilityMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_navigation_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_navigation_enabled")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_navigation_enabled(_ enabled: Bool) {
        withUnsafePointer(to: enabled) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMapLayer.method_set_navigation_enabled, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_navigation_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_navigation_enabled")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_navigation_enabled() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(TileMapLayer.method_is_navigation_enabled, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_navigation_map: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_navigation_map")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2722037293)!
            }
            
        }
        
    }()
    
    /// Sets a custom `map` as a ``NavigationServer2D`` navigation map. If not set, uses the default ``World2D`` navigation map instead.
    public final func setNavigationMap(_ map: RID) {
        withUnsafePointer(to: map.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMapLayer.method_set_navigation_map, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_navigation_map: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_navigation_map")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2944877500)!
            }
            
        }
        
    }()
    
    /// Returns the ``RID`` of the ``NavigationServer2D`` navigation used by this ``TileMapLayer``.
    /// 
    /// By default this returns the default ``World2D`` navigation map, unless a custom map was provided using ``setNavigationMap(_:)``.
    /// 
    public final func getNavigationMap() -> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall(TileMapLayer.method_get_navigation_map, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_navigation_visibility_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_navigation_visibility_mode")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3508099847)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_navigation_visibility_mode(_ showNavigation: TileMapLayer.DebugVisibilityMode) {
        withUnsafePointer(to: showNavigation.rawValue) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(TileMapLayer.method_set_navigation_visibility_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_navigation_visibility_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_navigation_visibility_mode")
        return withUnsafePointer(to: &TileMapLayer.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 338220793)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_navigation_visibility_mode() -> TileMapLayer.DebugVisibilityMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall(TileMapLayer.method_get_navigation_visibility_mode, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return TileMapLayer.DebugVisibilityMode (rawValue: _result)!
    }
    
    override class func getVirtualDispatcher (name: StringName) -> GDExtensionClassCallVirtual? {
        guard implementedOverrides().contains(name) else { return nil }
        switch name.description {
            case "_tile_data_runtime_update":
                return _TileMapLayer_proxy_tile_data_runtime_update
            case "_use_tile_data_runtime_update":
                return _TileMapLayer_proxy_use_tile_data_runtime_update
            default:
                return super.getVirtualDispatcher (name: name)
        }
        
    }
    
    // Signals 
    /// Emitted when this ``TileMapLayer``'s properties changes. This includes modified cells, properties, or changes made to its assigned ``TileSet``.
    /// 
    /// > Note: This signal may be emitted very often when batch-modifying a ``TileMapLayer``. Avoid executing complex processing in a connected function, and consider delaying it to the end of the frame instead (i.e. calling ``Object/callDeferred(method:)``).
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.changed.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var changed: SimpleSignal { SimpleSignal (target: self, signalName: "changed") }
    
}

// Support methods for proxies
func _TileMapLayer_proxy_tile_data_runtime_update (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<TileMapLayer>.fromOpaque(instance).takeUnretainedValue()
    let resolved_1 = args [1]!.load (as: UnsafeRawPointer.self)
    
    swiftObject._tileDataRuntimeUpdate (coords: args [0]!.assumingMemoryBound (to: Vector2i.self).pointee, tileData: lookupLiveObject (handleAddress: resolved_1) as? TileData ?? TileData (nativeHandle: resolved_1))
}

func _TileMapLayer_proxy_use_tile_data_runtime_update (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<TileMapLayer>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._useTileDataRuntimeUpdate (coords: args [0]!.assumingMemoryBound (to: Vector2i.self).pointee)
    retPtr!.storeBytes (of: ret, as: Bool.self)
}

