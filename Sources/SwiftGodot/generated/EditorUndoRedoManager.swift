// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
import Foundation
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Manages undo history of scenes opened in the editor.
/// 
/// ``EditorUndoRedoManager`` is a manager for ``UndoRedo`` objects associated with edited scenes. Each scene has its own undo history and ``EditorUndoRedoManager`` ensures that each action performed in the editor gets associated with a proper scene. For actions not related to scenes (``ProjectSettings`` edits, external resources, etc.), a separate global history is used.
/// 
/// The usage is mostly the same as ``UndoRedo``. You create and commit actions and the manager automatically decides under-the-hood what scenes it belongs to. The scene is deduced based on the first operation in an action, using the object from the operation. The rules are as follows:
/// 
/// - If the object is a ``Node``, use the currently edited scene;
/// 
/// - If the object is a built-in resource, use the scene from its path;
/// 
/// - If the object is external resource or anything else, use global history.
/// 
/// This guessing can sometimes yield false results, so you can provide a custom context object when creating an action.
/// 
/// ``EditorUndoRedoManager`` is intended to be used by Godot editor plugins. You can obtain it using ``EditorPlugin/getUndoRedo()``. For non-editor uses or plugins that don't need to integrate with the editor's undo history, use ``UndoRedo`` instead.
/// 
/// The manager's API is mostly the same as in ``UndoRedo``, so you can refer to its documentation for more examples. The main difference is that ``EditorUndoRedoManager`` uses object + method name for actions, instead of ``Callable``.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``historyChanged``
/// - ``versionChanged``
open class EditorUndoRedoManager: Object {
    override open class var godotClassName: StringName { "EditorUndoRedoManager" }
    public enum SpecialHistory: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Global history not associated with any scene, but with external resources etc.
        case globalHistory = 0 // GLOBAL_HISTORY
        /// History associated with remote inspector. Used when live editing a running project.
        case remoteHistory = -9 // REMOTE_HISTORY
        /// Invalid "null" history. It's a special value, not associated with any object.
        case invalidHistory = -99 // INVALID_HISTORY
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .globalHistory: return ".globalHistory"
                case .remoteHistory: return ".remoteHistory"
                case .invalidHistory: return ".invalidHistory"
            }
            
        }
        
    }
    
    /* Methods */
    fileprivate static var method_create_action: GDExtensionMethodBindPtr = {
        let methodName = StringName("create_action")
        return withUnsafePointer(to: &EditorUndoRedoManager.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2107025470)!
            }
            
        }
        
    }()
    
    /// Create a new action. After this is called, do all your calls to ``addDoMethod(object:method:)``, ``addUndoMethod(object:method:)``, ``addDoProperty(object:property:value:)``, and ``addUndoProperty(object:property:value:)``, then commit the action with ``commitAction(execute:)``.
    /// 
    /// The way actions are merged is dictated by the `mergeMode` argument. See ``UndoRedo.MergeMode`` for details.
    /// 
    /// If `customContext` object is provided, it will be used for deducing target history (instead of using the first operation).
    /// 
    /// The way undo operation are ordered in actions is dictated by `backwardUndoOps`. When `backwardUndoOps` is `false` undo option are ordered in the same order they were added. Which means the first operation to be added will be the first to be undone.
    /// 
    public final func createAction(name: String, mergeMode: UndoRedo.MergeMode = .disable, customContext: Object? = nil, backwardUndoOps: Bool = false) {
        let name = GString(name)
        withUnsafePointer(to: name.content) { pArg0 in
            withUnsafePointer(to: mergeMode.rawValue) { pArg1 in
                withUnsafePointer(to: customContext?.handle) { pArg2 in
                    withUnsafePointer(to: backwardUndoOps) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                gi.object_method_bind_ptrcall(EditorUndoRedoManager.method_create_action, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_commit_action: GDExtensionMethodBindPtr = {
        let methodName = StringName("commit_action")
        return withUnsafePointer(to: &EditorUndoRedoManager.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3216645846)!
            }
            
        }
        
    }()
    
    /// Commit the action. If `execute` is true (default), all "do" methods/properties are called/set when this function is called.
    public final func commitAction(execute: Bool = true) {
        withUnsafePointer(to: execute) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(EditorUndoRedoManager.method_commit_action, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_is_committing_action: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_committing_action")
        return withUnsafePointer(to: &EditorUndoRedoManager.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the ``EditorUndoRedoManager`` is currently committing the action, i.e. running its "do" method or property change (see ``commitAction(execute:)``).
    public final func isCommittingAction() -> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall(EditorUndoRedoManager.method_is_committing_action, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_force_fixed_history: GDExtensionMethodBindPtr = {
        let methodName = StringName("force_fixed_history")
        return withUnsafePointer(to: &EditorUndoRedoManager.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Forces the next operation (e.g. ``addDoMethod(object:method:)``) to use the action's history rather than guessing it from the object. This is sometimes needed when a history can't be correctly determined, like for a nested resource that doesn't have a path yet.
    /// 
    /// This method should only be used when absolutely necessary, otherwise it might cause invalid history state. For most of complex cases, the `custom_context` parameter of ``createAction(name:mergeMode:customContext:backwardUndoOps:)`` is sufficient.
    /// 
    public final func forceFixedHistory() {
        gi.object_method_bind_ptrcall(EditorUndoRedoManager.method_force_fixed_history, UnsafeMutableRawPointer(mutating: handle), nil, nil)
        
    }
    
    fileprivate static var method_add_do_method: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_do_method")
        return withUnsafePointer(to: &EditorUndoRedoManager.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1517810467)!
            }
            
        }
        
    }()
    
    /// Register a method that will be called when the action is committed (i.e. the "do" action).
    /// 
    /// If this is the first operation, the `object` will be used to deduce target undo history.
    /// 
    public final func addDoMethod(object: Object?, method: StringName, _ arguments: Variant...) {
        var _result: Variant.ContentType = Variant.zero
        let object = Variant(object)
        withUnsafePointer(to: object.content) { pArg0 in
            let method = Variant(method)
            withUnsafePointer(to: method.content) { pArg1 in
                if arguments.isEmpty {
                    withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                            gi.object_method_bind_call(EditorUndoRedoManager.method_add_do_method, UnsafeMutableRawPointer(mutating: handle), pArgs, 2, &_result, nil)
                        }
                        
                    }
                    
                } else {
                    // A temporary allocation containing pointers to `Variant.ContentType` of marshaled arguments
                    withUnsafeTemporaryAllocation(of: UnsafeRawPointer?.self, capacity: 2 + arguments.count) { pArgsBuffer in
                        defer { pArgsBuffer.deinitialize() }
                        guard let pArgs = pArgsBuffer.baseAddress else {
                            fatalError("pArgsBuffer.baseAddress is nil")
                        }
                        pArgsBuffer.initializeElement(at: 0, to: pArg0)
                        pArgsBuffer.initializeElement(at: 1, to: pArg1)
                        // A temporary allocation containing `Variant.ContentType` of marshaled arguments
                        withUnsafeTemporaryAllocation(of: Variant.ContentType.self, capacity: arguments.count) { contentsBuffer in
                            defer { contentsBuffer.deinitialize() }
                            guard let contentsPtr = contentsBuffer.baseAddress else {
                                fatalError("contentsBuffer.baseAddress is nil")
                            }
                            
                            for i in 0..<arguments.count {
                                // Copy `content`s of the variadic `Variant`s into `contentBuffer`
                                contentsBuffer.initializeElement(at: i, to: arguments[i].content)
                                // Initialize `pArgs` elements following mandatory arguments to point at respective contents of `contentsBuffer`                                        
                                pArgsBuffer.initializeElement(at: 2 + i, to: contentsPtr + i)
                            }
                        
                            gi.object_method_bind_call(EditorUndoRedoManager.method_add_do_method, UnsafeMutableRawPointer(mutating: handle), pArgs, Int64(2 + arguments.count), &_result, nil)
                        }                           
                    }
                    
                }
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_undo_method: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_undo_method")
        return withUnsafePointer(to: &EditorUndoRedoManager.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1517810467)!
            }
            
        }
        
    }()
    
    /// Register a method that will be called when the action is undone (i.e. the "undo" action).
    /// 
    /// If this is the first operation, the `object` will be used to deduce target undo history.
    /// 
    public final func addUndoMethod(object: Object?, method: StringName, _ arguments: Variant...) {
        var _result: Variant.ContentType = Variant.zero
        let object = Variant(object)
        withUnsafePointer(to: object.content) { pArg0 in
            let method = Variant(method)
            withUnsafePointer(to: method.content) { pArg1 in
                if arguments.isEmpty {
                    withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                            gi.object_method_bind_call(EditorUndoRedoManager.method_add_undo_method, UnsafeMutableRawPointer(mutating: handle), pArgs, 2, &_result, nil)
                        }
                        
                    }
                    
                } else {
                    // A temporary allocation containing pointers to `Variant.ContentType` of marshaled arguments
                    withUnsafeTemporaryAllocation(of: UnsafeRawPointer?.self, capacity: 2 + arguments.count) { pArgsBuffer in
                        defer { pArgsBuffer.deinitialize() }
                        guard let pArgs = pArgsBuffer.baseAddress else {
                            fatalError("pArgsBuffer.baseAddress is nil")
                        }
                        pArgsBuffer.initializeElement(at: 0, to: pArg0)
                        pArgsBuffer.initializeElement(at: 1, to: pArg1)
                        // A temporary allocation containing `Variant.ContentType` of marshaled arguments
                        withUnsafeTemporaryAllocation(of: Variant.ContentType.self, capacity: arguments.count) { contentsBuffer in
                            defer { contentsBuffer.deinitialize() }
                            guard let contentsPtr = contentsBuffer.baseAddress else {
                                fatalError("contentsBuffer.baseAddress is nil")
                            }
                            
                            for i in 0..<arguments.count {
                                // Copy `content`s of the variadic `Variant`s into `contentBuffer`
                                contentsBuffer.initializeElement(at: i, to: arguments[i].content)
                                // Initialize `pArgs` elements following mandatory arguments to point at respective contents of `contentsBuffer`                                        
                                pArgsBuffer.initializeElement(at: 2 + i, to: contentsPtr + i)
                            }
                        
                            gi.object_method_bind_call(EditorUndoRedoManager.method_add_undo_method, UnsafeMutableRawPointer(mutating: handle), pArgs, Int64(2 + arguments.count), &_result, nil)
                        }                           
                    }
                    
                }
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_do_property: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_do_property")
        return withUnsafePointer(to: &EditorUndoRedoManager.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1017172818)!
            }
            
        }
        
    }()
    
    /// Register a property value change for "do".
    /// 
    /// If this is the first operation, the `object` will be used to deduce target undo history.
    /// 
    public final func addDoProperty(object: Object?, property: StringName, value: Variant) {
        withUnsafePointer(to: object?.handle) { pArg0 in
            withUnsafePointer(to: property.content) { pArg1 in
                withUnsafePointer(to: value.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(EditorUndoRedoManager.method_add_do_property, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_undo_property: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_undo_property")
        return withUnsafePointer(to: &EditorUndoRedoManager.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1017172818)!
            }
            
        }
        
    }()
    
    /// Register a property value change for "undo".
    /// 
    /// If this is the first operation, the `object` will be used to deduce target undo history.
    /// 
    public final func addUndoProperty(object: Object?, property: StringName, value: Variant) {
        withUnsafePointer(to: object?.handle) { pArg0 in
            withUnsafePointer(to: property.content) { pArg1 in
                withUnsafePointer(to: value.content) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            gi.object_method_bind_ptrcall(EditorUndoRedoManager.method_add_undo_property, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_do_reference: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_do_reference")
        return withUnsafePointer(to: &EditorUndoRedoManager.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3975164845)!
            }
            
        }
        
    }()
    
    /// Register a reference for "do" that will be erased if the "do" history is lost. This is useful mostly for new nodes created for the "do" call. Do not use for resources.
    public final func addDoReference(object: Object?) {
        withUnsafePointer(to: object?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(EditorUndoRedoManager.method_add_do_reference, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_add_undo_reference: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_undo_reference")
        return withUnsafePointer(to: &EditorUndoRedoManager.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3975164845)!
            }
            
        }
        
    }()
    
    /// Register a reference for "undo" that will be erased if the "undo" history is lost. This is useful mostly for nodes removed with the "do" call (not the "undo" call!).
    public final func addUndoReference(object: Object?) {
        withUnsafePointer(to: object?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(EditorUndoRedoManager.method_add_undo_reference, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_object_history_id: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_object_history_id")
        return withUnsafePointer(to: &EditorUndoRedoManager.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1107568780)!
            }
            
        }
        
    }()
    
    /// Returns the history ID deduced from the given `object`. It can be used with ``getHistoryUndoRedo(id:)``.
    public final func getObjectHistoryId(object: Object?) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: object?.handle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(EditorUndoRedoManager.method_get_object_history_id, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_history_undo_redo: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_history_undo_redo")
        return withUnsafePointer(to: &EditorUndoRedoManager.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2417974513)!
            }
            
        }
        
    }()
    
    /// Returns the ``UndoRedo`` object associated with the given history `id`.
    /// 
    /// `id` above `0` are mapped to the opened scene tabs (but it doesn't match their order). `id` of `0` or lower have special meaning (see ``EditorUndoRedoManager/SpecialHistory``).
    /// 
    /// Best used with ``getObjectHistoryId(object:)``. This method is only provided in case you need some more advanced methods of ``UndoRedo`` (but keep in mind that directly operating on the ``UndoRedo`` object might affect editor's stability).
    /// 
    public final func getHistoryUndoRedo(id: Int32) -> UndoRedo? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: id) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(EditorUndoRedoManager.method_get_history_undo_redo, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    // Signals 
    /// Emitted when the list of actions in any history has changed, either when an action is committed or a history is cleared.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.historyChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var historyChanged: SimpleSignal { SimpleSignal (target: self, signalName: "history_changed") }
    
    /// Emitted when the version of any history has changed as a result of undo or redo call.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.versionChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var versionChanged: SimpleSignal { SimpleSignal (target: self, signalName: "version_changed") }
    
}

