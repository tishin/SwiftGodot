// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
import Foundation
#endif
// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Audio stream that can playback music interactively, combining clips and a transition table.
/// 
/// This is an audio stream that can playback music interactively, combining clips and a transition table. Clips must be added first, and the transition rules via the ``addTransition(fromClip:toClip:fromTime:toTime:fadeMode:fadeBeats:useFillerClip:fillerClip:holdPrevious:)``. Additionally, this stream export a property parameter to control the playback via ``AudioStreamPlayer``, ``AudioStreamPlayer2D``, or ``AudioStreamPlayer3D``.
/// 
/// The way this is used is by filling a number of clips, then configuring the transition table. From there, clips are selected for playback and the music will smoothly go from the current to the new one while using the corresponding transition rule defined in the transition table.
/// 
open class AudioStreamInteractive: AudioStream {
    override open class var godotClassName: StringName { "AudioStreamInteractive" }
    public enum TransitionFromTime: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Start transition as soon as possible, don't wait for any specific time position.
        case immediate = 0 // TRANSITION_FROM_TIME_IMMEDIATE
        /// Transition when the clip playback position reaches the next beat.
        case nextBeat = 1 // TRANSITION_FROM_TIME_NEXT_BEAT
        /// Transition when the clip playback position reaches the next bar.
        case nextBar = 2 // TRANSITION_FROM_TIME_NEXT_BAR
        /// Transition when the current clip finished playing.
        case end = 3 // TRANSITION_FROM_TIME_END
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .immediate: return ".immediate"
                case .nextBeat: return ".nextBeat"
                case .nextBar: return ".nextBar"
                case .end: return ".end"
            }
            
        }
        
    }
    
    public enum TransitionToTime: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Transition to the same position in the destination clip. This is useful when both clips have exactly the same length and the music should fade between them.
        case samePosition = 0 // TRANSITION_TO_TIME_SAME_POSITION
        /// Transition to the start of the destination clip.
        case start = 1 // TRANSITION_TO_TIME_START
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .samePosition: return ".samePosition"
                case .start: return ".start"
            }
            
        }
        
    }
    
    public enum FadeMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Do not use fade for the transition. This is useful when transitioning from a clip-end to clip-beginning, and each clip has their begin/end.
        case disabled = 0 // FADE_DISABLED
        /// Use a fade-in in the next clip, let the current clip finish.
        case `in` = 1 // FADE_IN
        /// Use a fade-out in the current clip, the next clip will start by itself.
        case out = 2 // FADE_OUT
        /// Use a cross-fade between clips.
        case cross = 3 // FADE_CROSS
        /// Use automatic fade logic depending on the transition from/to. It is recommended to use this by default.
        case automatic = 4 // FADE_AUTOMATIC
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .disabled: return ".disabled"
                case .`in`: return ".`in`"
                case .out: return ".out"
                case .cross: return ".cross"
                case .automatic: return ".automatic"
            }
            
        }
        
    }
    
    public enum AutoAdvanceMode: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Disable auto-advance (default).
        case disabled = 0 // AUTO_ADVANCE_DISABLED
        /// Enable auto-advance, a clip must be specified.
        case enabled = 1 // AUTO_ADVANCE_ENABLED
        /// Enable auto-advance, but instead of specifying a clip, the playback will return to hold (see ``addTransition(fromClip:toClip:fromTime:toTime:fadeMode:fadeBeats:useFillerClip:fillerClip:holdPrevious:)``).
        case returnToHold = 2 // AUTO_ADVANCE_RETURN_TO_HOLD
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .disabled: return ".disabled"
                case .enabled: return ".enabled"
                case .returnToHold: return ".returnToHold"
            }
            
        }
        
    }
    
    /* Constants */
    /// This constant describes that any clip is valid for a specific transition as either source or destination.
    public static let clipAny = -1
    
    /* Properties */
    
    /// Index of the initial clip, which will be played first when this stream is played.
    final public var initialClip: Int32 {
        get {
            return get_initial_clip ()
        }
        
        set {
            set_initial_clip (newValue)
        }
        
    }
    
    /// Amount of clips contained in this interactive player.
    final public var clipCount: Int32 {
        get {
            return get_clip_count ()
        }
        
        set {
            set_clip_count (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_set_clip_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_clip_count")
        return withUnsafePointer(to: &AudioStreamInteractive.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_clip_count(_ clipCount: Int32) {
        withUnsafePointer(to: clipCount) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(AudioStreamInteractive.method_set_clip_count, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_clip_count: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_clip_count")
        return withUnsafePointer(to: &AudioStreamInteractive.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_clip_count() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(AudioStreamInteractive.method_get_clip_count, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_initial_clip: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_initial_clip")
        return withUnsafePointer(to: &AudioStreamInteractive.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_initial_clip(_ clipIndex: Int32) {
        withUnsafePointer(to: clipIndex) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(AudioStreamInteractive.method_set_initial_clip, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_initial_clip: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_initial_clip")
        return withUnsafePointer(to: &AudioStreamInteractive.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_initial_clip() -> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall(AudioStreamInteractive.method_get_initial_clip, UnsafeMutableRawPointer(mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_clip_name: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_clip_name")
        return withUnsafePointer(to: &AudioStreamInteractive.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3780747571)!
            }
            
        }
        
    }()
    
    /// Set the name of the current clip (for easier identification).
    public final func setClipName(clipIndex: Int32, name: StringName) {
        withUnsafePointer(to: clipIndex) { pArg0 in
            withUnsafePointer(to: name.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(AudioStreamInteractive.method_set_clip_name, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_clip_name: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_clip_name")
        return withUnsafePointer(to: &AudioStreamInteractive.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 659327637)!
            }
            
        }
        
    }()
    
    /// Return the name of a clip.
    public final func getClipName(clipIndex: Int32) -> StringName {
        let _result: StringName = StringName ()
        withUnsafePointer(to: clipIndex) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(AudioStreamInteractive.method_get_clip_name, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result.content)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_set_clip_stream: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_clip_stream")
        return withUnsafePointer(to: &AudioStreamInteractive.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 111075094)!
            }
            
        }
        
    }()
    
    /// Set the ``AudioStream`` associated with the current clip.
    public final func setClipStream(clipIndex: Int32, stream: AudioStream?) {
        withUnsafePointer(to: clipIndex) { pArg0 in
            withUnsafePointer(to: stream?.handle) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(AudioStreamInteractive.method_set_clip_stream, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_clip_stream: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_clip_stream")
        return withUnsafePointer(to: &AudioStreamInteractive.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2739380747)!
            }
            
        }
        
    }()
    
    /// Return the ``AudioStream`` associated with a clip.
    public final func getClipStream(clipIndex: Int32) -> AudioStream? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        withUnsafePointer(to: clipIndex) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(AudioStreamInteractive.method_get_clip_stream, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_clip_auto_advance: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_clip_auto_advance")
        return withUnsafePointer(to: &AudioStreamInteractive.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 57217598)!
            }
            
        }
        
    }()
    
    /// Set whether a clip will auto-advance by changing the auto-advance mode.
    public final func setClipAutoAdvance(clipIndex: Int32, mode: AudioStreamInteractive.AutoAdvanceMode) {
        withUnsafePointer(to: clipIndex) { pArg0 in
            withUnsafePointer(to: mode.rawValue) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(AudioStreamInteractive.method_set_clip_auto_advance, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_clip_auto_advance: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_clip_auto_advance")
        return withUnsafePointer(to: &AudioStreamInteractive.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1778634807)!
            }
            
        }
        
    }()
    
    /// Return whether a clip has auto-advance enabled. See ``setClipAutoAdvance(clipIndex:mode:)``.
    public final func getClipAutoAdvance(clipIndex: Int32) -> AudioStreamInteractive.AutoAdvanceMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: clipIndex) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(AudioStreamInteractive.method_get_clip_auto_advance, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return AudioStreamInteractive.AutoAdvanceMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_clip_auto_advance_next_clip: GDExtensionMethodBindPtr = {
        let methodName = StringName("set_clip_auto_advance_next_clip")
        return withUnsafePointer(to: &AudioStreamInteractive.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Set the index of the next clip towards which this clip will auto advance to when finished. If the clip being played loops, then auto-advance will be ignored.
    public final func setClipAutoAdvanceNextClip(clipIndex: Int32, autoAdvanceNextClip: Int32) {
        withUnsafePointer(to: clipIndex) { pArg0 in
            withUnsafePointer(to: autoAdvanceNextClip) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(AudioStreamInteractive.method_set_clip_auto_advance_next_clip, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_clip_auto_advance_next_clip: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_clip_auto_advance_next_clip")
        return withUnsafePointer(to: &AudioStreamInteractive.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Return the clip towards which the clip referenced by `clipIndex` will auto-advance to.
    public final func getClipAutoAdvanceNextClip(clipIndex: Int32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: clipIndex) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    gi.object_method_bind_ptrcall(AudioStreamInteractive.method_get_clip_auto_advance_next_clip, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_add_transition: GDExtensionMethodBindPtr = {
        let methodName = StringName("add_transition")
        return withUnsafePointer(to: &AudioStreamInteractive.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1630280552)!
            }
            
        }
        
    }()
    
    /// Add a transition between two clips. Provide the indices of the source and destination clips, or use the ``clipAny`` constant to indicate that transition happens to/from any clip to this one.
    /// 
    /// * `fromTime` indicates the moment in the current clip the transition will begin after triggered.
    /// 
    /// * `toTime` indicates the time in the next clip that the playback will start from.
    /// 
    /// * `fadeMode` indicates how the fade will happen between clips. If unsure, just use .fadeAutomatic which uses the most common type of fade for each situation.
    /// 
    /// * `fadeBeats` indicates how many beats the fade will take. Using decimals is allowed.
    /// 
    /// * `useFillerClip` indicates that there will be a filler clip used between the source and destination clips.
    /// 
    /// * `fillerClip` the index of the filler clip.
    /// 
    /// * If `holdPrevious` is used, then this clip will be remembered. This can be used together with .autoAdvanceReturnToHold to return to this clip after another is done playing.
    /// 
    public final func addTransition(fromClip: Int32, toClip: Int32, fromTime: AudioStreamInteractive.TransitionFromTime, toTime: AudioStreamInteractive.TransitionToTime, fadeMode: AudioStreamInteractive.FadeMode, fadeBeats: Double, useFillerClip: Bool = false, fillerClip: Int32 = -1, holdPrevious: Bool = false) {
        withUnsafePointer(to: fromClip) { pArg0 in
            withUnsafePointer(to: toClip) { pArg1 in
                withUnsafePointer(to: fromTime.rawValue) { pArg2 in
                    withUnsafePointer(to: toTime.rawValue) { pArg3 in
                        withUnsafePointer(to: fadeMode.rawValue) { pArg4 in
                            withUnsafePointer(to: fadeBeats) { pArg5 in
                                withUnsafePointer(to: useFillerClip) { pArg6 in
                                    withUnsafePointer(to: fillerClip) { pArg7 in
                                        withUnsafePointer(to: holdPrevious) { pArg8 in
                                            withUnsafePointer(to: UnsafeRawPointersN9(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6, pArg7, pArg8)) { pArgs in
                                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 9) { pArgs in
                                                    gi.object_method_bind_ptrcall(AudioStreamInteractive.method_add_transition, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                                                }
                                                
                                            }
                                            
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_has_transition: GDExtensionMethodBindPtr = {
        let methodName = StringName("has_transition")
        return withUnsafePointer(to: &AudioStreamInteractive.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2522259332)!
            }
            
        }
        
    }()
    
    /// Return true if a given transition exists (was added via ``addTransition(fromClip:toClip:fromTime:toTime:fadeMode:fadeBeats:useFillerClip:fillerClip:holdPrevious:)``).
    public final func hasTransition(fromClip: Int32, toClip: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: fromClip) { pArg0 in
            withUnsafePointer(to: toClip) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(AudioStreamInteractive.method_has_transition, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_erase_transition: GDExtensionMethodBindPtr = {
        let methodName = StringName("erase_transition")
        return withUnsafePointer(to: &AudioStreamInteractive.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Erase a transition by providing `fromClip` and `toClip` clip indices. ``clipAny`` can be used for either argument or both.
    public final func eraseTransition(fromClip: Int32, toClip: Int32) {
        withUnsafePointer(to: fromClip) { pArg0 in
            withUnsafePointer(to: toClip) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(AudioStreamInteractive.method_erase_transition, UnsafeMutableRawPointer(mutating: handle), pArgs, nil)
                    }
                    
                }
                
            }
            
        }
        
        
    }
    
    fileprivate static var method_get_transition_list: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_transition_list")
        return withUnsafePointer(to: &AudioStreamInteractive.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1930428628)!
            }
            
        }
        
    }()
    
    /// Return the list of transitions (from, to interleaved).
    public final func getTransitionList() -> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        gi.object_method_bind_ptrcall(AudioStreamInteractive.method_get_transition_list, UnsafeMutableRawPointer(mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_get_transition_from_time: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_transition_from_time")
        return withUnsafePointer(to: &AudioStreamInteractive.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3453338158)!
            }
            
        }
        
    }()
    
    /// Return the source time position for a transition (see ``addTransition(fromClip:toClip:fromTime:toTime:fadeMode:fadeBeats:useFillerClip:fillerClip:holdPrevious:)``).
    public final func getTransitionFromTime(fromClip: Int32, toClip: Int32) -> AudioStreamInteractive.TransitionFromTime {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: fromClip) { pArg0 in
            withUnsafePointer(to: toClip) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(AudioStreamInteractive.method_get_transition_from_time, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return AudioStreamInteractive.TransitionFromTime (rawValue: _result)!
    }
    
    fileprivate static var method_get_transition_to_time: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_transition_to_time")
        return withUnsafePointer(to: &AudioStreamInteractive.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 1369651373)!
            }
            
        }
        
    }()
    
    /// Return the destination time position for a transition (see ``addTransition(fromClip:toClip:fromTime:toTime:fadeMode:fadeBeats:useFillerClip:fillerClip:holdPrevious:)``).
    public final func getTransitionToTime(fromClip: Int32, toClip: Int32) -> AudioStreamInteractive.TransitionToTime {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: fromClip) { pArg0 in
            withUnsafePointer(to: toClip) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(AudioStreamInteractive.method_get_transition_to_time, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return AudioStreamInteractive.TransitionToTime (rawValue: _result)!
    }
    
    fileprivate static var method_get_transition_fade_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_transition_fade_mode")
        return withUnsafePointer(to: &AudioStreamInteractive.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 4065396087)!
            }
            
        }
        
    }()
    
    /// Return the mode for a transition (see ``addTransition(fromClip:toClip:fromTime:toTime:fadeMode:fadeBeats:useFillerClip:fillerClip:holdPrevious:)``).
    public final func getTransitionFadeMode(fromClip: Int32, toClip: Int32) -> AudioStreamInteractive.FadeMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        withUnsafePointer(to: fromClip) { pArg0 in
            withUnsafePointer(to: toClip) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(AudioStreamInteractive.method_get_transition_fade_mode, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return AudioStreamInteractive.FadeMode (rawValue: _result)!
    }
    
    fileprivate static var method_get_transition_fade_beats: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_transition_fade_beats")
        return withUnsafePointer(to: &AudioStreamInteractive.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3085491603)!
            }
            
        }
        
    }()
    
    /// Return the time (in beats) for a transition (see ``addTransition(fromClip:toClip:fromTime:toTime:fadeMode:fadeBeats:useFillerClip:fillerClip:holdPrevious:)``).
    public final func getTransitionFadeBeats(fromClip: Int32, toClip: Int32) -> Double {
        var _result: Double = 0.0
        withUnsafePointer(to: fromClip) { pArg0 in
            withUnsafePointer(to: toClip) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(AudioStreamInteractive.method_get_transition_fade_beats, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_transition_using_filler_clip: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_transition_using_filler_clip")
        return withUnsafePointer(to: &AudioStreamInteractive.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2522259332)!
            }
            
        }
        
    }()
    
    /// Return whether a transition uses the _filler clip_ functionality (see ``addTransition(fromClip:toClip:fromTime:toTime:fadeMode:fadeBeats:useFillerClip:fillerClip:holdPrevious:)``).
    public final func isTransitionUsingFillerClip(fromClip: Int32, toClip: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: fromClip) { pArg0 in
            withUnsafePointer(to: toClip) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(AudioStreamInteractive.method_is_transition_using_filler_clip, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_get_transition_filler_clip: GDExtensionMethodBindPtr = {
        let methodName = StringName("get_transition_filler_clip")
        return withUnsafePointer(to: &AudioStreamInteractive.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 3175239445)!
            }
            
        }
        
    }()
    
    /// Return the filler clip for a transition (see ``addTransition(fromClip:toClip:fromTime:toTime:fadeMode:fadeBeats:useFillerClip:fillerClip:holdPrevious:)``).
    public final func getTransitionFillerClip(fromClip: Int32, toClip: Int32) -> Int32 {
        var _result: Int32 = 0
        withUnsafePointer(to: fromClip) { pArg0 in
            withUnsafePointer(to: toClip) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(AudioStreamInteractive.method_get_transition_filler_clip, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
    fileprivate static var method_is_transition_holding_previous: GDExtensionMethodBindPtr = {
        let methodName = StringName("is_transition_holding_previous")
        return withUnsafePointer(to: &AudioStreamInteractive.godotClassName.content) { classPtr in
            withUnsafePointer(to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind(classPtr, mnamePtr, 2522259332)!
            }
            
        }
        
    }()
    
    /// Return whether a transition uses the _hold previous_ functionality (see ``addTransition(fromClip:toClip:fromTime:toTime:fadeMode:fadeBeats:useFillerClip:fillerClip:holdPrevious:)``).
    public final func isTransitionHoldingPrevious(fromClip: Int32, toClip: Int32) -> Bool {
        var _result: Bool = false
        withUnsafePointer(to: fromClip) { pArg0 in
            withUnsafePointer(to: toClip) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        gi.object_method_bind_ptrcall(AudioStreamInteractive.method_is_transition_holding_previous, UnsafeMutableRawPointer(mutating: handle), pArgs, &_result)
                    }
                    
                }
                
            }
            
        }
        
        return _result
    }
    
}

