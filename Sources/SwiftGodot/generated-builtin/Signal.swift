// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
import Foundation
#endif
/// A built-in type representing a signal of an ``Object``.
/// 
/// ``Signal`` is a built-in ``Variant`` type that represents a signal of an ``Object`` instance. Like all ``Variant`` types, it can be stored in variables and passed to functions. Signals allow all connected ``Callable``s (and by extension their respective objects) to listen and react to events, without directly referencing one another. This keeps the code flexible and easier to manage.
/// 
/// In GDScript, signals can be declared with the `signal` keyword. In C#, you may use the ```Signal``` attribute on a delegate.
/// 
public class Signal: Equatable {
    static var destructor: GDExtensionPtrDestructor = {
        return gi.variant_get_ptr_destructor (GDEXTENSION_VARIANT_TYPE_SIGNAL)!
    }()
    
    deinit {
        if content != Signal.zero {
            Signal.destructor (&content)
        }
        
    }
    
    // Contains a binary blob where this type information is stored
    public var content: ContentType = (0, 0)
    // Used to initialize empty types
    public static let zero: ContentType  = (0, 0)
    // Convenience type that matches the build configuration storage needs
    public typealias ContentType = (Int64, Int64)
    // Used to construct objects on virtual proxies
    public required init(content proxyContent: ContentType) {
        withUnsafePointer(to: proxyContent) { pContent in
            withUnsafePointer(to: pContent) { pArgs in
                Signal.constructor1(&content, pArgs)
            }
        }
    }
    // Used to construct objects when the underlying built-in's ref count has already been incremented for me
    public required init(alreadyOwnedContent content: ContentType) {
        self.content = content
    }
    
    static var constructor0: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_SIGNAL, 0)!
    
    /// Constructs an empty ``Signal`` with no object nor signal name bound.
    public required init () {
        Signal.constructor0(&content, nil)
    }
    
    static var constructor1: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_SIGNAL, 1)!
    
    /// Constructs a ``Signal`` as a copy of the given ``Signal``.
    public init (from: Signal) {
        withUnsafePointer(to: from.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    Signal.constructor1(&content, pArgs)
                }
                
            }
            
        }
        
    }
    
    static var constructor2: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_SIGNAL, 2)!
    
    /// Creates a new ``Signal`` named `signal` in the specified `object`.
    public init (object: Object, signal: StringName) {
        withUnsafePointer(to: object.handle) { pArg0 in
            withUnsafePointer(to: signal.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        Signal.constructor2(&content, pArgs)
                    }
                    
                }
                
            }
            
        }
        
    }
    
    
    /* Methods */
    
    static var method_is_null: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_null")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_SIGNAL, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if the signal's name does not exist in its object, or the object is not valid.
    public final func isNull()-> Bool {
        var result: Bool = Bool()
        Signal.method_is_null(&content, nil, &result, 0)
        return result
    }
    
    static var method_get_object_id: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_object_id")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_SIGNAL, &name.content, 3173160232)!
    }()
    
    /// Returns the ID of the object emitting this signal (see ``Object/getInstanceId()``).
    public final func getObjectId()-> Int64 {
        var result: Int64 = Int64()
        Signal.method_get_object_id(&content, nil, &result, 0)
        return result
    }
    
    static var method_get_name: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_name")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_SIGNAL, &name.content, 1825232092)!
    }()
    
    /// Returns the name of this signal.
    public final func getName()-> StringName {
        let result: StringName = StringName()
        Signal.method_get_name(&content, nil, &result.content, 0)
        return result
    }
    
    static var method_connect: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("connect")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_SIGNAL, &name.content, 979702392)!
    }()
    
    /// Connects this signal to the specified `callable`. Optional `flags` can be also added to configure the connection's behavior (see ``Object.ConnectFlags`` constants). You can provide additional arguments to the connected `callable` by using ``Callable/bind()``.
    /// 
    /// A signal can only be connected once to the same ``Callable``. If the signal is already connected, returns ``GodotError/errInvalidParameter`` and pushes an error message, unless the signal is connected with ``Object/ConnectFlags/connectReferenceCounted``. To prevent this, use ``isConnected(callable:)`` first to check for existing connections.
    /// 
    public final func connect(callable: Callable, flags: Int64 = 0)-> Int64 {
        var result: Int64 = Int64()
        withUnsafePointer(to: callable.content) { pArg0 in
            withUnsafePointer(to: flags) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        Signal.method_connect(&content, pArgs, &result, 2)
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_disconnect: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("disconnect")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_SIGNAL, &name.content, 3470848906)!
    }()
    
    /// Disconnects this signal from the specified ``Callable``. If the connection does not exist, generates an error. Use ``isConnected(callable:)`` to make sure that the connection exists.
    public final func disconnect(callable: Callable) {
        withUnsafePointer(to: callable.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    Signal.method_disconnect(&content, pArgs, nil, 1)
                }
                
            }
            
        }
        
    }
    
    static var method_is_connected: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_connected")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_SIGNAL, &name.content, 4129521963)!
    }()
    
    /// Returns `true` if the specified ``Callable`` is connected to this signal.
    public final func isConnected(callable: Callable)-> Bool {
        var result: Bool = Bool()
        withUnsafePointer(to: callable.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    Signal.method_is_connected(&content, pArgs, &result, 1)
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_get_connections: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_connections")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_SIGNAL, &name.content, 4144163970)!
    }()
    
    /// Returns an ``GArray`` of connections for this signal. Each connection is represented as a ``GDictionary`` that contains three entries:
    /// 
    /// - `signal` is a reference to this signal;
    /// 
    /// - `callable` is a reference to the connected ``Callable``;
    /// 
    /// - `flags` is a combination of ``Object.ConnectFlags``.
    /// 
    public final func getConnections()-> GArray {
        let result: GArray = GArray()
        Signal.method_get_connections(&content, nil, &result.content, 0)
        return result
    }
    
    static var method_emit: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("emit")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_SIGNAL, &name.content, 3286317445)!
    }()
    
    /// Emits this signal. All ``Callable``s connected to this signal will be triggered. This method supports a variable number of arguments, so parameters can be passed as a comma separated list.
    public final func emit(_ arguments: Variant...) {
        if arguments.isEmpty {
            Signal.method_emit(&content, nil, nil, 0) // no arguments
        } else {
            // A temporary allocation containing pointers to `Variant.ContentType` of marshaled arguments
            withUnsafeTemporaryAllocation(of: UnsafeRawPointer?.self, capacity: arguments.count) { pArgsBuffer in
                // We use entire buffer so can initialize every element in the end. It's not
                // necessary for UnsafeRawPointer and other POD types (which Variant.ContentType also is)
                // but we'll do it for the sake of correctness
                defer { pArgsBuffer.deinitialize() }
                guard let pArgs = pArgsBuffer.baseAddress else {
                    fatalError("pargsBuffer.baseAddress is nil")
                }
                // A temporary allocation containing `Variant.ContentType` of marshaled arguments
                withUnsafeTemporaryAllocation(of: Variant.ContentType.self, capacity: arguments.count) { contentsBuffer in
                    defer { contentsBuffer.deinitialize() }
                    guard let contentsPtr = contentsBuffer.baseAddress else {
                        fatalError("contentsBuffer.baseAddress is nil")
                    }
        
                    for i in 0..<arguments.count {
                        // Copy `content`s of the variadic `Variant`s into `contentBuffer`
                        contentsBuffer.initializeElement(at: i, to: arguments[i].content)
                        // Initialize `pArgs` elements following mandatory arguments to point at respective contents of `contentsBuffer`
                        pArgsBuffer.initializeElement(at: i, to: contentsPtr + i)
                    }
        
                    Signal.method_emit(&content, pArgs, nil, Int32(arguments.count))
                }
            }
        }
    }
    
    static var operator_3: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_EQUAL, GDEXTENSION_VARIANT_TYPE_SIGNAL, GDEXTENSION_VARIANT_TYPE_SIGNAL)!
    }()
    
    /// Returns `true` if both signals share the same object and name.
    public static func == (lhs: Signal, rhs: Signal) -> Bool  {
        var result: Bool = Bool()
        withUnsafePointer(to: lhs.content) { pArg0 in
            withUnsafePointer(to: rhs.content) { pArg1 in
                Signal.operator_3(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_4: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_NOT_EQUAL, GDEXTENSION_VARIANT_TYPE_SIGNAL, GDEXTENSION_VARIANT_TYPE_SIGNAL)!
    }()
    
    /// Returns `true` if the signals do not share the same object and name.
    public static func != (lhs: Signal, rhs: Signal) -> Bool  {
        var result: Bool = Bool()
        withUnsafePointer(to: lhs.content) { pArg0 in
            withUnsafePointer(to: rhs.content) { pArg1 in
                Signal.operator_4(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
}

