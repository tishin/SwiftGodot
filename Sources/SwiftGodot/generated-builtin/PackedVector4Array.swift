// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
import Foundation
#endif
/// A packed array of ``Vector4``s.
/// 
/// An array specifically designed to hold ``Vector4``. Packs data tightly, so it saves memory for large array sizes.
/// 
/// > Note: Packed arrays are always passed by reference. To get a copy of an array that can be modified independently of the original array, use ``duplicate()``. This is _not_ the case for built-in properties and methods. The returned packed array of these are a copies, and changing it will _not_ affect the original value. To update a built-in property you need to modify the returned array, and then assign it to the property again.
/// 
public class PackedVector4Array: Equatable, Collection, RandomAccessCollection {
    static var destructor: GDExtensionPtrDestructor = {
        return gi.variant_get_ptr_destructor (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY)!
    }()
    
    deinit {
        if content != PackedVector4Array.zero {
            PackedVector4Array.destructor (&content)
        }
        
    }
    
    /// The number of elements in the array
    public var count: Int { Int (size()) }
    // Contains a binary blob where this type information is stored
    public var content: ContentType = (0, 0)
    // Used to initialize empty types
    public static let zero: ContentType  = (0, 0)
    // Convenience type that matches the build configuration storage needs
    public typealias ContentType = (Int64, Int64)
    // Used to construct objects on virtual proxies
    public required init(content proxyContent: ContentType) {
        withUnsafePointer(to: proxyContent) { pContent in
            withUnsafePointer(to: pContent) { pArgs in
                PackedVector4Array.constructor1(&content, pArgs)
            }
        }
    }
    // Used to construct objects when the underlying built-in's ref count has already been incremented for me
    public required init(alreadyOwnedContent content: ContentType) {
        self.content = content
    }
    
    static var constructor0: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, 0)!
    
    /// Constructs an empty ``PackedVector4Array``.
    public required init () {
        PackedVector4Array.constructor0(&content, nil)
    }
    
    static var constructor1: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, 1)!
    
    /// Constructs a ``PackedVector4Array`` as a copy of the given ``PackedVector4Array``.
    public init (from: PackedVector4Array) {
        withUnsafePointer(to: from.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    PackedVector4Array.constructor1(&content, pArgs)
                }
                
            }
            
        }
        
    }
    
    static var constructor2: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, 2)!
    
    /// Constructs a new ``PackedVector4Array``. Optionally, you can pass in a generic ``GArray`` that will be converted.
    /// 
    /// > Note: When initializing a ``PackedVector4Array`` with elements, it must be initialized with an ``GArray`` of ``Vector4`` values:
    /// 
    public init (from: GArray) {
        withUnsafePointer(to: from.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    PackedVector4Array.constructor2(&content, pArgs)
                }
                
            }
            
        }
        
    }
    
    
    /* Methods */
    
    static var method_size: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("size")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, &name.content, 3173160232)!
    }()
    
    /// Returns the number of elements in the array.
    public final func size()-> Int64 {
        var result: Int64 = Int64()
        PackedVector4Array.method_size(&content, nil, &result, 0)
        return result
    }
    
    static var method_is_empty: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_empty")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if the array is empty.
    public final func isEmpty()-> Bool {
        var result: Bool = Bool()
        PackedVector4Array.method_is_empty(&content, nil, &result, 0)
        return result
    }
    
    static var method_set: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("set")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, &name.content, 1350366223)!
    }()
    
    /// Changes the ``Vector4`` at the given index.
    public final func set(index: Int64, value: Vector4) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: value) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        PackedVector4Array.method_set(&content, pArgs, nil, 2)
                    }
                    
                }
                
            }
            
        }
        
    }
    
    static var method_push_back: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("push_back")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, &name.content, 3289167688)!
    }()
    
    /// Inserts a ``Vector4`` at the end.
    @discardableResult /* 1: push_back */ 
    public final func pushBack(value: Vector4)-> Bool {
        var result: Bool = Bool()
        withUnsafePointer(to: value) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    PackedVector4Array.method_push_back(&content, pArgs, &result, 1)
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_append: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("append")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, &name.content, 3289167688)!
    }()
    
    /// Appends an element at the end of the array (alias of ``pushBack(value:)``).
    @discardableResult /* 1: append */ 
    public final func append(value: Vector4)-> Bool {
        var result: Bool = Bool()
        withUnsafePointer(to: value) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    PackedVector4Array.method_append(&content, pArgs, &result, 1)
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_append_array: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("append_array")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, &name.content, 537428395)!
    }()
    
    /// Appends a ``PackedVector4Array`` at the end of this array.
    public final func appendArray(_ array: PackedVector4Array) {
        withUnsafePointer(to: array.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    PackedVector4Array.method_append_array(&content, pArgs, nil, 1)
                }
                
            }
            
        }
        
    }
    
    static var method_remove_at: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("remove_at")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, &name.content, 2823966027)!
    }()
    
    /// Removes an element from the array by index.
    public final func removeAt(index: Int64) {
        withUnsafePointer(to: index) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    PackedVector4Array.method_remove_at(&content, pArgs, nil, 1)
                }
                
            }
            
        }
        
    }
    
    static var method_insert: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("insert")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, &name.content, 11085009)!
    }()
    
    /// Inserts a new element at a given position in the array. The position must be valid, or at the end of the array (`idx == size()`).
    public final func insert(atIndex: Int64, value: Vector4)-> Int64 {
        var result: Int64 = Int64()
        withUnsafePointer(to: atIndex) { pArg0 in
            withUnsafePointer(to: value) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        PackedVector4Array.method_insert(&content, pArgs, &result, 2)
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_fill: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("fill")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, &name.content, 3761353134)!
    }()
    
    /// Assigns the given value to all elements in the array. This can typically be used together with ``resize(newSize:)`` to create an array with a given size and initialized elements.
    public final func fill(value: Vector4) {
        withUnsafePointer(to: value) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    PackedVector4Array.method_fill(&content, pArgs, nil, 1)
                }
                
            }
            
        }
        
    }
    
    static var method_resize: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("resize")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, &name.content, 848867239)!
    }()
    
    /// Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size.
    @discardableResult /* 1: resize */ 
    public final func resize(newSize: Int64)-> Int64 {
        var result: Int64 = Int64()
        withUnsafePointer(to: newSize) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    PackedVector4Array.method_resize(&content, pArgs, &result, 1)
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_clear: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("clear")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, &name.content, 3218959716)!
    }()
    
    /// Clears the array. This is equivalent to using ``resize(newSize:)`` with a size of `0`.
    public final func clear() {
        PackedVector4Array.method_clear(&content, nil, nil, 0)
    }
    
    static var method_has: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("has")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, &name.content, 88913544)!
    }()
    
    /// Returns `true` if the array contains `value`.
    /// 
    /// > Note: Vectors with ``@GDScript.NAN`` elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
    /// 
    public final func has(value: Vector4)-> Bool {
        var result: Bool = Bool()
        withUnsafePointer(to: value) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    PackedVector4Array.method_has(&content, pArgs, &result, 1)
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_reverse: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("reverse")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, &name.content, 3218959716)!
    }()
    
    /// Reverses the order of the elements in the array.
    public final func reverse() {
        PackedVector4Array.method_reverse(&content, nil, nil, 0)
    }
    
    static var method_slice: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("slice")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, &name.content, 2942803855)!
    }()
    
    /// Returns the slice of the ``PackedVector4Array``, from `begin` (inclusive) to `end` (exclusive), as a new ``PackedVector4Array``.
    /// 
    /// The absolute value of `begin` and `end` will be clamped to the array size, so the default value for `end` makes it slice to the size of the array by default (i.e. `arr.slice(1)` is a shorthand for `arr.slice(1, arr.size())`).
    /// 
    /// If either `begin` or `end` are negative, they will be relative to the end of the array (i.e. `arr.slice(0, -2)` is a shorthand for `arr.slice(0, arr.size() - 2)`).
    /// 
    public final func slice(begin: Int64, end: Int64 = 2147483647)-> PackedVector4Array {
        let result: PackedVector4Array = PackedVector4Array()
        withUnsafePointer(to: begin) { pArg0 in
            withUnsafePointer(to: end) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        PackedVector4Array.method_slice(&content, pArgs, &result.content, 2)
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_to_byte_array: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("to_byte_array")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, &name.content, 247621236)!
    }()
    
    /// Returns a ``PackedByteArray`` with each vector encoded as bytes.
    public final func toByteArray()-> PackedByteArray {
        let result: PackedByteArray = PackedByteArray()
        PackedVector4Array.method_to_byte_array(&content, nil, &result.content, 0)
        return result
    }
    
    static var method_sort: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("sort")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, &name.content, 3218959716)!
    }()
    
    /// Sorts the elements of the array in ascending order.
    /// 
    /// > Note: Vectors with ``@GDScript.NAN`` elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
    /// 
    public final func sort() {
        PackedVector4Array.method_sort(&content, nil, nil, 0)
    }
    
    static var method_bsearch: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("bsearch")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, &name.content, 735671678)!
    }()
    
    /// Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a `before` specifier can be passed. If `false`, the returned index comes after all existing entries of the value in the array.
    /// 
    /// > Note: Calling ``bsearch(value:before:)`` on an unsorted array results in unexpected behavior.
    /// 
    /// > Note: Vectors with ``@GDScript.NAN`` elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
    /// 
    public final func bsearch(value: Vector4, before: Bool = true)-> Int64 {
        var result: Int64 = Int64()
        withUnsafePointer(to: value) { pArg0 in
            withUnsafePointer(to: before) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        PackedVector4Array.method_bsearch(&content, pArgs, &result, 2)
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_duplicate: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("duplicate")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, &name.content, 3186305013)!
    }()
    
    /// Creates a copy of the array, and returns it.
    public final func duplicate()-> PackedVector4Array {
        let result: PackedVector4Array = PackedVector4Array()
        PackedVector4Array.method_duplicate(&content, nil, &result.content, 0)
        return result
    }
    
    static var method_find: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("find")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, &name.content, 3091171314)!
    }()
    
    /// Searches the array for a value and returns its index or `-1` if not found. Optionally, the initial search index can be passed.
    /// 
    /// > Note: Vectors with ``@GDScript.NAN`` elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
    /// 
    public final func find(value: Vector4, from: Int64 = 0)-> Int64 {
        var result: Int64 = Int64()
        withUnsafePointer(to: value) { pArg0 in
            withUnsafePointer(to: from) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        PackedVector4Array.method_find(&content, pArgs, &result, 2)
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_rfind: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("rfind")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, &name.content, 3091171314)!
    }()
    
    /// Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
    /// 
    /// > Note: Vectors with ``@GDScript.NAN`` elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
    /// 
    public final func rfind(value: Vector4, from: Int64 = -1)-> Int64 {
        var result: Int64 = Int64()
        withUnsafePointer(to: value) { pArg0 in
            withUnsafePointer(to: from) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        PackedVector4Array.method_rfind(&content, pArgs, &result, 2)
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_count: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("count")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, &name.content, 3956594488)!
    }()
    
    /// Returns the number of times an element is in the array.
    /// 
    /// > Note: Vectors with ``@GDScript.NAN`` elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
    /// 
    public final func count(value: Vector4)-> Int64 {
        var result: Int64 = Int64()
        withUnsafePointer(to: value) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    PackedVector4Array.method_count(&content, pArgs, &result, 1)
                }
                
            }
            
        }
        
        return result
    }
    
    static var operator_5: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_EQUAL, GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY)!
    }()
    
    /// Returns `true` if contents of both arrays are the same, i.e. they have all equal ``Vector4``s at the corresponding indices.
    public static func == (lhs: PackedVector4Array, rhs: PackedVector4Array) -> Bool  {
        var result: Bool = Bool()
        withUnsafePointer(to: lhs.content) { pArg0 in
            withUnsafePointer(to: rhs.content) { pArg1 in
                PackedVector4Array.operator_5(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_6: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_NOT_EQUAL, GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY)!
    }()
    
    /// Returns `true` if contents of the arrays differ.
    public static func != (lhs: PackedVector4Array, rhs: PackedVector4Array) -> Bool  {
        var result: Bool = Bool()
        withUnsafePointer(to: lhs.content) { pArg0 in
            withUnsafePointer(to: rhs.content) { pArg1 in
                PackedVector4Array.operator_6(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_7: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_ADD, GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY, GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR4_ARRAY)!
    }()
    
    /// Returns a new ``PackedVector4Array`` with contents of `right` added at the end of this array. For better performance, consider using ``appendArray(array:)`` instead.
    public static func + (lhs: PackedVector4Array, rhs: PackedVector4Array) -> PackedVector4Array  {
        let result: PackedVector4Array = PackedVector4Array()
        withUnsafePointer(to: lhs.content) { pArg0 in
            withUnsafePointer(to: rhs.content) { pArg1 in
                PackedVector4Array.operator_7(pArg0, pArg1, &result.content)
            }
            
        }
        
        return result
    }
    
    public var startIndex: Int {
        0
    }
    
    public var endIndex: Int {
        Int (size ())
    }
    
    public func index(after i: Int) -> Int {
        i+1
    }
    
    public func index(before i: Int) -> Int {
        return i-1
    }
    
}

