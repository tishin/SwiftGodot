// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
import Foundation
#endif
/// A 4×4 matrix for 3D projective transformations.
/// 
/// A 4×4 matrix used for 3D projective transformations. It can represent transformations such as translation, rotation, scaling, shearing, and perspective division. It consists of four ``Vector4`` columns.
/// 
/// For purely linear transformations (translation, rotation, and scale), it is recommended to use ``Transform3D``, as it is more performant and requires less memory.
/// 
/// Used internally as ``Camera3D``'s projection matrix.
/// 
public struct Projection: Equatable, Hashable {
    /// The projection matrix's X vector (column 0). Equivalent to array index `0`.
    public var x: Vector4
    /// The projection matrix's Y vector (column 1). Equivalent to array index `1`.
    public var y: Vector4
    /// The projection matrix's Z vector (column 2). Equivalent to array index `2`.
    public var z: Vector4
    /// The projection matrix's W vector (column 3). Equivalent to array index `3`.
    public var w: Vector4
    public enum Planes: Int64, CaseIterable, CustomDebugStringConvertible {
        /// The index value of the projection's near clipping plane.
        case near = 0 // PLANE_NEAR
        /// The index value of the projection's far clipping plane.
        case far = 1 // PLANE_FAR
        /// The index value of the projection's left clipping plane.
        case left = 2 // PLANE_LEFT
        /// The index value of the projection's top clipping plane.
        case top = 3 // PLANE_TOP
        /// The index value of the projection's right clipping plane.
        case right = 4 // PLANE_RIGHT
        /// The index value of the projection bottom clipping plane.
        case bottom = 5 // PLANE_BOTTOM
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .near: return ".near"
                case .far: return ".far"
                case .left: return ".left"
                case .top: return ".top"
                case .right: return ".right"
                case .bottom: return ".bottom"
            }
            
        }
        
    }
    
    static var constructor0: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_PROJECTION, 0)!
    
    /// Constructs a default-initialized ``Projection`` set to ``IDENTITY``.
    public init () {
        self.x = Vector4 (x: 1, y: 0, z: 0, w: 0)
        self.y = Vector4 (x: 0, y: 1, z: 0, w: 0)
        self.z = Vector4 (x: 0, y: 0, z: 1, w: 0)
        self.w = Vector4 (x: 0, y: 0, z: 0, w: 1)
    }
    
    static var constructor1: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_PROJECTION, 1)!
    
    /// Constructs a ``Projection`` as a copy of the given ``Projection``.
    public init (from: Projection) {
        self.x = Vector4 ()
        self.y = Vector4 ()
        self.z = Vector4 ()
        self.w = Vector4 ()
        withUnsafePointer(to: from) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    Projection.constructor1(&self, pArgs)
                }
                
            }
            
        }
        
    }
    
    static var constructor2: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_PROJECTION, 2)!
    
    /// Constructs a Projection as a copy of the given ``Transform3D``.
    public init (from: Transform3D) {
        self.x = Vector4 ()
        self.y = Vector4 ()
        self.z = Vector4 ()
        self.w = Vector4 ()
        withUnsafePointer(to: from) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    Projection.constructor2(&self, pArgs)
                }
                
            }
            
        }
        
    }
    
    static var constructor3: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_PROJECTION, 3)!
    
    /// Constructs a Projection from four ``Vector4`` values (matrix columns).
    public init (xAxis: Vector4, yAxis: Vector4, zAxis: Vector4, wAxis: Vector4) {
        self.x = xAxis
        self.y = yAxis
        self.z = zAxis
        self.w = wAxis
    }
    
    
    /* Methods */
    
    static var method_create_depth_correction: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("create_depth_correction")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 1228516048)!
    }()
    
    /// Creates a new ``Projection`` that projects positions from a depth range of `-1` to `1` to one that ranges from `0` to `1`, and flips the projected positions vertically, according to `flipY`.
    public static func createDepthCorrection(flipY: Bool)-> Projection {
        var result: Projection = Projection()
        withUnsafePointer(to: flipY) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    Projection.method_create_depth_correction(nil, pArgs, &result, 1)
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_create_light_atlas_rect: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("create_light_atlas_rect")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 2654950662)!
    }()
    
    /// Creates a new ``Projection`` that projects positions into the given ``Rect2``.
    public static func createLightAtlasRect(_ rect: Rect2)-> Projection {
        var result: Projection = Projection()
        withUnsafePointer(to: rect) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    Projection.method_create_light_atlas_rect(nil, pArgs, &result, 1)
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_create_perspective: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("create_perspective")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 390915442)!
    }()
    
    /// Creates a new ``Projection`` that projects positions using a perspective projection with the given Y-axis field of view (in degrees), X:Y aspect ratio, and clipping planes.
    /// 
    /// `flipFov` determines whether the projection's field of view is flipped over its diagonal.
    /// 
    public static func createPerspective(fovy: Double, aspect: Double, zNear: Double, zFar: Double, flipFov: Bool = false)-> Projection {
        var result: Projection = Projection()
        let fovy = Double(fovy)
        withUnsafePointer(to: fovy) { pArg0 in
            let aspect = Double(aspect)
            withUnsafePointer(to: aspect) { pArg1 in
                let zNear = Double(zNear)
                withUnsafePointer(to: zNear) { pArg2 in
                    let zFar = Double(zFar)
                    withUnsafePointer(to: zFar) { pArg3 in
                        withUnsafePointer(to: flipFov) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    Projection.method_create_perspective(nil, pArgs, &result, 5)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_create_perspective_hmd: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("create_perspective_hmd")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 2857674800)!
    }()
    
    /// Creates a new ``Projection`` that projects positions using a perspective projection with the given Y-axis field of view (in degrees), X:Y aspect ratio, and clipping distances. The projection is adjusted for a head-mounted display with the given distance between eyes and distance to a point that can be focused on.
    /// 
    /// `eye` creates the projection for the left eye when set to 1, or the right eye when set to 2.
    /// 
    /// `flipFov` determines whether the projection's field of view is flipped over its diagonal.
    /// 
    public static func createPerspectiveHmd(fovy: Double, aspect: Double, zNear: Double, zFar: Double, flipFov: Bool, eye: Int64, intraocularDist: Double, convergenceDist: Double)-> Projection {
        var result: Projection = Projection()
        let fovy = Double(fovy)
        withUnsafePointer(to: fovy) { pArg0 in
            let aspect = Double(aspect)
            withUnsafePointer(to: aspect) { pArg1 in
                let zNear = Double(zNear)
                withUnsafePointer(to: zNear) { pArg2 in
                    let zFar = Double(zFar)
                    withUnsafePointer(to: zFar) { pArg3 in
                        withUnsafePointer(to: flipFov) { pArg4 in
                            withUnsafePointer(to: eye) { pArg5 in
                                let intraocularDist = Double(intraocularDist)
                                withUnsafePointer(to: intraocularDist) { pArg6 in
                                    let convergenceDist = Double(convergenceDist)
                                    withUnsafePointer(to: convergenceDist) { pArg7 in
                                        withUnsafePointer(to: UnsafeRawPointersN8(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6, pArg7)) { pArgs in
                                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 8) { pArgs in
                                                Projection.method_create_perspective_hmd(nil, pArgs, &result, 8)
                                            }
                                            
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_create_for_hmd: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("create_for_hmd")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 4184144994)!
    }()
    
    /// Creates a new ``Projection`` for projecting positions onto a head-mounted display with the given X:Y aspect ratio, distance between eyes, display width, distance to lens, oversampling factor, and depth clipping planes.
    /// 
    /// `eye` creates the projection for the left eye when set to 1, or the right eye when set to 2.
    /// 
    public static func createForHmd(eye: Int64, aspect: Double, intraocularDist: Double, displayWidth: Double, displayToLens: Double, oversample: Double, zNear: Double, zFar: Double)-> Projection {
        var result: Projection = Projection()
        withUnsafePointer(to: eye) { pArg0 in
            let aspect = Double(aspect)
            withUnsafePointer(to: aspect) { pArg1 in
                let intraocularDist = Double(intraocularDist)
                withUnsafePointer(to: intraocularDist) { pArg2 in
                    let displayWidth = Double(displayWidth)
                    withUnsafePointer(to: displayWidth) { pArg3 in
                        let displayToLens = Double(displayToLens)
                        withUnsafePointer(to: displayToLens) { pArg4 in
                            let oversample = Double(oversample)
                            withUnsafePointer(to: oversample) { pArg5 in
                                let zNear = Double(zNear)
                                withUnsafePointer(to: zNear) { pArg6 in
                                    let zFar = Double(zFar)
                                    withUnsafePointer(to: zFar) { pArg7 in
                                        withUnsafePointer(to: UnsafeRawPointersN8(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6, pArg7)) { pArgs in
                                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 8) { pArgs in
                                                Projection.method_create_for_hmd(nil, pArgs, &result, 8)
                                            }
                                            
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_create_orthogonal: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("create_orthogonal")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 3707929169)!
    }()
    
    /// Creates a new ``Projection`` that projects positions using an orthogonal projection with the given clipping planes.
    public static func createOrthogonal(left: Double, right: Double, bottom: Double, top: Double, zNear: Double, zFar: Double)-> Projection {
        var result: Projection = Projection()
        let left = Double(left)
        withUnsafePointer(to: left) { pArg0 in
            let right = Double(right)
            withUnsafePointer(to: right) { pArg1 in
                let bottom = Double(bottom)
                withUnsafePointer(to: bottom) { pArg2 in
                    let top = Double(top)
                    withUnsafePointer(to: top) { pArg3 in
                        let zNear = Double(zNear)
                        withUnsafePointer(to: zNear) { pArg4 in
                            let zFar = Double(zFar)
                            withUnsafePointer(to: zFar) { pArg5 in
                                withUnsafePointer(to: UnsafeRawPointersN6(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5)) { pArgs in
                                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 6) { pArgs in
                                        Projection.method_create_orthogonal(nil, pArgs, &result, 6)
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_create_orthogonal_aspect: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("create_orthogonal_aspect")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 390915442)!
    }()
    
    /// Creates a new ``Projection`` that projects positions using an orthogonal projection with the given size, X:Y aspect ratio, and clipping planes.
    /// 
    /// `flipFov` determines whether the projection's field of view is flipped over its diagonal.
    /// 
    public static func createOrthogonalAspect(size: Double, aspect: Double, zNear: Double, zFar: Double, flipFov: Bool = false)-> Projection {
        var result: Projection = Projection()
        let size = Double(size)
        withUnsafePointer(to: size) { pArg0 in
            let aspect = Double(aspect)
            withUnsafePointer(to: aspect) { pArg1 in
                let zNear = Double(zNear)
                withUnsafePointer(to: zNear) { pArg2 in
                    let zFar = Double(zFar)
                    withUnsafePointer(to: zFar) { pArg3 in
                        withUnsafePointer(to: flipFov) { pArg4 in
                            withUnsafePointer(to: UnsafeRawPointersN5(pArg0, pArg1, pArg2, pArg3, pArg4)) { pArgs in
                                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 5) { pArgs in
                                    Projection.method_create_orthogonal_aspect(nil, pArgs, &result, 5)
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_create_frustum: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("create_frustum")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 3707929169)!
    }()
    
    /// Creates a new ``Projection`` that projects positions in a frustum with the given clipping planes.
    public static func createFrustum(left: Double, right: Double, bottom: Double, top: Double, zNear: Double, zFar: Double)-> Projection {
        var result: Projection = Projection()
        let left = Double(left)
        withUnsafePointer(to: left) { pArg0 in
            let right = Double(right)
            withUnsafePointer(to: right) { pArg1 in
                let bottom = Double(bottom)
                withUnsafePointer(to: bottom) { pArg2 in
                    let top = Double(top)
                    withUnsafePointer(to: top) { pArg3 in
                        let zNear = Double(zNear)
                        withUnsafePointer(to: zNear) { pArg4 in
                            let zFar = Double(zFar)
                            withUnsafePointer(to: zFar) { pArg5 in
                                withUnsafePointer(to: UnsafeRawPointersN6(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5)) { pArgs in
                                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 6) { pArgs in
                                        Projection.method_create_frustum(nil, pArgs, &result, 6)
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_create_frustum_aspect: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("create_frustum_aspect")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 1535076251)!
    }()
    
    /// Creates a new ``Projection`` that projects positions in a frustum with the given size, X:Y aspect ratio, offset, and clipping planes.
    /// 
    /// `flipFov` determines whether the projection's field of view is flipped over its diagonal.
    /// 
    public static func createFrustumAspect(size: Double, aspect: Double, offset: Vector2, zNear: Double, zFar: Double, flipFov: Bool = false)-> Projection {
        var result: Projection = Projection()
        let size = Double(size)
        withUnsafePointer(to: size) { pArg0 in
            let aspect = Double(aspect)
            withUnsafePointer(to: aspect) { pArg1 in
                withUnsafePointer(to: offset) { pArg2 in
                    let zNear = Double(zNear)
                    withUnsafePointer(to: zNear) { pArg3 in
                        let zFar = Double(zFar)
                        withUnsafePointer(to: zFar) { pArg4 in
                            withUnsafePointer(to: flipFov) { pArg5 in
                                withUnsafePointer(to: UnsafeRawPointersN6(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5)) { pArgs in
                                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 6) { pArgs in
                                        Projection.method_create_frustum_aspect(nil, pArgs, &result, 6)
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_create_fit_aabb: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("create_fit_aabb")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 2264694907)!
    }()
    
    /// Creates a new ``Projection`` that scales a given projection to fit around a given ``AABB`` in projection space.
    public static func createFitAabb(_ aabb: AABB)-> Projection {
        var result: Projection = Projection()
        withUnsafePointer(to: aabb) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    Projection.method_create_fit_aabb(nil, pArgs, &result, 1)
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_determinant: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("determinant")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 466405837)!
    }()
    
    /// Returns a scalar value that is the signed factor by which areas are scaled by this matrix. If the sign is negative, the matrix flips the orientation of the area.
    /// 
    /// The determinant can be used to calculate the invertibility of a matrix or solve linear systems of equations involving the matrix, among other applications.
    /// 
    public func determinant()-> Double {
        var result: Double = Double()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Projection.method_determinant(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_perspective_znear_adjusted: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("perspective_znear_adjusted")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 3584785443)!
    }()
    
    /// Returns a ``Projection`` with the near clipping distance adjusted to be `newZnear`.
    /// 
    /// > Note: The original ``Projection`` must be a perspective projection.
    /// 
    public func perspectiveZnearAdjusted(newZnear: Double)-> Projection {
        var result: Projection = Projection()
        let newZnear = Double(newZnear)
        withUnsafePointer(to: newZnear) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Projection.method_perspective_znear_adjusted(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_get_projection_plane: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_projection_plane")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 1551184160)!
    }()
    
    /// Returns the clipping plane of this ``Projection`` whose index is given by `plane`.
    /// 
    /// `plane` should be equal to one of .planeNear, .planeFar, .planeLeft, .planeTop, .planeRight, or .planeBottom.
    /// 
    public func getProjectionPlane(_ plane: Int64)-> Plane {
        var result: Plane = Plane()
        withUnsafePointer(to: plane) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Projection.method_get_projection_plane(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_flipped_y: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("flipped_y")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 4212530932)!
    }()
    
    /// Returns a copy of this ``Projection`` with the signs of the values of the Y column flipped.
    public func flippedY()-> Projection {
        var result: Projection = Projection()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Projection.method_flipped_y(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_jitter_offseted: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("jitter_offseted")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 2448438599)!
    }()
    
    /// Returns a ``Projection`` with the X and Y values from the given ``Vector2`` added to the first and second values of the final column respectively.
    public func jitterOffseted(offset: Vector2)-> Projection {
        var result: Projection = Projection()
        withUnsafePointer(to: offset) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Projection.method_jitter_offseted(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_get_fovy: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_fovy")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 3514207532)!
    }()
    
    /// Returns the vertical field of view of the projection (in degrees) associated with the given horizontal field of view (in degrees) and aspect ratio.
    public static func getFovy(fovx: Double, aspect: Double)-> Double {
        var result: Double = Double()
        let fovx = Double(fovx)
        withUnsafePointer(to: fovx) { pArg0 in
            let aspect = Double(aspect)
            withUnsafePointer(to: aspect) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        Projection.method_get_fovy(nil, pArgs, &result, 2)
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_get_z_far: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_z_far")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 466405837)!
    }()
    
    /// Returns the distance for this ``Projection`` beyond which positions are clipped.
    public func getZFar()-> Double {
        var result: Double = Double()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Projection.method_get_z_far(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_get_z_near: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_z_near")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 466405837)!
    }()
    
    /// Returns the distance for this ``Projection`` before which positions are clipped.
    public func getZNear()-> Double {
        var result: Double = Double()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Projection.method_get_z_near(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_get_aspect: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_aspect")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 466405837)!
    }()
    
    /// Returns the X:Y aspect ratio of this ``Projection``'s viewport.
    public func getAspect()-> Double {
        var result: Double = Double()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Projection.method_get_aspect(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_get_fov: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_fov")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 466405837)!
    }()
    
    /// Returns the horizontal field of view of the projection (in degrees).
    public func getFov()-> Double {
        var result: Double = Double()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Projection.method_get_fov(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_is_orthogonal: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_orthogonal")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if this ``Projection`` performs an orthogonal projection.
    public func isOrthogonal()-> Bool {
        var result: Bool = Bool()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Projection.method_is_orthogonal(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_get_viewport_half_extents: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_viewport_half_extents")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 2428350749)!
    }()
    
    /// Returns the dimensions of the viewport plane that this ``Projection`` projects positions onto, divided by two.
    public func getViewportHalfExtents()-> Vector2 {
        var result: Vector2 = Vector2()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Projection.method_get_viewport_half_extents(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_get_far_plane_half_extents: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_far_plane_half_extents")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 2428350749)!
    }()
    
    /// Returns the dimensions of the far clipping plane of the projection, divided by two.
    public func getFarPlaneHalfExtents()-> Vector2 {
        var result: Vector2 = Vector2()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Projection.method_get_far_plane_half_extents(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_inverse: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("inverse")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 4212530932)!
    }()
    
    /// Returns a ``Projection`` that performs the inverse of this ``Projection``'s projective transformation.
    public func inverse()-> Projection {
        var result: Projection = Projection()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Projection.method_inverse(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_get_pixels_per_meter: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_pixels_per_meter")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 4103005248)!
    }()
    
    /// Returns the number of pixels with the given pixel width displayed per meter, after this ``Projection`` is applied.
    public func getPixelsPerMeter(forPixelWidth: Int64)-> Int64 {
        var result: Int64 = Int64()
        withUnsafePointer(to: forPixelWidth) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Projection.method_get_pixels_per_meter(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_get_lod_multiplier: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_lod_multiplier")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 466405837)!
    }()
    
    /// Returns the factor by which the visible level of detail is scaled by this ``Projection``.
    public func getLodMultiplier()-> Double {
        var result: Double = Double()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Projection.method_get_lod_multiplier(ptr, nil, &result, 0)
        }
        return result
    }
    
    private static var indexed_getter: GDExtensionPtrIndexedGetter = {
        return gi.variant_get_ptr_indexed_getter (GDEXTENSION_VARIANT_TYPE_PROJECTION)!
    }()
    
    private static var indexed_setter: GDExtensionPtrIndexedSetter = {
        return gi.variant_get_ptr_indexed_setter (GDEXTENSION_VARIANT_TYPE_PROJECTION)!
    }()
    
     public subscript (index: Int64) -> Vector4 {
        mutating get {
            var result = Vector4 ()
            Self.indexed_getter (&self, index, &result)
            return result
        }
        
        set {
            var value = newValue
            Self.indexed_setter (&self, index, &value)
        }
        
    }
    
    static var operator_3: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_PROJECTION, GDEXTENSION_VARIANT_TYPE_VECTOR4)!
    }()
    
    /// Projects (multiplies) the given ``Vector4`` by this ``Projection`` matrix.
    public static func * (lhs: Projection, rhs: Vector4) -> Vector4  {
        var result: Vector4 = Vector4()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Projection.operator_3(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_4: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_EQUAL, GDEXTENSION_VARIANT_TYPE_PROJECTION, GDEXTENSION_VARIANT_TYPE_PROJECTION)!
    }()
    
    /// Returns `true` if the projections are equal.
    /// 
    /// > Note: Due to floating-point precision errors, this may return `false`, even if the projections are virtually equal. An `is_equal_approx` method may be added in a future version of Godot.
    /// 
    public static func == (lhs: Projection, rhs: Projection) -> Bool  {
        var result: Bool = Bool()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Projection.operator_4(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_5: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_NOT_EQUAL, GDEXTENSION_VARIANT_TYPE_PROJECTION, GDEXTENSION_VARIANT_TYPE_PROJECTION)!
    }()
    
    /// Returns `true` if the projections are not equal.
    /// 
    /// > Note: Due to floating-point precision errors, this may return `true`, even if the projections are virtually equal. An `is_equal_approx` method may be added in a future version of Godot.
    /// 
    public static func != (lhs: Projection, rhs: Projection) -> Bool  {
        var result: Bool = Bool()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Projection.operator_5(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_6: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_PROJECTION, GDEXTENSION_VARIANT_TYPE_PROJECTION)!
    }()
    
    /// Returns a ``Projection`` that applies the combined transformations of this ``Projection`` and `right`.
    public static func * (lhs: Projection, rhs: Projection) -> Projection  {
        var result: Projection = Projection()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Projection.operator_6(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    /// The index value of the projection's near clipping plane.
    public static let planeNear = 0
    /// The index value of the projection's far clipping plane.
    public static let planeFar = 1
    /// The index value of the projection's left clipping plane.
    public static let planeLeft = 2
    /// The index value of the projection's top clipping plane.
    public static let planeTop = 3
    /// The index value of the projection's right clipping plane.
    public static let planeRight = 4
    /// The index value of the projection bottom clipping plane.
    public static let planeBottom = 5
    /// A ``Projection`` with no transformation defined. When applied to other data structures, no transformation is performed.
    public static let identity = Projection (xAxis: Vector4 (x: 1, y: 0, z: 0, w: 0), yAxis: Vector4 (x: 0, y: 1, z: 0, w: 0), zAxis: Vector4 (x: 0, y: 0, z: 1, w: 0), wAxis: Vector4 (x: 0, y: 0, z: 0, w: 1))
    /// A ``Projection`` with all values initialized to 0. When applied to other data structures, they will be zeroed.
    public static let zero = Projection (xAxis: Vector4 (x: 0, y: 0, z: 0, w: 0), yAxis: Vector4 (x: 0, y: 0, z: 0, w: 0), zAxis: Vector4 (x: 0, y: 0, z: 0, w: 0), wAxis: Vector4 (x: 0, y: 0, z: 0, w: 0))
}

