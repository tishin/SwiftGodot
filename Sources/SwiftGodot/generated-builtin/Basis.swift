// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
import Foundation
#endif
/// A 3×3 matrix for representing 3D rotation and scale.
/// 
/// The ``Basis`` built-in ``Variant`` type is a 3×3 <a href="https://en.wikipedia.org/wiki/Matrix_(mathematics)">matrix</a> used to represent 3D rotation, scale, and shear. It is frequently used within a ``Transform3D``.
/// 
/// A ``Basis`` is composed by 3 axis vectors, each representing a column of the matrix: ``x``, ``y``, and ``z``. The length of each axis (``Vector3/length()``) influences the basis's scale, while the direction of all axes influence the rotation. Usually, these axes are perpendicular to one another. However, when you rotate any axis individually, the basis becomes sheared. Applying a sheared basis to a 3D model will make the model appear distorted.
/// 
/// A ``Basis`` is **orthogonal** if its axes are perpendicular to each other. A basis is **normalized** if the length of every axis is `1`. A basis is **uniform** if all axes share the same length (see ``getScale()``). A basis is **orthonormal** if it is both orthogonal and normalized, which allows it to only represent rotations. A basis is **conformal** if it is both orthogonal and uniform, which ensures it is not distorted.
/// 
/// For a general introduction, see the <a href="https://docs.godotengine.org/en//tutorials/math/matrices_and_transforms.html">Matrices and transforms</a> tutorial.
/// 
/// > Note: Godot uses a <a href="https://en.wikipedia.org/wiki/Right-hand_rule">right-handed coordinate system</a>, which is a common standard. For directions, the convention for built-in types like ``Camera3D`` is for -Z to point forward (+X is right, +Y is up, and +Z is back). Other objects may use different direction conventions. For more information, see the <a href="https://docs.godotengine.org/en//tutorials/assets_pipeline/importing_scenes.html#d-asset-direction-conventions">Importing 3D Scenes</a> tutorial.
/// 
/// > Note: The basis matrices are exposed as <a href="https://www.mindcontrol.org/~hplus/graphics/matrix-layout.html">column-major</a> order, which is the same as OpenGL. However, they are stored internally in row-major order, which is the same as DirectX.
/// 
public struct Basis: Equatable, Hashable {
    /// The basis's X axis, and the column `0` of the matrix.
    /// 
    /// On the identity basis, this vector points right (``Vector3.RIGHT``).
    /// 
    public var x: Vector3
    /// The basis's Y axis, and the column `1` of the matrix.
    /// 
    /// On the identity basis, this vector points up (``Vector3.UP``).
    /// 
    public var y: Vector3
    /// The basis's Z axis, and the column `2` of the matrix.
    /// 
    /// On the identity basis, this vector points back (``Vector3.BACK``).
    /// 
    public var z: Vector3
    static var constructor0: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_BASIS, 0)!
    
    /// Constructs a ``Basis`` identical to the ``IDENTITY``.
    public init () {
        self.x = Vector3 (x: 1, y: 0, z: 0)
        self.y = Vector3 (x: 0, y: 1, z: 0)
        self.z = Vector3 (x: 0, y: 0, z: 1)
    }
    
    static var constructor1: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_BASIS, 1)!
    
    /// Constructs a ``Basis`` as a copy of the given ``Basis``.
    public init (from: Basis) {
        self.x = Vector3 ()
        self.y = Vector3 ()
        self.z = Vector3 ()
        withUnsafePointer(to: from) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    Basis.constructor1(&self, pArgs)
                }
                
            }
            
        }
        
    }
    
    static var constructor2: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_BASIS, 2)!
    
    /// Constructs a ``Basis`` that only represents rotation from the given ``Quaternion``.
    /// 
    /// > Note: Quaternions _only_ store rotation, not scale. Because of this, conversions from ``Basis`` to ``Quaternion`` cannot always be reversed.
    /// 
    public init (from: Quaternion) {
        self.x = Vector3 ()
        self.y = Vector3 ()
        self.z = Vector3 ()
        withUnsafePointer(to: from) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    Basis.constructor2(&self, pArgs)
                }
                
            }
            
        }
        
    }
    
    static var constructor3: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_BASIS, 3)!
    
    /// Constructs a ``Basis`` that only represents rotation, rotated around the `axis` by the given `angle`, in radians. The axis must be a normalized vector.
    /// 
    /// > Note: This is the same as using ``rotated(axis:angle:)`` on the ``IDENTITY`` basis. With more than one angle consider using ``fromEuler(euler:order:)``, instead.
    /// 
    public init (axis: Vector3, angle: Float) {
        self.x = Vector3 ()
        self.y = Vector3 ()
        self.z = Vector3 ()
        withUnsafePointer(to: axis) { pArg0 in
            let angle = Double(angle)
            withUnsafePointer(to: angle) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        Basis.constructor3(&self, pArgs)
                    }
                    
                }
                
            }
            
        }
        
    }
    
    static var constructor4: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_BASIS, 4)!
    
    /// Constructs a ``Basis`` from 3 axis vectors. These are the columns of the basis matrix.
    public init (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) {
        self.x = xAxis
        self.y = yAxis
        self.z = zAxis
    }
    
    
    /* Methods */
    
    static var method_inverse: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("inverse")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 594669093)!
    }()
    
    /// Returns the <a href="https://en.wikipedia.org/wiki/Invertible_matrix">inverse of this basis's matrix</a>.
    public func inverse()-> Basis {
        var result: Basis = Basis()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Basis.method_inverse(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_transposed: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("transposed")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 594669093)!
    }()
    
    /// Returns the transposed version of this basis. This turns the basis matrix's columns into rows, and its rows into columns.
    /// 
    public func transposed()-> Basis {
        var result: Basis = Basis()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Basis.method_transposed(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_orthonormalized: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("orthonormalized")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 594669093)!
    }()
    
    /// Returns the orthonormalized version of this basis. An orthonormal basis is both _orthogonal_ (the axes are perpendicular to each other) and _normalized_ (the axes have a length of `1`), which also means it can only represent rotation.
    /// 
    /// It is often useful to call this method to avoid rounding errors on a rotating basis:
    /// 
    public func orthonormalized()-> Basis {
        var result: Basis = Basis()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Basis.method_orthonormalized(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_determinant: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("determinant")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 466405837)!
    }()
    
    /// Returns the <a href="https://en.wikipedia.org/wiki/Determinant">determinant</a> of this basis's matrix. For advanced math, this number can be used to determine a few attributes:
    /// 
    /// - If the determinant is exactly `0`, the basis is not invertible (see ``inverse()``).
    /// 
    /// - If the determinant is a negative number, the basis represents a negative scale.
    /// 
    /// > Note: If the basis's scale is the same for every axis, its determinant is always that scale by the power of 2.
    /// 
    public func determinant()-> Double {
        var result: Double = Double()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Basis.method_determinant(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_rotated: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("rotated")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 1998708965)!
    }()
    
    /// Returns this basis rotated around the given `axis` by `angle` (in radians). The `axis` must be a normalized vector (see ``Vector3/normalized()``).
    /// 
    /// Positive values rotate this basis clockwise around the axis, while negative values rotate it counterclockwise.
    /// 
    public func rotated(axis: Vector3, angle: Double)-> Basis {
        var result: Basis = Basis()
        withUnsafePointer(to: axis) { pArg0 in
            let angle = Double(angle)
            withUnsafePointer(to: angle) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        var mutSelfCopy = self
                        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                           Basis.method_rotated(ptr, pArgs, &result, 2)
                        }
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_scaled: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("scaled")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 3934786792)!
    }()
    
    /// Returns this basis with each axis's components scaled by the given `scale`'s components.
    /// 
    /// The basis matrix's rows are multiplied by `scale`'s components. This operation is a global scale (relative to the parent).
    /// 
    public func scaled(scale: Vector3)-> Basis {
        var result: Basis = Basis()
        withUnsafePointer(to: scale) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Basis.method_scaled(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_get_scale: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_scale")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 1776574132)!
    }()
    
    /// Returns the length of each axis of this basis, as a ``Vector3``. If the basis is not sheared, this is the scaling factor. It is not affected by rotation.
    /// 
    /// > Note: If the value returned by ``determinant()`` is negative, the scale is also negative.
    /// 
    public func getScale()-> Vector3 {
        var result: Vector3 = Vector3()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Basis.method_get_scale(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_get_euler: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_euler")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 1394941017)!
    }()
    
    /// Returns this basis's rotation as a ``Vector3`` of <a href="https://en.wikipedia.org/wiki/Euler_angles">Euler angles</a>, in radians.
    /// 
    /// - The ``Vector3/x`` contains the angle around the ``x`` axis (pitch);
    /// 
    /// - The ``Vector3/y`` contains the angle around the ``y`` axis (yaw);
    /// 
    /// - The ``Vector3/z`` contains the angle around the ``z`` axis (roll).
    /// 
    /// The order of each consecutive rotation can be changed with `order` (see ``EulerOrder`` constants). By default, the YXZ convention is used (``EulerOrder/yxz``): Z (roll) is calculated first, then X (pitch), and lastly Y (yaw). When using the opposite method ``fromEuler(euler:order:)``, this order is reversed.
    /// 
    /// > Note: Euler angles are much more intuitive but are not suitable for 3D math. Because of this, consider using the ``getRotationQuaternion()`` method instead, which returns a ``Quaternion``.
    /// 
    /// > Note: In the Inspector dock, a basis's rotation is often displayed in Euler angles (in degrees), as is the case with the ``Node3D/rotation`` property.
    /// 
    public func getEuler(order: Int64 = 2)-> Vector3 {
        var result: Vector3 = Vector3()
        withUnsafePointer(to: order) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Basis.method_get_euler(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_tdotx: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("tdotx")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 1047977935)!
    }()
    
    /// Returns the transposed dot product between `with` and the ``x`` axis (see ``transposed()``).
    /// 
    /// This is equivalent to `basis.x.dot(vector)`.
    /// 
    public func tdotx(with: Vector3)-> Double {
        var result: Double = Double()
        withUnsafePointer(to: with) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Basis.method_tdotx(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_tdoty: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("tdoty")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 1047977935)!
    }()
    
    /// Returns the transposed dot product between `with` and the ``y`` axis (see ``transposed()``).
    /// 
    /// This is equivalent to `basis.y.dot(vector)`.
    /// 
    public func tdoty(with: Vector3)-> Double {
        var result: Double = Double()
        withUnsafePointer(to: with) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Basis.method_tdoty(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_tdotz: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("tdotz")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 1047977935)!
    }()
    
    /// Returns the transposed dot product between `with` and the ``z`` axis (see ``transposed()``).
    /// 
    /// This is equivalent to `basis.z.dot(vector)`.
    /// 
    public func tdotz(with: Vector3)-> Double {
        var result: Double = Double()
        withUnsafePointer(to: with) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Basis.method_tdotz(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_slerp: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("slerp")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 3118673011)!
    }()
    
    /// Performs a spherical-linear interpolation with the `to` basis, given a `weight`. Both this basis and `to` should represent a rotation.
    /// 
    /// **Example:** Smoothly rotate a ``Node3D`` to the target basis over time, with a ``Tween``.
    /// 
    public func slerp(to: Basis, weight: Double)-> Basis {
        var result: Basis = Basis()
        withUnsafePointer(to: to) { pArg0 in
            let weight = Double(weight)
            withUnsafePointer(to: weight) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        var mutSelfCopy = self
                        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                           Basis.method_slerp(ptr, pArgs, &result, 2)
                        }
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_is_conformal: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_conformal")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if this basis is conformal. A conformal basis is both _orthogonal_ (the axes are perpendicular to each other) and _uniform_ (the axes share the same length). This method can be especially useful during physics calculations.
    public func isConformal()-> Bool {
        var result: Bool = Bool()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Basis.method_is_conformal(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_is_equal_approx: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_equal_approx")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 3165333982)!
    }()
    
    /// Returns `true` if this basis and `b` are approximately equal, by calling ``@GlobalScope.is_equal_approx`` on all vector components.
    public func isEqualApprox(b: Basis)-> Bool {
        var result: Bool = Bool()
        withUnsafePointer(to: b) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Basis.method_is_equal_approx(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_is_finite: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_finite")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if this basis is finite, by calling ``@GlobalScope.is_finite`` on all vector components.
    public func isFinite()-> Bool {
        var result: Bool = Bool()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Basis.method_is_finite(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_get_rotation_quaternion: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_rotation_quaternion")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 4274879941)!
    }()
    
    /// Returns this basis's rotation as a ``Quaternion``.
    /// 
    /// > Note: Quatenions are much more suitable for 3D math but are less intuitive. For user interfaces, consider using the ``getEuler(order:)`` method, which returns Euler angles.
    /// 
    public func getRotationQuaternion()-> Quaternion {
        var result: Quaternion = Quaternion()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Basis.method_get_rotation_quaternion(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_looking_at: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("looking_at")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 3728732505)!
    }()
    
    /// Creates a new ``Basis`` with a rotation such that the forward axis (-Z) points towards the `target` position.
    /// 
    /// By default, the -Z axis (camera forward) is treated as forward (implies +X is right). If `useModelFront` is `true`, the +Z axis (asset front) is treated as forward (implies +X is left) and points toward the `target` position.
    /// 
    /// The up axis (+Y) points as close to the `up` vector as possible while staying perpendicular to the forward axis. The returned basis is orthonormalized (see ``orthonormalized()``). The `target` and `up` vectors cannot be ``Vector3.ZERO``, and cannot be parallel to each other.
    /// 
    public static func lookingAt(target: Vector3, up: Vector3 = Vector3 (x: 0, y: 1, z: 0), useModelFront: Bool = false)-> Basis {
        var result: Basis = Basis()
        withUnsafePointer(to: target) { pArg0 in
            withUnsafePointer(to: up) { pArg1 in
                withUnsafePointer(to: useModelFront) { pArg2 in
                    withUnsafePointer(to: UnsafeRawPointersN3(pArg0, pArg1, pArg2)) { pArgs in
                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 3) { pArgs in
                            Basis.method_looking_at(nil, pArgs, &result, 3)
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_from_scale: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("from_scale")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 3703240166)!
    }()
    
    /// Constructs a new ``Basis`` that only represents scale, with no rotation or shear, from the given `scale` vector.
    /// 
    /// > Note: In linear algebra, the matrix of this basis is also known as a <a href="https://en.wikipedia.org/wiki/Diagonal_matrix">diagonal matrix</a>.
    /// 
    public static func fromScale(_ scale: Vector3)-> Basis {
        var result: Basis = Basis()
        withUnsafePointer(to: scale) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    Basis.method_from_scale(nil, pArgs, &result, 1)
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_from_euler: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("from_euler")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 2802321791)!
    }()
    
    /// Constructs a new ``Basis`` that only represents rotation from the given ``Vector3`` of <a href="https://en.wikipedia.org/wiki/Euler_angles">Euler angles</a>, in radians.
    /// 
    /// - The ``Vector3/x`` should contain the angle around the ``x`` axis (pitch).
    /// 
    /// - The ``Vector3/y`` should contain the angle around the ``y`` axis (yaw).
    /// 
    /// - The ``Vector3/z`` should contain the angle around the ``z`` axis (roll).
    /// 
    /// The order of each consecutive rotation can be changed with `order` (see ``EulerOrder`` constants). By default, the YXZ convention is used (``EulerOrder/yxz``): the basis rotates first around the Y axis (yaw), then X (pitch), and lastly Z (roll). When using the opposite method ``getEuler(order:)``, this order is reversed.
    /// 
    public static func fromEuler(_ euler: Vector3, order: Int64 = 2)-> Basis {
        var result: Basis = Basis()
        withUnsafePointer(to: euler) { pArg0 in
            withUnsafePointer(to: order) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        Basis.method_from_euler(nil, pArgs, &result, 2)
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    private static var indexed_getter: GDExtensionPtrIndexedGetter = {
        return gi.variant_get_ptr_indexed_getter (GDEXTENSION_VARIANT_TYPE_BASIS)!
    }()
    
    private static var indexed_setter: GDExtensionPtrIndexedSetter = {
        return gi.variant_get_ptr_indexed_setter (GDEXTENSION_VARIANT_TYPE_BASIS)!
    }()
    
     public subscript (index: Int64) -> Vector3 {
        mutating get {
            var result = Vector3 ()
            Self.indexed_getter (&self, index, &result)
            return result
        }
        
        set {
            var value = newValue
            Self.indexed_setter (&self, index, &value)
        }
        
    }
    
    static var operator_3: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_BASIS, GDEXTENSION_VARIANT_TYPE_INT)!
    }()
    
    /// Multiplies all components of the ``Basis`` by the given integer. This affects the basis's scale uniformly, resizing all 3 axes by the `right` value.
    public static func * (lhs: Basis, rhs: Int64) -> Basis  {
        var result: Basis = Basis()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Basis.operator_3(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_4: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_DIVIDE, GDEXTENSION_VARIANT_TYPE_BASIS, GDEXTENSION_VARIANT_TYPE_INT)!
    }()
    
    /// Divides all components of the ``Basis`` by the given integer. This affects the basis's scale uniformly, resizing all 3 axes by the `right` value.
    public static func / (lhs: Basis, rhs: Int64) -> Basis  {
        var result: Basis = Basis()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Basis.operator_4(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_5: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_BASIS, GDEXTENSION_VARIANT_TYPE_FLOAT)!
    }()
    
    /// Multiplies all components of the ``Basis`` by the given float. This affects the basis's scale uniformly, resizing all 3 axes by the `right` value.
    public static func * (lhs: Basis, rhs: Double) -> Basis  {
        var result: Basis = Basis()
        withUnsafePointer(to: lhs) { pArg0 in
            let rhs = Double(rhs)
            withUnsafePointer(to: rhs) { pArg1 in
                Basis.operator_5(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_6: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_DIVIDE, GDEXTENSION_VARIANT_TYPE_BASIS, GDEXTENSION_VARIANT_TYPE_FLOAT)!
    }()
    
    /// Divides all components of the ``Basis`` by the given float. This affects the basis's scale uniformly, resizing all 3 axes by the `right` value.
    public static func / (lhs: Basis, rhs: Double) -> Basis  {
        var result: Basis = Basis()
        withUnsafePointer(to: lhs) { pArg0 in
            let rhs = Double(rhs)
            withUnsafePointer(to: rhs) { pArg1 in
                Basis.operator_6(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_7: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_BASIS, GDEXTENSION_VARIANT_TYPE_VECTOR3)!
    }()
    
    /// Transforms (multiplies) the `right` vector by this basis, returning a ``Vector3``.
    /// 
    public static func * (lhs: Basis, rhs: Vector3) -> Vector3  {
        var result: Vector3 = Vector3()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Basis.operator_7(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_8: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_EQUAL, GDEXTENSION_VARIANT_TYPE_BASIS, GDEXTENSION_VARIANT_TYPE_BASIS)!
    }()
    
    /// Returns `true` if the components of both ``Basis`` matrices are exactly equal.
    /// 
    /// > Note: Due to floating-point precision errors, consider using ``isEqualApprox(b:)`` instead, which is more reliable.
    /// 
    public static func == (lhs: Basis, rhs: Basis) -> Bool  {
        var result: Bool = Bool()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Basis.operator_8(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_9: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_NOT_EQUAL, GDEXTENSION_VARIANT_TYPE_BASIS, GDEXTENSION_VARIANT_TYPE_BASIS)!
    }()
    
    /// Returns `true` if the components of both ``Basis`` matrices are not equal.
    /// 
    /// > Note: Due to floating-point precision errors, consider using ``isEqualApprox(b:)`` instead, which is more reliable.
    /// 
    public static func != (lhs: Basis, rhs: Basis) -> Bool  {
        var result: Bool = Bool()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Basis.operator_9(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_10: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_BASIS, GDEXTENSION_VARIANT_TYPE_BASIS)!
    }()
    
    /// Transforms (multiplies) the `right` basis by this basis.
    /// 
    /// This is the operation performed between parent and child ``Node3D``s.
    /// 
    public static func * (lhs: Basis, rhs: Basis) -> Basis  {
        var result: Basis = Basis()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Basis.operator_10(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    /// The identity basis. This is a basis with no rotation, no shear, and its scale being `1`. This means that:
    /// 
    /// - The ``x`` points right (``Vector3.RIGHT``);
    /// 
    /// - The ``y`` points up (``Vector3.UP``);
    /// 
    /// - The ``z`` points back (``Vector3.BACK``).
    /// 
    /// This is identical to creating [constructor Basis] without any parameters. This constant can be used to make your code clearer, and for consistency with C#.
    /// 
    public static let identity = Basis (xAxis: Vector3 (x: 1, y: 0, z: 0), yAxis: Vector3 (x: 0, y: 1, z: 0), zAxis: Vector3 (x: 0, y: 0, z: 1))
    /// When any basis is multiplied by ``FLIP_X``, it negates all components of the ``x`` axis (the X column).
    /// 
    /// When ``FLIP_X`` is multiplied by any basis, it negates the ``Vector3/x`` component of all axes (the X row).
    /// 
    public static let flipX = Basis (xAxis: Vector3 (x: -1, y: 0, z: 0), yAxis: Vector3 (x: 0, y: 1, z: 0), zAxis: Vector3 (x: 0, y: 0, z: 1))
    /// When any basis is multiplied by ``FLIP_Y``, it negates all components of the ``y`` axis (the Y column).
    /// 
    /// When ``FLIP_Y`` is multiplied by any basis, it negates the ``Vector3/y`` component of all axes (the Y row).
    /// 
    public static let flipY = Basis (xAxis: Vector3 (x: 1, y: 0, z: 0), yAxis: Vector3 (x: 0, y: -1, z: 0), zAxis: Vector3 (x: 0, y: 0, z: 1))
    /// When any basis is multiplied by ``FLIP_Z``, it negates all components of the ``z`` axis (the Z column).
    /// 
    /// When ``FLIP_Z`` is multiplied by any basis, it negates the ``Vector3/z`` component of all axes (the Z row).
    /// 
    public static let flipZ = Basis (xAxis: Vector3 (x: 1, y: 0, z: 0), yAxis: Vector3 (x: 0, y: 1, z: 0), zAxis: Vector3 (x: 0, y: 0, z: -1))
}

