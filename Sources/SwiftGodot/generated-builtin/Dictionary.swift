// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
import Foundation
#endif
/// A built-in data structure that holds key-value pairs.
/// 
/// Dictionaries are associative containers that contain values referenced by unique keys. Dictionaries will preserve the insertion order when adding new entries. In other programming languages, this data structure is often referred to as a hash map or an associative array.
/// 
/// You can define a dictionary by placing a comma-separated list of `key: value` pairs inside curly braces `{}`.
/// 
/// Creating a dictionary:
/// 
/// You can access a dictionary's value by referencing its corresponding key. In the above example, `points_dict["White"]` will return `50`. You can also write `points_dict.White`, which is equivalent. However, you'll have to use the bracket syntax if the key you're accessing the dictionary with isn't a fixed string (such as a number or variable).
/// 
/// In the above code, `points` will be assigned the value that is paired with the appropriate color selected in `my_color`.
/// 
/// Dictionaries can contain more complex data:
/// 
/// To add a key to an existing dictionary, access it like an existing key and assign to it:
/// 
/// Finally, dictionaries can contain different types of keys and values in the same dictionary:
/// 
/// The keys of a dictionary can be iterated with the `for` keyword:
/// 
/// > Note: Dictionaries are always passed by reference. To get a copy of a dictionary which can be modified independently of the original dictionary, use ``duplicate(deep:)``.
/// 
/// > Note: Erasing elements while iterating over dictionaries is **not** supported and will result in unpredictable behavior.
/// 
public class GDictionary: Equatable {
    static var destructor: GDExtensionPtrDestructor = {
        return gi.variant_get_ptr_destructor (GDEXTENSION_VARIANT_TYPE_DICTIONARY)!
    }()
    
    deinit {
        if content != GDictionary.zero {
            GDictionary.destructor (&content)
        }
        
    }
    
    // Contains a binary blob where this type information is stored
    public var content: ContentType = 0
    // Used to initialize empty types
    public static let zero: ContentType  = 0
    // Convenience type that matches the build configuration storage needs
    public typealias ContentType = Int64
    // Used to construct objects on virtual proxies
    public required init(content proxyContent: ContentType) {
        withUnsafePointer(to: proxyContent) { pContent in
            withUnsafePointer(to: pContent) { pArgs in
                GDictionary.constructor1(&content, pArgs)
            }
        }
    }
    // Used to construct objects when the underlying built-in's ref count has already been incremented for me
    public required init(alreadyOwnedContent content: ContentType) {
        self.content = content
    }
    
    static var constructor0: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_DICTIONARY, 0)!
    
    /// Constructs an empty ``GDictionary``.
    public required init () {
        GDictionary.constructor0(&content, nil)
    }
    
    static var constructor1: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_DICTIONARY, 1)!
    
    /// Returns the same dictionary as `from`. If you need a copy of the dictionary, use ``duplicate(deep:)``.
    public init (from: GDictionary) {
        withUnsafePointer(to: from.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    GDictionary.constructor1(&content, pArgs)
                }
                
            }
            
        }
        
    }
    
    
    /* Methods */
    
    static var method_size: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("size")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 3173160232)!
    }()
    
    /// Returns the number of entries in the dictionary. Empty dictionaries (`{ }`) always return `0`. See also ``isEmpty()``.
    public final func size()-> Int64 {
        var result: Int64 = Int64()
        GDictionary.method_size(&content, nil, &result, 0)
        return result
    }
    
    static var method_is_empty: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_empty")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if the dictionary is empty (its size is `0`). See also ``size()``.
    public final func isEmpty()-> Bool {
        var result: Bool = Bool()
        GDictionary.method_is_empty(&content, nil, &result, 0)
        return result
    }
    
    static var method_clear: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("clear")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 3218959716)!
    }()
    
    /// Clears the dictionary, removing all entries from it.
    public final func clear() {
        GDictionary.method_clear(&content, nil, nil, 0)
    }
    
    static var method_merge: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("merge")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 2079548978)!
    }()
    
    /// Adds entries from `dictionary` to this dictionary. By default, duplicate keys are not copied over, unless `overwrite` is `true`.
    /// 
    /// > Note: ``merge(dictionary:overwrite:)`` is _not_ recursive. Nested dictionaries are considered as keys that can be overwritten or not depending on the value of `overwrite`, but they will never be merged together.
    /// 
    public final func merge(dictionary: GDictionary, overwrite: Bool = false) {
        withUnsafePointer(to: dictionary.content) { pArg0 in
            withUnsafePointer(to: overwrite) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        GDictionary.method_merge(&content, pArgs, nil, 2)
                    }
                    
                }
                
            }
            
        }
        
    }
    
    static var method_merged: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("merged")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 2271165639)!
    }()
    
    /// Returns a copy of this dictionary merged with the other `dictionary`. By default, duplicate keys are not copied over, unless `overwrite` is `true`. See also ``merge(dictionary:overwrite:)``.
    /// 
    /// This method is useful for quickly making dictionaries with default values:
    /// 
    /// See also ``merge(dictionary:overwrite:)``.
    /// 
    public final func merged(dictionary: GDictionary, overwrite: Bool = false)-> GDictionary {
        let result: GDictionary = GDictionary()
        withUnsafePointer(to: dictionary.content) { pArg0 in
            withUnsafePointer(to: overwrite) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        GDictionary.method_merged(&content, pArgs, &result.content, 2)
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_has: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("has")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 3680194679)!
    }()
    
    /// Returns `true` if the dictionary contains an entry with the given `key`.
    /// 
    /// In GDScript, this is equivalent to the `in` operator:
    /// 
    /// > Note: This method returns `true` as long as the `key` exists, even if its corresponding value is `null`.
    /// 
    public final func has(key: Variant)-> Bool {
        var result: Bool = Bool()
        withUnsafePointer(to: key.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    GDictionary.method_has(&content, pArgs, &result, 1)
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_has_all: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("has_all")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 2988181878)!
    }()
    
    /// Returns `true` if the dictionary contains all keys in the given `keys` array.
    /// 
    public final func hasAll(keys: GArray)-> Bool {
        var result: Bool = Bool()
        withUnsafePointer(to: keys.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    GDictionary.method_has_all(&content, pArgs, &result, 1)
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_find_key: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("find_key")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 1988825835)!
    }()
    
    /// Finds and returns the first key whose associated value is equal to `value`, or `null` if it is not found.
    /// 
    /// > Note: `null` is also a valid key. If inside the dictionary, ``findKey(value:)`` may give misleading results.
    /// 
    public final func findKey(value: Variant)-> Variant {
        let result: Variant = Variant()
        withUnsafePointer(to: value.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    GDictionary.method_find_key(&content, pArgs, &result.content, 1)
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_erase: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("erase")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 1776646889)!
    }()
    
    /// Removes the dictionary entry by key, if it exists. Returns `true` if the given `key` existed in the dictionary, otherwise `false`.
    /// 
    /// > Note: Do not erase entries while iterating over the dictionary. You can iterate over the ``keys()`` array instead.
    /// 
    public final func erase(key: Variant)-> Bool {
        var result: Bool = Bool()
        withUnsafePointer(to: key.content) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    GDictionary.method_erase(&content, pArgs, &result, 1)
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_hash: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("hash")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 3173160232)!
    }()
    
    /// Returns a hashed 32-bit integer value representing the dictionary contents.
    /// 
    /// > Note: Dictionaries with the same entries but in a different order will not have the same hash.
    /// 
    /// > Note: Dictionaries with equal hash values are _not_ guaranteed to be the same, because of hash collisions. On the contrary, dictionaries with different hash values are guaranteed to be different.
    /// 
    public final func hash()-> Int64 {
        var result: Int64 = Int64()
        GDictionary.method_hash(&content, nil, &result, 0)
        return result
    }
    
    static var method_keys: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("keys")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 4144163970)!
    }()
    
    /// Returns the list of keys in the dictionary.
    public final func keys()-> GArray {
        let result: GArray = GArray()
        GDictionary.method_keys(&content, nil, &result.content, 0)
        return result
    }
    
    static var method_values: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("values")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 4144163970)!
    }()
    
    /// Returns the list of values in this dictionary.
    public final func values()-> GArray {
        let result: GArray = GArray()
        GDictionary.method_values(&content, nil, &result.content, 0)
        return result
    }
    
    static var method_duplicate: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("duplicate")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 830099069)!
    }()
    
    /// Creates and returns a new copy of the dictionary. If `deep` is `true`, inner ``GDictionary`` and ``GArray`` keys and values are also copied, recursively.
    public final func duplicate(deep: Bool = false)-> GDictionary {
        let result: GDictionary = GDictionary()
        withUnsafePointer(to: deep) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    GDictionary.method_duplicate(&content, pArgs, &result.content, 1)
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_get: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 2205440559)!
    }()
    
    /// Returns the corresponding value for the given `key` in the dictionary. If the `key` does not exist, returns `default`, or `null` if the parameter is omitted.
    public final func get(key: Variant, `default`: Variant)-> Variant {
        let result: Variant = Variant()
        withUnsafePointer(to: key.content) { pArg0 in
            withUnsafePointer(to: `default`.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        GDictionary.method_get(&content, pArgs, &result.content, 2)
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_get_or_add: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_or_add")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 1052551076)!
    }()
    
    /// Gets a value and ensures the key is set. If the `key` exists in the dictionary, this behaves like ``get(key:`default`:)``. Otherwise, the `default` value is inserted into the dictionary and returned.
    public final func getOrAdd(key: Variant, `default`: Variant)-> Variant {
        let result: Variant = Variant()
        withUnsafePointer(to: key.content) { pArg0 in
            withUnsafePointer(to: `default`.content) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        GDictionary.method_get_or_add(&content, pArgs, &result.content, 2)
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_make_read_only: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("make_read_only")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 3218959716)!
    }()
    
    /// Makes the dictionary read-only, i.e. disables modification of the dictionary's contents. Does not apply to nested content, e.g. content of nested dictionaries.
    public final func makeReadOnly() {
        GDictionary.method_make_read_only(&content, nil, nil, 0)
    }
    
    static var method_is_read_only: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_read_only")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if the dictionary is read-only. See ``makeReadOnly()``. Dictionaries are automatically read-only if declared with `const` keyword.
    public final func isReadOnly()-> Bool {
        var result: Bool = Bool()
        GDictionary.method_is_read_only(&content, nil, &result, 0)
        return result
    }
    
    static var method_recursive_equal: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("recursive_equal")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 1404404751)!
    }()
    
    /// Returns `true` if the two dictionaries contain the same keys and values, inner ``GDictionary`` and ``GArray`` keys and values are compared recursively.
    public final func recursiveEqual(dictionary: GDictionary, recursionCount: Int64)-> Bool {
        var result: Bool = Bool()
        withUnsafePointer(to: dictionary.content) { pArg0 in
            withUnsafePointer(to: recursionCount) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        GDictionary.method_recursive_equal(&content, pArgs, &result, 2)
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    private static var keyed_getter: GDExtensionPtrKeyedGetter = {
        return gi.variant_get_ptr_keyed_getter (GDEXTENSION_VARIANT_TYPE_DICTIONARY)!
    }()
    
    private static var keyed_setter: GDExtensionPtrKeyedSetter = {
        return gi.variant_get_ptr_keyed_setter (GDEXTENSION_VARIANT_TYPE_DICTIONARY)!
    }()
    
    private static var keyed_checker: GDExtensionPtrKeyedChecker = {
        return gi.variant_get_ptr_keyed_checker (GDEXTENSION_VARIANT_TYPE_DICTIONARY)!
    }()
    
    public subscript(key: Variant) -> Variant? {
        get {
            var result = Variant.zero
            if Self.keyed_checker(&content, &key.content) != 0 {
                Self.keyed_getter (&content, &key.content, &result)
                // Returns unowned handle
                return Variant(takingOver: result)
            } else {
                return nil
            }
        }
    
        set {                
            if let newValue {
                Self.keyed_setter(&content, &key.content, &newValue.content)
            } else {                    
                var nilContent = Variant.zero
                // nil will cause a crash, needs a pointer to Nil Variant content instead
                Self.keyed_setter(&content, &key.content, &nilContent)
            }                
        }
    }
    static var operator_3: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_EQUAL, GDEXTENSION_VARIANT_TYPE_DICTIONARY, GDEXTENSION_VARIANT_TYPE_DICTIONARY)!
    }()
    
    /// Returns `true` if the two dictionaries contain the same keys and values. The order of the entries does not matter.
    /// 
    /// > Note: In C#, by convention, this operator compares by **reference**. If you need to compare by value, iterate over both dictionaries.
    /// 
    public static func == (lhs: GDictionary, rhs: GDictionary) -> Bool  {
        var result: Bool = Bool()
        withUnsafePointer(to: lhs.content) { pArg0 in
            withUnsafePointer(to: rhs.content) { pArg1 in
                GDictionary.operator_3(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_4: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_NOT_EQUAL, GDEXTENSION_VARIANT_TYPE_DICTIONARY, GDEXTENSION_VARIANT_TYPE_DICTIONARY)!
    }()
    
    /// Returns `true` if the two dictionaries do not contain the same keys and values.
    public static func != (lhs: GDictionary, rhs: GDictionary) -> Bool  {
        var result: Bool = Bool()
        withUnsafePointer(to: lhs.content) { pArg0 in
            withUnsafePointer(to: rhs.content) { pArg1 in
                GDictionary.operator_4(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
}

