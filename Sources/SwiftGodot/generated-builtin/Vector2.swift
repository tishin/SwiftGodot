// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
import Foundation
#endif
/// A 2D vector using floating-point coordinates.
/// 
/// A 2-element structure that can be used to represent 2D coordinates or any other pair of numeric values.
/// 
/// It uses floating-point coordinates. By default, these floating-point values use 32-bit precision, unlike float which is always 64-bit. If double precision is needed, compile the engine with the option `precision=double`.
/// 
/// See ``Vector2i`` for its integer counterpart.
/// 
/// > Note: In a boolean context, a Vector2 will evaluate to `false` if it's equal to `Vector2(0, 0)`. Otherwise, a Vector2 will always evaluate to `true`.
/// 
public struct Vector2: Equatable, Hashable {
    /// The vector's X component. Also accessible by using the index position `[0]`.
    public var x: Float
    /// The vector's Y component. Also accessible by using the index position `[1]`.
    public var y: Float
    public enum Axis: Int64, CaseIterable, CustomDebugStringConvertible {
        /// Enumerated value for the X axis. Returned by ``maxAxisIndex()`` and ``minAxisIndex()``.
        case x = 0 // AXIS_X
        /// Enumerated value for the Y axis. Returned by ``maxAxisIndex()`` and ``minAxisIndex()``.
        case y = 1 // AXIS_Y
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            switch self {
                case .x: return ".x"
                case .y: return ".y"
            }
            
        }
        
    }
    
    static var constructor0: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_VECTOR2, 0)!
    
    /// Constructs a default-initialized ``Vector2`` with all components set to `0`.
    public init () {
        self.x = Float ()
        self.y = Float ()
    }
    
    static var constructor1: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_VECTOR2, 1)!
    
    /// Constructs a ``Vector2`` as a copy of the given ``Vector2``.
    public init (from: Vector2) {
        self.x = Float ()
        self.y = Float ()
        withUnsafePointer(to: from) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    Vector2.constructor1(&self, pArgs)
                }
                
            }
            
        }
        
    }
    
    static var constructor2: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_VECTOR2, 2)!
    
    /// Constructs a new ``Vector2`` from ``Vector2i``.
    public init (from: Vector2i) {
        self.x = Float ()
        self.y = Float ()
        withUnsafePointer(to: from) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    Vector2.constructor2(&self, pArgs)
                }
                
            }
            
        }
        
    }
    
    static var constructor3: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_VECTOR2, 3)!
    
    /// Constructs a new ``Vector2`` from the given `x` and `y`.
    public init (x: Float, y: Float) {
        self.x = x
        self.y = y
    }
    
    
    /* Methods */
    
    static var method_angle: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("angle")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 466405837)!
    }()
    
    /// Returns this vector's angle with respect to the positive X axis, or `(1, 0)` vector, in radians.
    /// 
    /// For example, `Vector2.RIGHT.angle()` will return zero, `Vector2.DOWN.angle()` will return `PI / 2` (a quarter turn, or 90 degrees), and `Vector2(1, -1).angle()` will return `-PI / 4` (a negative eighth turn, or -45 degrees).
    /// 
    /// <a href="https://raw.githubusercontent.com/godotengine/godot-docs/master/img/vector2_angle.png">Illustration of the returned angle.</a>
    /// 
    /// Equivalent to the result of ``@GlobalScope.atan2`` when called with the vector's ``y`` and ``x`` as parameters: `atan2(y, x)`.
    /// 
    public func angle()-> Double {
        var result: Double = Double()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Vector2.method_angle(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_angle_to: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("angle_to")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 3819070308)!
    }()
    
    /// Returns the angle to the given vector, in radians.
    /// 
    /// <a href="https://raw.githubusercontent.com/godotengine/godot-docs/master/img/vector2_angle_to.png">Illustration of the returned angle.</a>
    /// 
    public func angleTo(_ to: Vector2)-> Double {
        var result: Double = Double()
        withUnsafePointer(to: to) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Vector2.method_angle_to(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_angle_to_point: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("angle_to_point")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 3819070308)!
    }()
    
    /// Returns the angle between the line connecting the two points and the X axis, in radians.
    /// 
    /// `a.angle_to_point(b)` is equivalent of doing `(b - a).angle()`.
    /// 
    /// <a href="https://raw.githubusercontent.com/godotengine/godot-docs/master/img/vector2_angle_to_point.png">Illustration of the returned angle.</a>
    /// 
    public func angleToPoint(to: Vector2)-> Double {
        var result: Double = Double()
        withUnsafePointer(to: to) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Vector2.method_angle_to_point(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_direction_to: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("direction_to")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 2026743667)!
    }()
    
    /// Returns the normalized vector pointing from this vector to `to`. This is equivalent to using `(b - a).normalized()`.
    public func directionTo(_ to: Vector2)-> Vector2 {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: to) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Vector2.method_direction_to(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_distance_to: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("distance_to")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 3819070308)!
    }()
    
    /// Returns the distance between this vector and `to`.
    public func distanceTo(_ to: Vector2)-> Double {
        var result: Double = Double()
        withUnsafePointer(to: to) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Vector2.method_distance_to(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_distance_squared_to: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("distance_squared_to")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 3819070308)!
    }()
    
    /// Returns the squared distance between this vector and `to`.
    /// 
    /// This method runs faster than ``distanceTo(to:)``, so prefer it if you need to compare vectors or need the squared distance for some formula.
    /// 
    public func distanceSquaredTo(_ to: Vector2)-> Double {
        var result: Double = Double()
        withUnsafePointer(to: to) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Vector2.method_distance_squared_to(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_length: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("length")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 466405837)!
    }()
    
    /// Returns the length (magnitude) of this vector.
    public func length()-> Double {
        var result: Double = Double()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Vector2.method_length(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_length_squared: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("length_squared")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 466405837)!
    }()
    
    /// Returns the squared length (squared magnitude) of this vector.
    /// 
    /// This method runs faster than ``length()``, so prefer it if you need to compare vectors or need the squared distance for some formula.
    /// 
    public func lengthSquared()-> Double {
        var result: Double = Double()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Vector2.method_length_squared(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_limit_length: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("limit_length")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 2544004089)!
    }()
    
    /// Returns the vector with a maximum length by limiting its length to `length`.
    public func limitLength(_ length: Double = 1.0)-> Vector2 {
        var result: Vector2 = Vector2()
        let length = Double(length)
        withUnsafePointer(to: length) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Vector2.method_limit_length(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_normalized: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("normalized")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 2428350749)!
    }()
    
    /// Returns the result of scaling the vector to unit length. Equivalent to `v / v.length()`. Returns `(0, 0)` if `v.length() == 0`. See also ``isNormalized()``.
    /// 
    /// > Note: This function may return incorrect values if the input vector length is near zero.
    /// 
    public func normalized()-> Vector2 {
        var result: Vector2 = Vector2()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Vector2.method_normalized(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_is_normalized: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_normalized")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if the vector is normalized, i.e. its length is approximately equal to 1.
    public func isNormalized()-> Bool {
        var result: Bool = Bool()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Vector2.method_is_normalized(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_is_equal_approx: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_equal_approx")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 3190634762)!
    }()
    
    /// Returns `true` if this vector and `to` are approximately equal, by running ``@GlobalScope.is_equal_approx`` on each component.
    public func isEqualApprox(to: Vector2)-> Bool {
        var result: Bool = Bool()
        withUnsafePointer(to: to) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Vector2.method_is_equal_approx(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_is_zero_approx: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_zero_approx")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if this vector's values are approximately zero, by running ``@GlobalScope.is_zero_approx`` on each component.
    /// 
    /// This method is faster than using ``isEqualApprox(to:)`` with one value as a zero vector.
    /// 
    public func isZeroApprox()-> Bool {
        var result: Bool = Bool()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Vector2.method_is_zero_approx(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_is_finite: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_finite")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if this vector is finite, by calling ``@GlobalScope.is_finite`` on each component.
    public func isFinite()-> Bool {
        var result: Bool = Bool()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Vector2.method_is_finite(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_posmod: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("posmod")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 2544004089)!
    }()
    
    /// Returns a vector composed of the ``@GlobalScope.fposmod`` of this vector's components and `mod`.
    public func posmod(mod: Double)-> Vector2 {
        var result: Vector2 = Vector2()
        let mod = Double(mod)
        withUnsafePointer(to: mod) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Vector2.method_posmod(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_posmodv: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("posmodv")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 2026743667)!
    }()
    
    /// Returns a vector composed of the ``@GlobalScope.fposmod`` of this vector's components and `modv`'s components.
    public func posmodv(modv: Vector2)-> Vector2 {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: modv) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Vector2.method_posmodv(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_project: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("project")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 2026743667)!
    }()
    
    /// Returns a new vector resulting from projecting this vector onto the given vector `b`. The resulting new vector is parallel to `b`. See also ``slide(n:)``.
    /// 
    /// > Note: If the vector `b` is a zero vector, the components of the resulting new vector will be ``@GDScript.NAN``.
    /// 
    public func project(b: Vector2)-> Vector2 {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: b) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Vector2.method_project(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_slerp: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("slerp")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 4250033116)!
    }()
    
    /// Returns the result of spherical linear interpolation between this vector and `to`, by amount `weight`. `weight` is on the range of 0.0 to 1.0, representing the amount of interpolation.
    /// 
    /// This method also handles interpolating the lengths if the input vectors have different lengths. For the special case of one or both input vectors having zero length, this method behaves like ``lerp(to:weight:)``.
    /// 
    public func slerp(to: Vector2, weight: Double)-> Vector2 {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: to) { pArg0 in
            let weight = Double(weight)
            withUnsafePointer(to: weight) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        var mutSelfCopy = self
                        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                           Vector2.method_slerp(ptr, pArgs, &result, 2)
                        }
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_cubic_interpolate: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("cubic_interpolate")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 193522989)!
    }()
    
    /// Performs a cubic interpolation between this vector and `b` using `preA` and `postB` as handles, and returns the result at position `weight`. `weight` is on the range of 0.0 to 1.0, representing the amount of interpolation.
    public func cubicInterpolate(b: Vector2, preA: Vector2, postB: Vector2, weight: Double)-> Vector2 {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: b) { pArg0 in
            withUnsafePointer(to: preA) { pArg1 in
                withUnsafePointer(to: postB) { pArg2 in
                    let weight = Double(weight)
                    withUnsafePointer(to: weight) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                var mutSelfCopy = self
                                withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                                   Vector2.method_cubic_interpolate(ptr, pArgs, &result, 4)
                                }
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_cubic_interpolate_in_time: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("cubic_interpolate_in_time")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 1957055074)!
    }()
    
    /// Performs a cubic interpolation between this vector and `b` using `preA` and `postB` as handles, and returns the result at position `weight`. `weight` is on the range of 0.0 to 1.0, representing the amount of interpolation.
    /// 
    /// It can perform smoother interpolation than ``cubicInterpolate(b:preA:postB:weight:)`` by the time values.
    /// 
    public func cubicInterpolateInTime(b: Vector2, preA: Vector2, postB: Vector2, weight: Double, bT: Double, preAT: Double, postBT: Double)-> Vector2 {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: b) { pArg0 in
            withUnsafePointer(to: preA) { pArg1 in
                withUnsafePointer(to: postB) { pArg2 in
                    let weight = Double(weight)
                    withUnsafePointer(to: weight) { pArg3 in
                        let bT = Double(bT)
                        withUnsafePointer(to: bT) { pArg4 in
                            let preAT = Double(preAT)
                            withUnsafePointer(to: preAT) { pArg5 in
                                let postBT = Double(postBT)
                                withUnsafePointer(to: postBT) { pArg6 in
                                    withUnsafePointer(to: UnsafeRawPointersN7(pArg0, pArg1, pArg2, pArg3, pArg4, pArg5, pArg6)) { pArgs in
                                        pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 7) { pArgs in
                                            var mutSelfCopy = self
                                            withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                                               Vector2.method_cubic_interpolate_in_time(ptr, pArgs, &result, 7)
                                            }
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_bezier_interpolate: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("bezier_interpolate")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 193522989)!
    }()
    
    /// Returns the point at the given `t` on the <a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve">Bézier curve</a> defined by this vector and the given `control1`, `control2`, and `end` points.
    public func bezierInterpolate(control1: Vector2, control2: Vector2, end: Vector2, t: Double)-> Vector2 {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: control1) { pArg0 in
            withUnsafePointer(to: control2) { pArg1 in
                withUnsafePointer(to: end) { pArg2 in
                    let t = Double(t)
                    withUnsafePointer(to: t) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                var mutSelfCopy = self
                                withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                                   Vector2.method_bezier_interpolate(ptr, pArgs, &result, 4)
                                }
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_bezier_derivative: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("bezier_derivative")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 193522989)!
    }()
    
    /// Returns the derivative at the given `t` on the <a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve">Bézier curve</a> defined by this vector and the given `control1`, `control2`, and `end` points.
    public func bezierDerivative(control1: Vector2, control2: Vector2, end: Vector2, t: Double)-> Vector2 {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: control1) { pArg0 in
            withUnsafePointer(to: control2) { pArg1 in
                withUnsafePointer(to: end) { pArg2 in
                    let t = Double(t)
                    withUnsafePointer(to: t) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                var mutSelfCopy = self
                                withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                                   Vector2.method_bezier_derivative(ptr, pArgs, &result, 4)
                                }
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_max_axis_index: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("max_axis_index")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 3173160232)!
    }()
    
    /// Returns the axis of the vector's highest value. See `AXIS_*` constants. If all components are equal, this method returns .x.
    public func maxAxisIndex()-> Int64 {
        var result: Int64 = Int64()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Vector2.method_max_axis_index(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_min_axis_index: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("min_axis_index")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 3173160232)!
    }()
    
    /// Returns the axis of the vector's lowest value. See `AXIS_*` constants. If all components are equal, this method returns .y.
    public func minAxisIndex()-> Int64 {
        var result: Int64 = Int64()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Vector2.method_min_axis_index(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_move_toward: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("move_toward")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 4250033116)!
    }()
    
    /// Returns a new vector moved toward `to` by the fixed `delta` amount. Will not go past the final value.
    public func moveToward(to: Vector2, delta: Double)-> Vector2 {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: to) { pArg0 in
            let delta = Double(delta)
            withUnsafePointer(to: delta) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        var mutSelfCopy = self
                        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                           Vector2.method_move_toward(ptr, pArgs, &result, 2)
                        }
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_rotated: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("rotated")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 2544004089)!
    }()
    
    /// Returns the result of rotating this vector by `angle` (in radians). See also ``@GlobalScope.deg_to_rad``.
    public func rotated(angle: Double)-> Vector2 {
        var result: Vector2 = Vector2()
        let angle = Double(angle)
        withUnsafePointer(to: angle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Vector2.method_rotated(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_orthogonal: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("orthogonal")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 2428350749)!
    }()
    
    /// Returns a perpendicular vector rotated 90 degrees counter-clockwise compared to the original, with the same length.
    public func orthogonal()-> Vector2 {
        var result: Vector2 = Vector2()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Vector2.method_orthogonal(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_floor: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("floor")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 2428350749)!
    }()
    
    /// Returns a new vector with all components rounded down (towards negative infinity).
    public func floor()-> Vector2 {
        var result: Vector2 = Vector2()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Vector2.method_floor(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_ceil: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("ceil")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 2428350749)!
    }()
    
    /// Returns a new vector with all components rounded up (towards positive infinity).
    public func ceil()-> Vector2 {
        var result: Vector2 = Vector2()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Vector2.method_ceil(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_round: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("round")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 2428350749)!
    }()
    
    /// Returns a new vector with all components rounded to the nearest integer, with halfway cases rounded away from zero.
    public func round()-> Vector2 {
        var result: Vector2 = Vector2()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Vector2.method_round(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_aspect: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("aspect")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 466405837)!
    }()
    
    /// Returns the aspect ratio of this vector, the ratio of ``x`` to ``y``.
    public func aspect()-> Double {
        var result: Double = Double()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Vector2.method_aspect(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_dot: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("dot")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 3819070308)!
    }()
    
    /// Returns the dot product of this vector and `with`. This can be used to compare the angle between two vectors. For example, this can be used to determine whether an enemy is facing the player.
    /// 
    /// The dot product will be `0` for a right angle (90 degrees), greater than 0 for angles narrower than 90 degrees and lower than 0 for angles wider than 90 degrees.
    /// 
    /// When using unit (normalized) vectors, the result will always be between `-1.0` (180 degree angle) when the vectors are facing opposite directions, and `1.0` (0 degree angle) when the vectors are aligned.
    /// 
    /// > Note: `a.dot(b)` is equivalent to `b.dot(a)`.
    /// 
    public func dot(with: Vector2)-> Double {
        var result: Double = Double()
        withUnsafePointer(to: with) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Vector2.method_dot(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_slide: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("slide")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 2026743667)!
    }()
    
    /// Returns a new vector resulting from sliding this vector along a line with normal `n`. The resulting new vector is perpendicular to `n`, and is equivalent to this vector minus its projection on `n`. See also ``project(b:)``.
    /// 
    /// > Note: The vector `n` must be normalized. See also ``normalized()``.
    /// 
    public func slide(n: Vector2)-> Vector2 {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: n) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Vector2.method_slide(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_bounce: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("bounce")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 2026743667)!
    }()
    
    /// Returns the vector "bounced off" from a line defined by the given normal `n` perpendicular to the line.
    /// 
    /// > Note: ``bounce(n:)`` performs the operation that most engines and frameworks call [code skip-lint]reflect()`.
    /// 
    public func bounce(n: Vector2)-> Vector2 {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: n) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Vector2.method_bounce(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_reflect: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("reflect")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 2026743667)!
    }()
    
    /// Returns the result of reflecting the vector from a line defined by the given direction vector `line`.
    /// 
    /// > Note: ``reflect(line:)`` differs from what other engines and frameworks call [code skip-lint]reflect()`. In other engines, [code skip-lint]reflect()` takes a normal direction which is a direction perpendicular to the line. In Godot, you specify the direction of the line directly. See also ``bounce(n:)`` which does what most engines call [code skip-lint]reflect()`.
    /// 
    public func reflect(line: Vector2)-> Vector2 {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: line) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Vector2.method_reflect(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_cross: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("cross")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 3819070308)!
    }()
    
    /// Returns the 2D analog of the cross product for this vector and `with`.
    /// 
    /// This is the signed area of the parallelogram formed by the two vectors. If the second vector is clockwise from the first vector, then the cross product is the positive area. If counter-clockwise, the cross product is the negative area. If the two vectors are parallel this returns zero, making it useful for testing if two vectors are parallel.
    /// 
    /// > Note: Cross product is not defined in 2D mathematically. This method embeds the 2D vectors in the XY plane of 3D space and uses their cross product's Z component as the analog.
    /// 
    public func cross(with: Vector2)-> Double {
        var result: Double = Double()
        withUnsafePointer(to: with) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Vector2.method_cross(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_abs: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("abs")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 2428350749)!
    }()
    
    /// Returns a new vector with all components in absolute values (i.e. positive).
    public func abs()-> Vector2 {
        var result: Vector2 = Vector2()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Vector2.method_abs(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_sign: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("sign")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 2428350749)!
    }()
    
    /// Returns a new vector with each component set to `1.0` if it's positive, `-1.0` if it's negative, and `0.0` if it's zero. The result is identical to calling ``@GlobalScope.sign`` on each component.
    public func sign()-> Vector2 {
        var result: Vector2 = Vector2()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Vector2.method_sign(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_clamp: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("clamp")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 318031021)!
    }()
    
    /// Returns a new vector with all components clamped between the components of `min` and `max`, by running ``@GlobalScope.clamp`` on each component.
    public func clamp(min: Vector2, max: Vector2)-> Vector2 {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: min) { pArg0 in
            withUnsafePointer(to: max) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        var mutSelfCopy = self
                        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                           Vector2.method_clamp(ptr, pArgs, &result, 2)
                        }
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_clampf: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("clampf")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 3464402636)!
    }()
    
    /// Returns a new vector with all components clamped between `min` and `max`, by running ``@GlobalScope.clamp`` on each component.
    public func clampf(min: Double, max: Double)-> Vector2 {
        var result: Vector2 = Vector2()
        let min = Double(min)
        withUnsafePointer(to: min) { pArg0 in
            let max = Double(max)
            withUnsafePointer(to: max) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        var mutSelfCopy = self
                        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                           Vector2.method_clampf(ptr, pArgs, &result, 2)
                        }
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_snappedf: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("snappedf")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 2544004089)!
    }()
    
    /// Returns a new vector with each component snapped to the nearest multiple of `step`. This can also be used to round the components to an arbitrary number of decimals.
    public func snappedf(step: Double)-> Vector2 {
        var result: Vector2 = Vector2()
        let step = Double(step)
        withUnsafePointer(to: step) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Vector2.method_snappedf(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_min: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("min")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 2026743667)!
    }()
    
    /// Returns the component-wise minimum of this and `with`, equivalent to `Vector2(minf(x, with.x), minf(y, with.y))`.
    public func min(with: Vector2)-> Vector2 {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: with) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Vector2.method_min(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_minf: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("minf")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 2544004089)!
    }()
    
    /// Returns the component-wise minimum of this and `with`, equivalent to `Vector2(minf(x, with), minf(y, with))`.
    public func minf(with: Double)-> Vector2 {
        var result: Vector2 = Vector2()
        let with = Double(with)
        withUnsafePointer(to: with) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Vector2.method_minf(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_max: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("max")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 2026743667)!
    }()
    
    /// Returns the component-wise maximum of this and `with`, equivalent to `Vector2(maxf(x, with.x), maxf(y, with.y))`.
    public func max(with: Vector2)-> Vector2 {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: with) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Vector2.method_max(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_maxf: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("maxf")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 2544004089)!
    }()
    
    /// Returns the component-wise maximum of this and `with`, equivalent to `Vector2(maxf(x, with), maxf(y, with))`.
    public func maxf(with: Double)-> Vector2 {
        var result: Vector2 = Vector2()
        let with = Double(with)
        withUnsafePointer(to: with) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Vector2.method_maxf(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_from_angle: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("from_angle")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR2, &name.content, 889263119)!
    }()
    
    /// Creates a unit ``Vector2`` rotated to the given `angle` in radians. This is equivalent to doing `Vector2(cos(angle), sin(angle))` or `Vector2.RIGHT.rotated(angle)`.
    /// 
    public static func fromAngle(_ angle: Double)-> Vector2 {
        var result: Vector2 = Vector2()
        let angle = Double(angle)
        withUnsafePointer(to: angle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    Vector2.method_from_angle(nil, pArgs, &result, 1)
                }
                
            }
            
        }
        
        return result
    }
    
    private static var indexed_getter: GDExtensionPtrIndexedGetter = {
        return gi.variant_get_ptr_indexed_getter (GDEXTENSION_VARIANT_TYPE_VECTOR2)!
    }()
    
    private static var indexed_setter: GDExtensionPtrIndexedSetter = {
        return gi.variant_get_ptr_indexed_setter (GDEXTENSION_VARIANT_TYPE_VECTOR2)!
    }()
    
     public subscript (index: Int64) -> Double {
        mutating get {
            var result = Double ()
            Self.indexed_getter (&self, index, &result)
            return result
        }
        
        set {
            var value = newValue
            Self.indexed_setter (&self, index, &value)
        }
        
    }
    
    static var operator_5: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_VECTOR2, GDEXTENSION_VARIANT_TYPE_INT)!
    }()
    
    /// Multiplies each component of the ``Vector2`` by the given integer.
    public static func * (lhs: Vector2, rhs: Int64) -> Vector2  {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Vector2.operator_5(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_6: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_DIVIDE, GDEXTENSION_VARIANT_TYPE_VECTOR2, GDEXTENSION_VARIANT_TYPE_INT)!
    }()
    
    /// Divides each component of the ``Vector2`` by the given integer.
    public static func / (lhs: Vector2, rhs: Int64) -> Vector2  {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Vector2.operator_6(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_7: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_VECTOR2, GDEXTENSION_VARIANT_TYPE_FLOAT)!
    }()
    
    /// Multiplies each component of the ``Vector2`` by the given float.
    public static func * (lhs: Vector2, rhs: Double) -> Vector2  {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: lhs) { pArg0 in
            let rhs = Double(rhs)
            withUnsafePointer(to: rhs) { pArg1 in
                Vector2.operator_7(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_8: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_DIVIDE, GDEXTENSION_VARIANT_TYPE_VECTOR2, GDEXTENSION_VARIANT_TYPE_FLOAT)!
    }()
    
    /// Divides each component of the ``Vector2`` by the given float.
    public static func / (lhs: Vector2, rhs: Double) -> Vector2  {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: lhs) { pArg0 in
            let rhs = Double(rhs)
            withUnsafePointer(to: rhs) { pArg1 in
                Vector2.operator_8(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_9: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_EQUAL, GDEXTENSION_VARIANT_TYPE_VECTOR2, GDEXTENSION_VARIANT_TYPE_VECTOR2)!
    }()
    
    /// Returns `true` if the vectors are exactly equal.
    /// 
    /// > Note: Due to floating-point precision errors, consider using ``isEqualApprox(to:)`` instead, which is more reliable.
    /// 
    /// > Note: Vectors with ``@GDScript.NAN`` elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included.
    /// 
    public static func == (lhs: Vector2, rhs: Vector2) -> Bool  {
        var result: Bool = Bool()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Vector2.operator_9(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_10: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_NOT_EQUAL, GDEXTENSION_VARIANT_TYPE_VECTOR2, GDEXTENSION_VARIANT_TYPE_VECTOR2)!
    }()
    
    /// Returns `true` if the vectors are not equal.
    /// 
    /// > Note: Due to floating-point precision errors, consider using ``isEqualApprox(to:)`` instead, which is more reliable.
    /// 
    /// > Note: Vectors with ``@GDScript.NAN`` elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included.
    /// 
    public static func != (lhs: Vector2, rhs: Vector2) -> Bool  {
        var result: Bool = Bool()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Vector2.operator_10(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_11: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_LESS_EQUAL, GDEXTENSION_VARIANT_TYPE_VECTOR2, GDEXTENSION_VARIANT_TYPE_VECTOR2)!
    }()
    
    /// Compares two ``Vector2`` vectors by first checking if the X value of the left vector is less than the X value of the `right` vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors.
    /// 
    /// > Note: Vectors with ``@GDScript.NAN`` elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included.
    /// 
    public static func < (lhs: Vector2, rhs: Vector2) -> Bool  {
        var result: Bool = Bool()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Vector2.operator_11(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_12: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_LESS, GDEXTENSION_VARIANT_TYPE_VECTOR2, GDEXTENSION_VARIANT_TYPE_VECTOR2)!
    }()
    
    /// Compares two ``Vector2`` vectors by first checking if the X value of the left vector is less than or equal to the X value of the `right` vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors.
    /// 
    /// > Note: Vectors with ``@GDScript.NAN`` elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included.
    /// 
    public static func <= (lhs: Vector2, rhs: Vector2) -> Bool  {
        var result: Bool = Bool()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Vector2.operator_12(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_13: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_GREATER, GDEXTENSION_VARIANT_TYPE_VECTOR2, GDEXTENSION_VARIANT_TYPE_VECTOR2)!
    }()
    
    /// Compares two ``Vector2`` vectors by first checking if the X value of the left vector is greater than the X value of the `right` vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors.
    /// 
    /// > Note: Vectors with ``@GDScript.NAN`` elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included.
    /// 
    public static func > (lhs: Vector2, rhs: Vector2) -> Bool  {
        var result: Bool = Bool()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Vector2.operator_13(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_14: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_GREATER_EQUAL, GDEXTENSION_VARIANT_TYPE_VECTOR2, GDEXTENSION_VARIANT_TYPE_VECTOR2)!
    }()
    
    /// Compares two ``Vector2`` vectors by first checking if the X value of the left vector is greater than or equal to the X value of the `right` vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors.
    /// 
    /// > Note: Vectors with ``@GDScript.NAN`` elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included.
    /// 
    public static func >= (lhs: Vector2, rhs: Vector2) -> Bool  {
        var result: Bool = Bool()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Vector2.operator_14(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_15: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_ADD, GDEXTENSION_VARIANT_TYPE_VECTOR2, GDEXTENSION_VARIANT_TYPE_VECTOR2)!
    }()
    
    /// Adds each component of the ``Vector2`` by the components of the given ``Vector2``.
    /// 
    public static func + (lhs: Vector2, rhs: Vector2) -> Vector2  {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Vector2.operator_15(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_16: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_SUBTRACT, GDEXTENSION_VARIANT_TYPE_VECTOR2, GDEXTENSION_VARIANT_TYPE_VECTOR2)!
    }()
    
    /// Subtracts each component of the ``Vector2`` by the components of the given ``Vector2``.
    /// 
    public static func - (lhs: Vector2, rhs: Vector2) -> Vector2  {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Vector2.operator_16(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_17: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_VECTOR2, GDEXTENSION_VARIANT_TYPE_VECTOR2)!
    }()
    
    /// Multiplies each component of the ``Vector2`` by the components of the given ``Vector2``.
    /// 
    public static func * (lhs: Vector2, rhs: Vector2) -> Vector2  {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Vector2.operator_17(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_18: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_DIVIDE, GDEXTENSION_VARIANT_TYPE_VECTOR2, GDEXTENSION_VARIANT_TYPE_VECTOR2)!
    }()
    
    /// Divides each component of the ``Vector2`` by the components of the given ``Vector2``.
    /// 
    public static func / (lhs: Vector2, rhs: Vector2) -> Vector2  {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Vector2.operator_18(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_19: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_VECTOR2, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D)!
    }()
    
    /// Inversely transforms (multiplies) the ``Vector2`` by the given ``Transform2D`` transformation matrix, under the assumption that the transformation basis is orthonormal (i.e. rotation/reflection is fine, scaling/skew is not).
    /// 
    /// `vector * transform` is equivalent to `transform.inverse() * vector`. See ``Transform2D/inverse()``.
    /// 
    /// For transforming by inverse of an affine transformation (e.g. with scaling) `transform.affine_inverse() * vector` can be used instead. See ``Transform2D/affineInverse()``.
    /// 
    public static func * (lhs: Vector2, rhs: Transform2D) -> Vector2  {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Vector2.operator_19(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    /// Enumerated value for the X axis. Returned by ``maxAxisIndex()`` and ``minAxisIndex()``.
    public static let axisX = 0
    /// Enumerated value for the Y axis. Returned by ``maxAxisIndex()`` and ``minAxisIndex()``.
    public static let axisY = 1
    /// Zero vector, a vector with all components set to `0`.
    public static let zero = Vector2 (x: 0, y: 0)
    /// One vector, a vector with all components set to `1`.
    public static let one = Vector2 (x: 1, y: 1)
    /// Infinity vector, a vector with all components set to ``@GDScript.INF``.
    public static let inf = Vector2 (x: Float.infinity, y: Float.infinity)
    /// Left unit vector. Represents the direction of left.
    public static let left = Vector2 (x: -1, y: 0)
    /// Right unit vector. Represents the direction of right.
    public static let right = Vector2 (x: 1, y: 0)
    /// Up unit vector. Y is down in 2D, so this vector points -Y.
    public static let up = Vector2 (x: 0, y: -1)
    /// Down unit vector. Y is down in 2D, so this vector points +Y.
    public static let down = Vector2 (x: 0, y: 1)
}

