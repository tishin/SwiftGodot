// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// This file is autogenerated, do not edit
@_implementationOnly import GDExtension

#if CUSTOM_BUILTIN_IMPLEMENTATIONS
import Foundation
#endif
/// A 2×3 matrix representing a 2D transformation.
/// 
/// A 2×3 matrix (2 rows, 3 columns) used for 2D linear transformations. It can represent transformations such as translation, rotation, and scaling. It consists of three ``Vector2`` values: ``x``, ``y``, and the ``origin``.
/// 
/// For a general introduction, see the <a href="https://docs.godotengine.org/en//tutorials/math/matrices_and_transforms.html">Matrices and transforms</a> tutorial.
/// 
public struct Transform2D: Equatable, Hashable {
    /// The basis matrix's X vector (column 0). Equivalent to array index `0`.
    public var x: Vector2
    /// The basis matrix's Y vector (column 1). Equivalent to array index `1`.
    public var y: Vector2
    /// The origin vector (column 2, the third column). Equivalent to array index `2`. The origin vector represents translation.
    public var origin: Vector2
    static var constructor0: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, 0)!
    
    /// Constructs a default-initialized ``Transform2D`` set to ``IDENTITY``.
    public init () {
        self.x = Vector2 (x: 1, y: 0)
        self.y = Vector2 (x: 0, y: 1)
        self.origin = Vector2 ()
    }
    
    static var constructor1: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, 1)!
    
    /// Constructs a ``Transform2D`` as a copy of the given ``Transform2D``.
    public init (from: Transform2D) {
        self.x = Vector2 ()
        self.y = Vector2 ()
        self.origin = Vector2 ()
        withUnsafePointer(to: from) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    Transform2D.constructor1(&self, pArgs)
                }
                
            }
            
        }
        
    }
    
    static var constructor2: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, 2)!
    
    /// Constructs the transform from a given angle (in radians) and position.
    public init (rotation: Float, position: Vector2) {
        self.x = Vector2 ()
        self.y = Vector2 ()
        self.origin = Vector2 ()
        let rotation = Double(rotation)
        withUnsafePointer(to: rotation) { pArg0 in
            withUnsafePointer(to: position) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        Transform2D.constructor2(&self, pArgs)
                    }
                    
                }
                
            }
            
        }
        
    }
    
    static var constructor3: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, 3)!
    
    /// Constructs the transform from a given angle (in radians), scale, skew (in radians) and position.
    public init (rotation: Float, scale: Vector2, skew: Float, position: Vector2) {
        self.x = Vector2 ()
        self.y = Vector2 ()
        self.origin = Vector2 ()
        let rotation = Double(rotation)
        withUnsafePointer(to: rotation) { pArg0 in
            withUnsafePointer(to: scale) { pArg1 in
                let skew = Double(skew)
                withUnsafePointer(to: skew) { pArg2 in
                    withUnsafePointer(to: position) { pArg3 in
                        withUnsafePointer(to: UnsafeRawPointersN4(pArg0, pArg1, pArg2, pArg3)) { pArgs in
                            pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 4) { pArgs in
                                Transform2D.constructor3(&self, pArgs)
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
    }
    
    static var constructor4: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, 4)!
    
    /// Constructs the transform from 3 ``Vector2`` values representing ``x``, ``y``, and the ``origin`` (the three column vectors).
    public init (xAxis: Vector2, yAxis: Vector2, origin: Vector2) {
        self.x = xAxis
        self.y = yAxis
        self.origin = origin
    }
    
    
    /* Methods */
    
    static var method_inverse: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("inverse")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 1420440541)!
    }()
    
    /// Returns the inverse of the transform, under the assumption that the transformation basis is orthonormal (i.e. rotation/reflection is fine, scaling/skew is not). Use ``affineInverse()`` for non-orthonormal transforms (e.g. with scaling).
    public func inverse()-> Transform2D {
        var result: Transform2D = Transform2D()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Transform2D.method_inverse(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_affine_inverse: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("affine_inverse")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 1420440541)!
    }()
    
    /// Returns the inverse of the transform, under the assumption that the basis is invertible (must have non-zero determinant).
    public func affineInverse()-> Transform2D {
        var result: Transform2D = Transform2D()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Transform2D.method_affine_inverse(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_get_rotation: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_rotation")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 466405837)!
    }()
    
    /// Returns the transform's rotation (in radians).
    public func getRotation()-> Double {
        var result: Double = Double()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Transform2D.method_get_rotation(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_get_origin: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_origin")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 2428350749)!
    }()
    
    /// Returns the transform's origin (translation).
    public func getOrigin()-> Vector2 {
        var result: Vector2 = Vector2()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Transform2D.method_get_origin(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_get_scale: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_scale")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 2428350749)!
    }()
    
    /// Returns the scale.
    public func getScale()-> Vector2 {
        var result: Vector2 = Vector2()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Transform2D.method_get_scale(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_get_skew: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_skew")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 466405837)!
    }()
    
    /// Returns the transform's skew (in radians).
    public func getSkew()-> Double {
        var result: Double = Double()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Transform2D.method_get_skew(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_orthonormalized: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("orthonormalized")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 1420440541)!
    }()
    
    /// Returns the transform with the basis orthogonal (90 degrees), and normalized axis vectors (scale of 1 or -1).
    public func orthonormalized()-> Transform2D {
        var result: Transform2D = Transform2D()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Transform2D.method_orthonormalized(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_rotated: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("rotated")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 729597514)!
    }()
    
    /// Returns a copy of the transform rotated by the given `angle` (in radians).
    /// 
    /// This method is an optimized version of multiplying the given transform `X` with a corresponding rotation transform `R` from the left, i.e., `R * X`.
    /// 
    /// This can be seen as transforming with respect to the global/parent frame.
    /// 
    public func rotated(angle: Double)-> Transform2D {
        var result: Transform2D = Transform2D()
        let angle = Double(angle)
        withUnsafePointer(to: angle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Transform2D.method_rotated(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_rotated_local: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("rotated_local")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 729597514)!
    }()
    
    /// Returns a copy of the transform rotated by the given `angle` (in radians).
    /// 
    /// This method is an optimized version of multiplying the given transform `X` with a corresponding rotation transform `R` from the right, i.e., `X * R`.
    /// 
    /// This can be seen as transforming with respect to the local frame.
    /// 
    public func rotatedLocal(angle: Double)-> Transform2D {
        var result: Transform2D = Transform2D()
        let angle = Double(angle)
        withUnsafePointer(to: angle) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Transform2D.method_rotated_local(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_scaled: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("scaled")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 1446323263)!
    }()
    
    /// Returns a copy of the transform scaled by the given `scale` factor.
    /// 
    /// This method is an optimized version of multiplying the given transform `X` with a corresponding scaling transform `S` from the left, i.e., `S * X`.
    /// 
    /// This can be seen as transforming with respect to the global/parent frame.
    /// 
    public func scaled(scale: Vector2)-> Transform2D {
        var result: Transform2D = Transform2D()
        withUnsafePointer(to: scale) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Transform2D.method_scaled(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_scaled_local: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("scaled_local")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 1446323263)!
    }()
    
    /// Returns a copy of the transform scaled by the given `scale` factor.
    /// 
    /// This method is an optimized version of multiplying the given transform `X` with a corresponding scaling transform `S` from the right, i.e., `X * S`.
    /// 
    /// This can be seen as transforming with respect to the local frame.
    /// 
    public func scaledLocal(scale: Vector2)-> Transform2D {
        var result: Transform2D = Transform2D()
        withUnsafePointer(to: scale) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Transform2D.method_scaled_local(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_translated: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("translated")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 1446323263)!
    }()
    
    /// Returns a copy of the transform translated by the given `offset`.
    /// 
    /// This method is an optimized version of multiplying the given transform `X` with a corresponding translation transform `T` from the left, i.e., `T * X`.
    /// 
    /// This can be seen as transforming with respect to the global/parent frame.
    /// 
    public func translated(offset: Vector2)-> Transform2D {
        var result: Transform2D = Transform2D()
        withUnsafePointer(to: offset) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Transform2D.method_translated(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_translated_local: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("translated_local")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 1446323263)!
    }()
    
    /// Returns a copy of the transform translated by the given `offset`.
    /// 
    /// This method is an optimized version of multiplying the given transform `X` with a corresponding translation transform `T` from the right, i.e., `X * T`.
    /// 
    /// This can be seen as transforming with respect to the local frame.
    /// 
    public func translatedLocal(offset: Vector2)-> Transform2D {
        var result: Transform2D = Transform2D()
        withUnsafePointer(to: offset) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Transform2D.method_translated_local(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_determinant: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("determinant")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 466405837)!
    }()
    
    /// Returns the determinant of the basis matrix. If the basis is uniformly scaled, then its determinant equals the square of the scale factor.
    /// 
    /// A negative determinant means the basis was flipped, so one part of the scale is negative. A zero determinant means the basis isn't invertible, and is usually considered invalid.
    /// 
    public func determinant()-> Double {
        var result: Double = Double()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Transform2D.method_determinant(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_basis_xform: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("basis_xform")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 2026743667)!
    }()
    
    /// Returns a vector transformed (multiplied) by the basis matrix.
    /// 
    /// This method does not account for translation (the ``origin`` vector).
    /// 
    public func basisXform(v: Vector2)-> Vector2 {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: v) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Transform2D.method_basis_xform(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_basis_xform_inv: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("basis_xform_inv")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 2026743667)!
    }()
    
    /// Returns a vector transformed (multiplied) by the inverse basis matrix, under the assumption that the basis is orthonormal (i.e. rotation/reflection is fine, scaling/skew is not).
    /// 
    /// This method does not account for translation (the ``origin`` vector).
    /// 
    /// `transform.basis_xform_inv(vector)` is equivalent to `transform.inverse().basis_xform(vector)`. See ``inverse()``.
    /// 
    /// For non-orthonormal transforms (e.g. with scaling) `transform.affine_inverse().basis_xform(vector)` can be used instead. See ``affineInverse()``.
    /// 
    public func basisXformInv(v: Vector2)-> Vector2 {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: v) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Transform2D.method_basis_xform_inv(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_interpolate_with: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("interpolate_with")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 359399686)!
    }()
    
    /// Returns a transform interpolated between this transform and another by a given `weight` (on the range of 0.0 to 1.0).
    public func interpolateWith(xform: Transform2D, weight: Double)-> Transform2D {
        var result: Transform2D = Transform2D()
        withUnsafePointer(to: xform) { pArg0 in
            let weight = Double(weight)
            withUnsafePointer(to: weight) { pArg1 in
                withUnsafePointer(to: UnsafeRawPointersN2(pArg0, pArg1)) { pArgs in
                    pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 2) { pArgs in
                        var mutSelfCopy = self
                        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                           Transform2D.method_interpolate_with(ptr, pArgs, &result, 2)
                        }
                    }
                    
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_is_conformal: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_conformal")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if the transform's basis is conformal, meaning it preserves angles and distance ratios, and may only be composed of rotation and uniform scale. Returns `false` if the transform's basis has non-uniform scale or shear/skew. This can be used to validate if the transform is non-distorted, which is important for physics and other use cases.
    public func isConformal()-> Bool {
        var result: Bool = Bool()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Transform2D.method_is_conformal(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_is_equal_approx: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_equal_approx")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 3837431929)!
    }()
    
    /// Returns `true` if this transform and `xform` are approximately equal, by running ``@GlobalScope.is_equal_approx`` on each component.
    public func isEqualApprox(xform: Transform2D)-> Bool {
        var result: Bool = Bool()
        withUnsafePointer(to: xform) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Transform2D.method_is_equal_approx(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    static var method_is_finite: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_finite")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if this transform is finite, by calling ``@GlobalScope.is_finite`` on each component.
    public func isFinite()-> Bool {
        var result: Bool = Bool()
        var mutSelfCopy = self
        withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
           Transform2D.method_is_finite(ptr, nil, &result, 0)
        }
        return result
    }
    
    static var method_looking_at: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("looking_at")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 1446323263)!
    }()
    
    /// Returns a copy of the transform rotated such that the rotated X-axis points towards the `target` position.
    /// 
    /// Operations take place in global space.
    /// 
    public func lookingAt(target: Vector2 = Vector2 (x: 0, y: 0))-> Transform2D {
        var result: Transform2D = Transform2D()
        withUnsafePointer(to: target) { pArg0 in
            withUnsafePointer(to: UnsafeRawPointersN1(pArg0)) { pArgs in
                pArgs.withMemoryRebound(to: UnsafeRawPointer?.self, capacity: 1) { pArgs in
                    var mutSelfCopy = self
                    withUnsafeMutablePointer (to: &mutSelfCopy) { ptr in
                       Transform2D.method_looking_at(ptr, pArgs, &result, 1)
                    }
                }
                
            }
            
        }
        
        return result
    }
    
    private static var indexed_getter: GDExtensionPtrIndexedGetter = {
        return gi.variant_get_ptr_indexed_getter (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D)!
    }()
    
    private static var indexed_setter: GDExtensionPtrIndexedSetter = {
        return gi.variant_get_ptr_indexed_setter (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D)!
    }()
    
     public subscript (index: Int64) -> Vector2 {
        mutating get {
            var result = Vector2 ()
            Self.indexed_getter (&self, index, &result)
            return result
        }
        
        set {
            var value = newValue
            Self.indexed_setter (&self, index, &value)
        }
        
    }
    
    static var operator_3: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, GDEXTENSION_VARIANT_TYPE_INT)!
    }()
    
    /// This operator multiplies all components of the ``Transform2D``, including the ``origin`` vector, which scales it uniformly.
    public static func * (lhs: Transform2D, rhs: Int64) -> Transform2D  {
        var result: Transform2D = Transform2D()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Transform2D.operator_3(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_4: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_DIVIDE, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, GDEXTENSION_VARIANT_TYPE_INT)!
    }()
    
    /// This operator divides all components of the ``Transform2D``, including the ``origin`` vector, which inversely scales it uniformly.
    public static func / (lhs: Transform2D, rhs: Int64) -> Transform2D  {
        var result: Transform2D = Transform2D()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Transform2D.operator_4(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_5: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, GDEXTENSION_VARIANT_TYPE_FLOAT)!
    }()
    
    /// This operator multiplies all components of the ``Transform2D``, including the ``origin`` vector, which scales it uniformly.
    public static func * (lhs: Transform2D, rhs: Double) -> Transform2D  {
        var result: Transform2D = Transform2D()
        withUnsafePointer(to: lhs) { pArg0 in
            let rhs = Double(rhs)
            withUnsafePointer(to: rhs) { pArg1 in
                Transform2D.operator_5(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_6: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_DIVIDE, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, GDEXTENSION_VARIANT_TYPE_FLOAT)!
    }()
    
    /// This operator divides all components of the ``Transform2D``, including the ``origin`` vector, which inversely scales it uniformly.
    public static func / (lhs: Transform2D, rhs: Double) -> Transform2D  {
        var result: Transform2D = Transform2D()
        withUnsafePointer(to: lhs) { pArg0 in
            let rhs = Double(rhs)
            withUnsafePointer(to: rhs) { pArg1 in
                Transform2D.operator_6(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_7: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, GDEXTENSION_VARIANT_TYPE_VECTOR2)!
    }()
    
    /// Transforms (multiplies) the ``Vector2`` by the given ``Transform2D`` matrix.
    public static func * (lhs: Transform2D, rhs: Vector2) -> Vector2  {
        var result: Vector2 = Vector2()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Transform2D.operator_7(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_8: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, GDEXTENSION_VARIANT_TYPE_RECT2)!
    }()
    
    /// Transforms (multiplies) the ``Rect2`` by the given ``Transform2D`` matrix.
    public static func * (lhs: Transform2D, rhs: Rect2) -> Rect2  {
        var result: Rect2 = Rect2()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Transform2D.operator_8(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_9: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_EQUAL, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D)!
    }()
    
    /// Returns `true` if the transforms are exactly equal.
    /// 
    /// > Note: Due to floating-point precision errors, consider using ``isEqualApprox(xform:)`` instead, which is more reliable.
    /// 
    public static func == (lhs: Transform2D, rhs: Transform2D) -> Bool  {
        var result: Bool = Bool()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Transform2D.operator_9(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_10: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_NOT_EQUAL, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D)!
    }()
    
    /// Returns `true` if the transforms are not equal.
    /// 
    /// > Note: Due to floating-point precision errors, consider using ``isEqualApprox(xform:)`` instead, which is more reliable.
    /// 
    public static func != (lhs: Transform2D, rhs: Transform2D) -> Bool  {
        var result: Bool = Bool()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Transform2D.operator_10(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_11: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D)!
    }()
    
    /// Composes these two transformation matrices by multiplying them together. This has the effect of transforming the second transform (the child) by the first transform (the parent).
    public static func * (lhs: Transform2D, rhs: Transform2D) -> Transform2D  {
        var result: Transform2D = Transform2D()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs) { pArg1 in
                Transform2D.operator_11(pArg0, pArg1, &result)
            }
            
        }
        
        return result
    }
    
    static var operator_14: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR2_ARRAY)!
    }()
    
    /// Transforms (multiplies) each element of the ``Vector2`` array by the given ``Transform2D`` matrix.
    public static func * (lhs: Transform2D, rhs: PackedVector2Array) -> PackedVector2Array  {
        let result: PackedVector2Array = PackedVector2Array()
        withUnsafePointer(to: lhs) { pArg0 in
            withUnsafePointer(to: rhs.content) { pArg1 in
                Transform2D.operator_14(pArg0, pArg1, &result.content)
            }
            
        }
        
        return result
    }
    
    /// The identity ``Transform2D`` with no translation, rotation or scaling applied. When applied to other data structures, ``IDENTITY`` performs no transformation.
    public static let identity = Transform2D (xAxis: Vector2 (x: 1, y: 0), yAxis: Vector2 (x: 0, y: 1), origin: Vector2 (x: 0, y: 0))
    /// The ``Transform2D`` that will flip something along the X axis.
    public static let flipX = Transform2D (xAxis: Vector2 (x: -1, y: 0), yAxis: Vector2 (x: 0, y: 1), origin: Vector2 (x: 0, y: 0))
    /// The ``Transform2D`` that will flip something along the Y axis.
    public static let flipY = Transform2D (xAxis: Vector2 (x: 1, y: 0), yAxis: Vector2 (x: 0, y: -1), origin: Vector2 (x: 0, y: 0))
}

